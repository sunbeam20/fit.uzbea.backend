
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Permissions
 * 
 */
export type Permissions = $Result.DefaultSelection<Prisma.$PermissionsPayload>
/**
 * Model RolePermissions
 * 
 */
export type RolePermissions = $Result.DefaultSelection<Prisma.$RolePermissionsPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Suppliers
 * 
 */
export type Suppliers = $Result.DefaultSelection<Prisma.$SuppliersPayload>
/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model ProductSerials
 * 
 */
export type ProductSerials = $Result.DefaultSelection<Prisma.$ProductSerialsPayload>
/**
 * Model Expenses
 * 
 */
export type Expenses = $Result.DefaultSelection<Prisma.$ExpensesPayload>
/**
 * Model Sales
 * 
 */
export type Sales = $Result.DefaultSelection<Prisma.$SalesPayload>
/**
 * Model SalesItems
 * 
 */
export type SalesItems = $Result.DefaultSelection<Prisma.$SalesItemsPayload>
/**
 * Model SalesItemSerials
 * 
 */
export type SalesItemSerials = $Result.DefaultSelection<Prisma.$SalesItemSerialsPayload>
/**
 * Model SalesReturn
 * 
 */
export type SalesReturn = $Result.DefaultSelection<Prisma.$SalesReturnPayload>
/**
 * Model SalesReturnItems
 * 
 */
export type SalesReturnItems = $Result.DefaultSelection<Prisma.$SalesReturnItemsPayload>
/**
 * Model SalesReturnItemSerials
 * 
 */
export type SalesReturnItemSerials = $Result.DefaultSelection<Prisma.$SalesReturnItemSerialsPayload>
/**
 * Model Exchanges
 * 
 */
export type Exchanges = $Result.DefaultSelection<Prisma.$ExchangesPayload>
/**
 * Model ExchangesItems
 * 
 */
export type ExchangesItems = $Result.DefaultSelection<Prisma.$ExchangesItemsPayload>
/**
 * Model ExchangeItemSerials
 * 
 */
export type ExchangeItemSerials = $Result.DefaultSelection<Prisma.$ExchangeItemSerialsPayload>
/**
 * Model Purchases
 * 
 */
export type Purchases = $Result.DefaultSelection<Prisma.$PurchasesPayload>
/**
 * Model PurchasesItems
 * 
 */
export type PurchasesItems = $Result.DefaultSelection<Prisma.$PurchasesItemsPayload>
/**
 * Model PurchaseItemSerials
 * 
 */
export type PurchaseItemSerials = $Result.DefaultSelection<Prisma.$PurchaseItemSerialsPayload>
/**
 * Model PurchasesReturn
 * 
 */
export type PurchasesReturn = $Result.DefaultSelection<Prisma.$PurchasesReturnPayload>
/**
 * Model PurchasesReturnItems
 * 
 */
export type PurchasesReturnItems = $Result.DefaultSelection<Prisma.$PurchasesReturnItemsPayload>
/**
 * Model PurchaseReturnItemSerials
 * 
 */
export type PurchaseReturnItemSerials = $Result.DefaultSelection<Prisma.$PurchaseReturnItemSerialsPayload>
/**
 * Model Services
 * 
 */
export type Services = $Result.DefaultSelection<Prisma.$ServicesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ProductStatus: {
  Active: 'Active',
  Unavailable: 'Unavailable',
  Discontinued: 'Discontinued'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const ProductType: {
  New: 'New',
  PreOwned: 'PreOwned'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const SerialStatus: {
  Available: 'Available',
  Sold: 'Sold',
  Returned: 'Returned',
  Unavailable: 'Unavailable',
  InService: 'InService',
  Exchanged: 'Exchanged'
};

export type SerialStatus = (typeof SerialStatus)[keyof typeof SerialStatus]


export const Warranty: {
  Yes: 'Yes',
  No: 'No'
};

export type Warranty = (typeof Warranty)[keyof typeof Warranty]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type SerialStatus = $Enums.SerialStatus

export const SerialStatus: typeof $Enums.SerialStatus

export type Warranty = $Enums.Warranty

export const Warranty: typeof $Enums.Warranty

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Permissions
 * const permissions = await prisma.permissions.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permissions.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermissions`: Exposes CRUD operations for the **RolePermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermissions.findMany()
    * ```
    */
  get rolePermissions(): Prisma.RolePermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suppliers`: Exposes CRUD operations for the **Suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.suppliers.findMany()
    * ```
    */
  get suppliers(): Prisma.SuppliersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSerials`: Exposes CRUD operations for the **ProductSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSerials
    * const productSerials = await prisma.productSerials.findMany()
    * ```
    */
  get productSerials(): Prisma.ProductSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenses`: Exposes CRUD operations for the **Expenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expenses.findMany()
    * ```
    */
  get expenses(): Prisma.ExpensesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sales`: Exposes CRUD operations for the **Sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sales.findMany()
    * ```
    */
  get sales(): Prisma.SalesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesItems`: Exposes CRUD operations for the **SalesItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesItems
    * const salesItems = await prisma.salesItems.findMany()
    * ```
    */
  get salesItems(): Prisma.SalesItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesItemSerials`: Exposes CRUD operations for the **SalesItemSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesItemSerials
    * const salesItemSerials = await prisma.salesItemSerials.findMany()
    * ```
    */
  get salesItemSerials(): Prisma.SalesItemSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesReturn`: Exposes CRUD operations for the **SalesReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReturns
    * const salesReturns = await prisma.salesReturn.findMany()
    * ```
    */
  get salesReturn(): Prisma.SalesReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesReturnItems`: Exposes CRUD operations for the **SalesReturnItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReturnItems
    * const salesReturnItems = await prisma.salesReturnItems.findMany()
    * ```
    */
  get salesReturnItems(): Prisma.SalesReturnItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesReturnItemSerials`: Exposes CRUD operations for the **SalesReturnItemSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReturnItemSerials
    * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findMany()
    * ```
    */
  get salesReturnItemSerials(): Prisma.SalesReturnItemSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchanges`: Exposes CRUD operations for the **Exchanges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchanges
    * const exchanges = await prisma.exchanges.findMany()
    * ```
    */
  get exchanges(): Prisma.ExchangesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangesItems`: Exposes CRUD operations for the **ExchangesItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangesItems
    * const exchangesItems = await prisma.exchangesItems.findMany()
    * ```
    */
  get exchangesItems(): Prisma.ExchangesItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangeItemSerials`: Exposes CRUD operations for the **ExchangeItemSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeItemSerials
    * const exchangeItemSerials = await prisma.exchangeItemSerials.findMany()
    * ```
    */
  get exchangeItemSerials(): Prisma.ExchangeItemSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchases`: Exposes CRUD operations for the **Purchases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchases.findMany()
    * ```
    */
  get purchases(): Prisma.PurchasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasesItems`: Exposes CRUD operations for the **PurchasesItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasesItems
    * const purchasesItems = await prisma.purchasesItems.findMany()
    * ```
    */
  get purchasesItems(): Prisma.PurchasesItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItemSerials`: Exposes CRUD operations for the **PurchaseItemSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItemSerials
    * const purchaseItemSerials = await prisma.purchaseItemSerials.findMany()
    * ```
    */
  get purchaseItemSerials(): Prisma.PurchaseItemSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasesReturn`: Exposes CRUD operations for the **PurchasesReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasesReturns
    * const purchasesReturns = await prisma.purchasesReturn.findMany()
    * ```
    */
  get purchasesReturn(): Prisma.PurchasesReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchasesReturnItems`: Exposes CRUD operations for the **PurchasesReturnItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasesReturnItems
    * const purchasesReturnItems = await prisma.purchasesReturnItems.findMany()
    * ```
    */
  get purchasesReturnItems(): Prisma.PurchasesReturnItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReturnItemSerials`: Exposes CRUD operations for the **PurchaseReturnItemSerials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReturnItemSerials
    * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findMany()
    * ```
    */
  get purchaseReturnItemSerials(): Prisma.PurchaseReturnItemSerialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **Services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.ServicesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Permissions: 'Permissions',
    RolePermissions: 'RolePermissions',
    Roles: 'Roles',
    Session: 'Session',
    Users: 'Users',
    Customers: 'Customers',
    Suppliers: 'Suppliers',
    Categories: 'Categories',
    Products: 'Products',
    ProductSerials: 'ProductSerials',
    Expenses: 'Expenses',
    Sales: 'Sales',
    SalesItems: 'SalesItems',
    SalesItemSerials: 'SalesItemSerials',
    SalesReturn: 'SalesReturn',
    SalesReturnItems: 'SalesReturnItems',
    SalesReturnItemSerials: 'SalesReturnItemSerials',
    Exchanges: 'Exchanges',
    ExchangesItems: 'ExchangesItems',
    ExchangeItemSerials: 'ExchangeItemSerials',
    Purchases: 'Purchases',
    PurchasesItems: 'PurchasesItems',
    PurchaseItemSerials: 'PurchaseItemSerials',
    PurchasesReturn: 'PurchasesReturn',
    PurchasesReturnItems: 'PurchasesReturnItems',
    PurchaseReturnItemSerials: 'PurchaseReturnItemSerials',
    Services: 'Services'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "permissions" | "rolePermissions" | "roles" | "session" | "users" | "customers" | "suppliers" | "categories" | "products" | "productSerials" | "expenses" | "sales" | "salesItems" | "salesItemSerials" | "salesReturn" | "salesReturnItems" | "salesReturnItemSerials" | "exchanges" | "exchangesItems" | "exchangeItemSerials" | "purchases" | "purchasesItems" | "purchaseItemSerials" | "purchasesReturn" | "purchasesReturnItems" | "purchaseReturnItemSerials" | "services"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Permissions: {
        payload: Prisma.$PermissionsPayload<ExtArgs>
        fields: Prisma.PermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findFirst: {
            args: Prisma.PermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findMany: {
            args: Prisma.PermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          create: {
            args: Prisma.PermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          createMany: {
            args: Prisma.PermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          delete: {
            args: Prisma.PermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          update: {
            args: Prisma.PermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          deleteMany: {
            args: Prisma.PermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          upsert: {
            args: Prisma.PermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.PermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      RolePermissions: {
        payload: Prisma.$RolePermissionsPayload<ExtArgs>
        fields: Prisma.RolePermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findMany: {
            args: Prisma.RolePermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          create: {
            args: Prisma.RolePermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          createMany: {
            args: Prisma.RolePermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          update: {
            args: Prisma.RolePermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermissions>
          }
          groupBy: {
            args: Prisma.RolePermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Suppliers: {
        payload: Prisma.$SuppliersPayload<ExtArgs>
        fields: Prisma.SuppliersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuppliersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuppliersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findFirst: {
            args: Prisma.SuppliersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuppliersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findMany: {
            args: Prisma.SuppliersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>[]
          }
          create: {
            args: Prisma.SuppliersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          createMany: {
            args: Prisma.SuppliersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuppliersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>[]
          }
          delete: {
            args: Prisma.SuppliersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          update: {
            args: Prisma.SuppliersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          deleteMany: {
            args: Prisma.SuppliersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuppliersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuppliersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>[]
          }
          upsert: {
            args: Prisma.SuppliersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          aggregate: {
            args: Prisma.SuppliersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuppliers>
          }
          groupBy: {
            args: Prisma.SuppliersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuppliersGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuppliersCountArgs<ExtArgs>
            result: $Utils.Optional<SuppliersCountAggregateOutputType> | number
          }
        }
      }
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      ProductSerials: {
        payload: Prisma.$ProductSerialsPayload<ExtArgs>
        fields: Prisma.ProductSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          findFirst: {
            args: Prisma.ProductSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          findMany: {
            args: Prisma.ProductSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>[]
          }
          create: {
            args: Prisma.ProductSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          createMany: {
            args: Prisma.ProductSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>[]
          }
          delete: {
            args: Prisma.ProductSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          update: {
            args: Prisma.ProductSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          deleteMany: {
            args: Prisma.ProductSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>[]
          }
          upsert: {
            args: Prisma.ProductSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSerialsPayload>
          }
          aggregate: {
            args: Prisma.ProductSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSerials>
          }
          groupBy: {
            args: Prisma.ProductSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSerialsCountAggregateOutputType> | number
          }
        }
      }
      Expenses: {
        payload: Prisma.$ExpensesPayload<ExtArgs>
        fields: Prisma.ExpensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          findFirst: {
            args: Prisma.ExpensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          findMany: {
            args: Prisma.ExpensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>[]
          }
          create: {
            args: Prisma.ExpensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          createMany: {
            args: Prisma.ExpensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpensesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>[]
          }
          delete: {
            args: Prisma.ExpensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          update: {
            args: Prisma.ExpensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          deleteMany: {
            args: Prisma.ExpensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpensesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>[]
          }
          upsert: {
            args: Prisma.ExpensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          aggregate: {
            args: Prisma.ExpensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenses>
          }
          groupBy: {
            args: Prisma.ExpensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpensesCountArgs<ExtArgs>
            result: $Utils.Optional<ExpensesCountAggregateOutputType> | number
          }
        }
      }
      Sales: {
        payload: Prisma.$SalesPayload<ExtArgs>
        fields: Prisma.SalesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          findFirst: {
            args: Prisma.SalesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          findMany: {
            args: Prisma.SalesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>[]
          }
          create: {
            args: Prisma.SalesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          createMany: {
            args: Prisma.SalesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>[]
          }
          delete: {
            args: Prisma.SalesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          update: {
            args: Prisma.SalesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          deleteMany: {
            args: Prisma.SalesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>[]
          }
          upsert: {
            args: Prisma.SalesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesPayload>
          }
          aggregate: {
            args: Prisma.SalesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSales>
          }
          groupBy: {
            args: Prisma.SalesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesCountArgs<ExtArgs>
            result: $Utils.Optional<SalesCountAggregateOutputType> | number
          }
        }
      }
      SalesItems: {
        payload: Prisma.$SalesItemsPayload<ExtArgs>
        fields: Prisma.SalesItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          findFirst: {
            args: Prisma.SalesItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          findMany: {
            args: Prisma.SalesItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>[]
          }
          create: {
            args: Prisma.SalesItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          createMany: {
            args: Prisma.SalesItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>[]
          }
          delete: {
            args: Prisma.SalesItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          update: {
            args: Prisma.SalesItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          deleteMany: {
            args: Prisma.SalesItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>[]
          }
          upsert: {
            args: Prisma.SalesItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemsPayload>
          }
          aggregate: {
            args: Prisma.SalesItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesItems>
          }
          groupBy: {
            args: Prisma.SalesItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesItemsCountArgs<ExtArgs>
            result: $Utils.Optional<SalesItemsCountAggregateOutputType> | number
          }
        }
      }
      SalesItemSerials: {
        payload: Prisma.$SalesItemSerialsPayload<ExtArgs>
        fields: Prisma.SalesItemSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesItemSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesItemSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          findFirst: {
            args: Prisma.SalesItemSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesItemSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          findMany: {
            args: Prisma.SalesItemSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>[]
          }
          create: {
            args: Prisma.SalesItemSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          createMany: {
            args: Prisma.SalesItemSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesItemSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>[]
          }
          delete: {
            args: Prisma.SalesItemSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          update: {
            args: Prisma.SalesItemSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          deleteMany: {
            args: Prisma.SalesItemSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesItemSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesItemSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>[]
          }
          upsert: {
            args: Prisma.SalesItemSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesItemSerialsPayload>
          }
          aggregate: {
            args: Prisma.SalesItemSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesItemSerials>
          }
          groupBy: {
            args: Prisma.SalesItemSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesItemSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesItemSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<SalesItemSerialsCountAggregateOutputType> | number
          }
        }
      }
      SalesReturn: {
        payload: Prisma.$SalesReturnPayload<ExtArgs>
        fields: Prisma.SalesReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          findFirst: {
            args: Prisma.SalesReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          findMany: {
            args: Prisma.SalesReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>[]
          }
          create: {
            args: Prisma.SalesReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          createMany: {
            args: Prisma.SalesReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>[]
          }
          delete: {
            args: Prisma.SalesReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          update: {
            args: Prisma.SalesReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          deleteMany: {
            args: Prisma.SalesReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>[]
          }
          upsert: {
            args: Prisma.SalesReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnPayload>
          }
          aggregate: {
            args: Prisma.SalesReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReturn>
          }
          groupBy: {
            args: Prisma.SalesReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReturnCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnCountAggregateOutputType> | number
          }
        }
      }
      SalesReturnItems: {
        payload: Prisma.$SalesReturnItemsPayload<ExtArgs>
        fields: Prisma.SalesReturnItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReturnItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReturnItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          findFirst: {
            args: Prisma.SalesReturnItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReturnItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          findMany: {
            args: Prisma.SalesReturnItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>[]
          }
          create: {
            args: Prisma.SalesReturnItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          createMany: {
            args: Prisma.SalesReturnItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReturnItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>[]
          }
          delete: {
            args: Prisma.SalesReturnItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          update: {
            args: Prisma.SalesReturnItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          deleteMany: {
            args: Prisma.SalesReturnItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReturnItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesReturnItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>[]
          }
          upsert: {
            args: Prisma.SalesReturnItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemsPayload>
          }
          aggregate: {
            args: Prisma.SalesReturnItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReturnItems>
          }
          groupBy: {
            args: Prisma.SalesReturnItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReturnItemsCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnItemsCountAggregateOutputType> | number
          }
        }
      }
      SalesReturnItemSerials: {
        payload: Prisma.$SalesReturnItemSerialsPayload<ExtArgs>
        fields: Prisma.SalesReturnItemSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReturnItemSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          findFirst: {
            args: Prisma.SalesReturnItemSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReturnItemSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          findMany: {
            args: Prisma.SalesReturnItemSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>[]
          }
          create: {
            args: Prisma.SalesReturnItemSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          createMany: {
            args: Prisma.SalesReturnItemSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReturnItemSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>[]
          }
          delete: {
            args: Prisma.SalesReturnItemSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          update: {
            args: Prisma.SalesReturnItemSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          deleteMany: {
            args: Prisma.SalesReturnItemSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReturnItemSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>[]
          }
          upsert: {
            args: Prisma.SalesReturnItemSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnItemSerialsPayload>
          }
          aggregate: {
            args: Prisma.SalesReturnItemSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReturnItemSerials>
          }
          groupBy: {
            args: Prisma.SalesReturnItemSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnItemSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReturnItemSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnItemSerialsCountAggregateOutputType> | number
          }
        }
      }
      Exchanges: {
        payload: Prisma.$ExchangesPayload<ExtArgs>
        fields: Prisma.ExchangesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          findFirst: {
            args: Prisma.ExchangesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          findMany: {
            args: Prisma.ExchangesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>[]
          }
          create: {
            args: Prisma.ExchangesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          createMany: {
            args: Prisma.ExchangesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>[]
          }
          delete: {
            args: Prisma.ExchangesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          update: {
            args: Prisma.ExchangesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          deleteMany: {
            args: Prisma.ExchangesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>[]
          }
          upsert: {
            args: Prisma.ExchangesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesPayload>
          }
          aggregate: {
            args: Prisma.ExchangesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchanges>
          }
          groupBy: {
            args: Prisma.ExchangesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangesCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangesCountAggregateOutputType> | number
          }
        }
      }
      ExchangesItems: {
        payload: Prisma.$ExchangesItemsPayload<ExtArgs>
        fields: Prisma.ExchangesItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangesItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangesItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          findFirst: {
            args: Prisma.ExchangesItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangesItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          findMany: {
            args: Prisma.ExchangesItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>[]
          }
          create: {
            args: Prisma.ExchangesItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          createMany: {
            args: Prisma.ExchangesItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangesItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>[]
          }
          delete: {
            args: Prisma.ExchangesItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          update: {
            args: Prisma.ExchangesItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          deleteMany: {
            args: Prisma.ExchangesItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangesItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangesItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>[]
          }
          upsert: {
            args: Prisma.ExchangesItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangesItemsPayload>
          }
          aggregate: {
            args: Prisma.ExchangesItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangesItems>
          }
          groupBy: {
            args: Prisma.ExchangesItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangesItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangesItemsCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangesItemsCountAggregateOutputType> | number
          }
        }
      }
      ExchangeItemSerials: {
        payload: Prisma.$ExchangeItemSerialsPayload<ExtArgs>
        fields: Prisma.ExchangeItemSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeItemSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeItemSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          findFirst: {
            args: Prisma.ExchangeItemSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeItemSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          findMany: {
            args: Prisma.ExchangeItemSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>[]
          }
          create: {
            args: Prisma.ExchangeItemSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          createMany: {
            args: Prisma.ExchangeItemSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeItemSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>[]
          }
          delete: {
            args: Prisma.ExchangeItemSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          update: {
            args: Prisma.ExchangeItemSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          deleteMany: {
            args: Prisma.ExchangeItemSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeItemSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangeItemSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>[]
          }
          upsert: {
            args: Prisma.ExchangeItemSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeItemSerialsPayload>
          }
          aggregate: {
            args: Prisma.ExchangeItemSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeItemSerials>
          }
          groupBy: {
            args: Prisma.ExchangeItemSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeItemSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeItemSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeItemSerialsCountAggregateOutputType> | number
          }
        }
      }
      Purchases: {
        payload: Prisma.$PurchasesPayload<ExtArgs>
        fields: Prisma.PurchasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          findFirst: {
            args: Prisma.PurchasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          findMany: {
            args: Prisma.PurchasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>[]
          }
          create: {
            args: Prisma.PurchasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          createMany: {
            args: Prisma.PurchasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>[]
          }
          delete: {
            args: Prisma.PurchasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          update: {
            args: Prisma.PurchasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          deleteMany: {
            args: Prisma.PurchasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>[]
          }
          upsert: {
            args: Prisma.PurchasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesPayload>
          }
          aggregate: {
            args: Prisma.PurchasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchases>
          }
          groupBy: {
            args: Prisma.PurchasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasesCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasesCountAggregateOutputType> | number
          }
        }
      }
      PurchasesItems: {
        payload: Prisma.$PurchasesItemsPayload<ExtArgs>
        fields: Prisma.PurchasesItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasesItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasesItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          findFirst: {
            args: Prisma.PurchasesItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasesItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          findMany: {
            args: Prisma.PurchasesItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>[]
          }
          create: {
            args: Prisma.PurchasesItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          createMany: {
            args: Prisma.PurchasesItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasesItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>[]
          }
          delete: {
            args: Prisma.PurchasesItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          update: {
            args: Prisma.PurchasesItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          deleteMany: {
            args: Prisma.PurchasesItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasesItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasesItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>[]
          }
          upsert: {
            args: Prisma.PurchasesItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesItemsPayload>
          }
          aggregate: {
            args: Prisma.PurchasesItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasesItems>
          }
          groupBy: {
            args: Prisma.PurchasesItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasesItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasesItemsCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasesItemsCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItemSerials: {
        payload: Prisma.$PurchaseItemSerialsPayload<ExtArgs>
        fields: Prisma.PurchaseItemSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          update: {
            args: Prisma.PurchaseItemSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseItemSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseItemSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemSerialsPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItemSerials>
          }
          groupBy: {
            args: Prisma.PurchaseItemSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemSerialsCountAggregateOutputType> | number
          }
        }
      }
      PurchasesReturn: {
        payload: Prisma.$PurchasesReturnPayload<ExtArgs>
        fields: Prisma.PurchasesReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasesReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasesReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          findFirst: {
            args: Prisma.PurchasesReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasesReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          findMany: {
            args: Prisma.PurchasesReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>[]
          }
          create: {
            args: Prisma.PurchasesReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          createMany: {
            args: Prisma.PurchasesReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasesReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>[]
          }
          delete: {
            args: Prisma.PurchasesReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          update: {
            args: Prisma.PurchasesReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          deleteMany: {
            args: Prisma.PurchasesReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasesReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasesReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>[]
          }
          upsert: {
            args: Prisma.PurchasesReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnPayload>
          }
          aggregate: {
            args: Prisma.PurchasesReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasesReturn>
          }
          groupBy: {
            args: Prisma.PurchasesReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasesReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasesReturnCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasesReturnCountAggregateOutputType> | number
          }
        }
      }
      PurchasesReturnItems: {
        payload: Prisma.$PurchasesReturnItemsPayload<ExtArgs>
        fields: Prisma.PurchasesReturnItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasesReturnItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasesReturnItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          findFirst: {
            args: Prisma.PurchasesReturnItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasesReturnItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          findMany: {
            args: Prisma.PurchasesReturnItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>[]
          }
          create: {
            args: Prisma.PurchasesReturnItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          createMany: {
            args: Prisma.PurchasesReturnItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasesReturnItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>[]
          }
          delete: {
            args: Prisma.PurchasesReturnItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          update: {
            args: Prisma.PurchasesReturnItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          deleteMany: {
            args: Prisma.PurchasesReturnItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasesReturnItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchasesReturnItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>[]
          }
          upsert: {
            args: Prisma.PurchasesReturnItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasesReturnItemsPayload>
          }
          aggregate: {
            args: Prisma.PurchasesReturnItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasesReturnItems>
          }
          groupBy: {
            args: Prisma.PurchasesReturnItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasesReturnItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasesReturnItemsCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasesReturnItemsCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReturnItemSerials: {
        payload: Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>
        fields: Prisma.PurchaseReturnItemSerialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReturnItemSerialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          findFirst: {
            args: Prisma.PurchaseReturnItemSerialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReturnItemSerialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          findMany: {
            args: Prisma.PurchaseReturnItemSerialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>[]
          }
          create: {
            args: Prisma.PurchaseReturnItemSerialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          createMany: {
            args: Prisma.PurchaseReturnItemSerialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReturnItemSerialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>[]
          }
          delete: {
            args: Prisma.PurchaseReturnItemSerialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          update: {
            args: Prisma.PurchaseReturnItemSerialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReturnItemSerialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReturnItemSerialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReturnItemSerialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemSerialsPayload>
          }
          aggregate: {
            args: Prisma.PurchaseReturnItemSerialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReturnItemSerials>
          }
          groupBy: {
            args: Prisma.PurchaseReturnItemSerialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnItemSerialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReturnItemSerialsCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnItemSerialsCountAggregateOutputType> | number
          }
        }
      }
      Services: {
        payload: Prisma.$ServicesPayload<ExtArgs>
        fields: Prisma.ServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          findFirst: {
            args: Prisma.ServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          findMany: {
            args: Prisma.ServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          create: {
            args: Prisma.ServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          createMany: {
            args: Prisma.ServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          delete: {
            args: Prisma.ServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          update: {
            args: Prisma.ServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          deleteMany: {
            args: Prisma.ServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>[]
          }
          upsert: {
            args: Prisma.ServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.ServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    permissions?: PermissionsOmit
    rolePermissions?: RolePermissionsOmit
    roles?: RolesOmit
    session?: SessionOmit
    users?: UsersOmit
    customers?: CustomersOmit
    suppliers?: SuppliersOmit
    categories?: CategoriesOmit
    products?: ProductsOmit
    productSerials?: ProductSerialsOmit
    expenses?: ExpensesOmit
    sales?: SalesOmit
    salesItems?: SalesItemsOmit
    salesItemSerials?: SalesItemSerialsOmit
    salesReturn?: SalesReturnOmit
    salesReturnItems?: SalesReturnItemsOmit
    salesReturnItemSerials?: SalesReturnItemSerialsOmit
    exchanges?: ExchangesOmit
    exchangesItems?: ExchangesItemsOmit
    exchangeItemSerials?: ExchangeItemSerialsOmit
    purchases?: PurchasesOmit
    purchasesItems?: PurchasesItemsOmit
    purchaseItemSerials?: PurchaseItemSerialsOmit
    purchasesReturn?: PurchasesReturnOmit
    purchasesReturnItems?: PurchasesReturnItemsOmit
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsOmit
    services?: ServicesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    rolePermissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionsCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    Users: number
    rolePermissions: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | RolesCountOutputTypeCountUsersArgs
    rolePermissions?: boolean | RolesCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Session: number
    Sales: number
    SalesReturn: number
    Exchanges: number
    Purchases: number
    PurchasesReturn: number
    Services: number
    createdProducts: number
    updatedProducts: number
    expenses: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Session?: boolean | UsersCountOutputTypeCountSessionArgs
    Sales?: boolean | UsersCountOutputTypeCountSalesArgs
    SalesReturn?: boolean | UsersCountOutputTypeCountSalesReturnArgs
    Exchanges?: boolean | UsersCountOutputTypeCountExchangesArgs
    Purchases?: boolean | UsersCountOutputTypeCountPurchasesArgs
    PurchasesReturn?: boolean | UsersCountOutputTypeCountPurchasesReturnArgs
    Services?: boolean | UsersCountOutputTypeCountServicesArgs
    createdProducts?: boolean | UsersCountOutputTypeCountCreatedProductsArgs
    updatedProducts?: boolean | UsersCountOutputTypeCountUpdatedProductsArgs
    expenses?: boolean | UsersCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUpdatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpensesWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    Sales: number
    SalesReturn: number
    Exchanges: number
    Services: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | CustomersCountOutputTypeCountSalesArgs
    SalesReturn?: boolean | CustomersCountOutputTypeCountSalesReturnArgs
    Exchanges?: boolean | CustomersCountOutputTypeCountExchangesArgs
    Services?: boolean | CustomersCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountSalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhereInput
  }


  /**
   * Count Type SuppliersCountOutputType
   */

  export type SuppliersCountOutputType = {
    Purchases: number
    PurchasesReturn: number
    products: number
  }

  export type SuppliersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | SuppliersCountOutputTypeCountPurchasesArgs
    PurchasesReturn?: boolean | SuppliersCountOutputTypeCountPurchasesReturnArgs
    products?: boolean | SuppliersCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuppliersCountOutputType
     */
    select?: SuppliersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesWhereInput
  }

  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountPurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnWhereInput
  }

  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    Products: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | CategoriesCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    SalesItems: number
    SalesReturnItems: number
    exchangeItemsOld: number
    exchangeItemsNew: number
    PurchasesItems: number
    PurchasesReturnItems: number
    productSerials: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItems?: boolean | ProductsCountOutputTypeCountSalesItemsArgs
    SalesReturnItems?: boolean | ProductsCountOutputTypeCountSalesReturnItemsArgs
    exchangeItemsOld?: boolean | ProductsCountOutputTypeCountExchangeItemsOldArgs
    exchangeItemsNew?: boolean | ProductsCountOutputTypeCountExchangeItemsNewArgs
    PurchasesItems?: boolean | ProductsCountOutputTypeCountPurchasesItemsArgs
    PurchasesReturnItems?: boolean | ProductsCountOutputTypeCountPurchasesReturnItemsArgs
    productSerials?: boolean | ProductsCountOutputTypeCountProductSerialsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountSalesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountSalesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountExchangeItemsOldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountExchangeItemsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountPurchasesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountPurchasesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnItemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountProductSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSerialsWhereInput
  }


  /**
   * Count Type ProductSerialsCountOutputType
   */

  export type ProductSerialsCountOutputType = {
    SalesItemSerials: number
    salesReturnItemSerials: number
    purchaseItemSerials: number
    purchaseReturnItemSerials: number
    salesReturnItems: number
    exchangeItemSerialsOld: number
    exchangeItemSerialsNew: number
  }

  export type ProductSerialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItemSerials?: boolean | ProductSerialsCountOutputTypeCountSalesItemSerialsArgs
    salesReturnItemSerials?: boolean | ProductSerialsCountOutputTypeCountSalesReturnItemSerialsArgs
    purchaseItemSerials?: boolean | ProductSerialsCountOutputTypeCountPurchaseItemSerialsArgs
    purchaseReturnItemSerials?: boolean | ProductSerialsCountOutputTypeCountPurchaseReturnItemSerialsArgs
    salesReturnItems?: boolean | ProductSerialsCountOutputTypeCountSalesReturnItemsArgs
    exchangeItemSerialsOld?: boolean | ProductSerialsCountOutputTypeCountExchangeItemSerialsOldArgs
    exchangeItemSerialsNew?: boolean | ProductSerialsCountOutputTypeCountExchangeItemSerialsNewArgs
  }

  // Custom InputTypes
  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerialsCountOutputType
     */
    select?: ProductSerialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountSalesItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemSerialsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountSalesReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemSerialsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountPurchaseItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemSerialsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountPurchaseReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemSerialsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountSalesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountExchangeItemSerialsOldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeItemSerialsWhereInput
  }

  /**
   * ProductSerialsCountOutputType without action
   */
  export type ProductSerialsCountOutputTypeCountExchangeItemSerialsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeItemSerialsWhereInput
  }


  /**
   * Count Type SalesCountOutputType
   */

  export type SalesCountOutputType = {
    SalesItems: number
    SalesReturn: number
    Exchanges: number
  }

  export type SalesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItems?: boolean | SalesCountOutputTypeCountSalesItemsArgs
    SalesReturn?: boolean | SalesCountOutputTypeCountSalesReturnArgs
    Exchanges?: boolean | SalesCountOutputTypeCountExchangesArgs
  }

  // Custom InputTypes
  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesCountOutputType
     */
    select?: SalesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountSalesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemsWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountSalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnWhereInput
  }

  /**
   * SalesCountOutputType without action
   */
  export type SalesCountOutputTypeCountExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesWhereInput
  }


  /**
   * Count Type SalesItemsCountOutputType
   */

  export type SalesItemsCountOutputType = {
    salesItemSerials: number
  }

  export type SalesItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesItemSerials?: boolean | SalesItemsCountOutputTypeCountSalesItemSerialsArgs
  }

  // Custom InputTypes
  /**
   * SalesItemsCountOutputType without action
   */
  export type SalesItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemsCountOutputType
     */
    select?: SalesItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesItemsCountOutputType without action
   */
  export type SalesItemsCountOutputTypeCountSalesItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemSerialsWhereInput
  }


  /**
   * Count Type SalesReturnCountOutputType
   */

  export type SalesReturnCountOutputType = {
    SalesReturnItems: number
  }

  export type SalesReturnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnItems?: boolean | SalesReturnCountOutputTypeCountSalesReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * SalesReturnCountOutputType without action
   */
  export type SalesReturnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnCountOutputType
     */
    select?: SalesReturnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesReturnCountOutputType without action
   */
  export type SalesReturnCountOutputTypeCountSalesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemsWhereInput
  }


  /**
   * Count Type SalesReturnItemsCountOutputType
   */

  export type SalesReturnItemsCountOutputType = {
    salesReturnItemSerials: number
  }

  export type SalesReturnItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesReturnItemSerials?: boolean | SalesReturnItemsCountOutputTypeCountSalesReturnItemSerialsArgs
  }

  // Custom InputTypes
  /**
   * SalesReturnItemsCountOutputType without action
   */
  export type SalesReturnItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemsCountOutputType
     */
    select?: SalesReturnItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesReturnItemsCountOutputType without action
   */
  export type SalesReturnItemsCountOutputTypeCountSalesReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemSerialsWhereInput
  }


  /**
   * Count Type ExchangesCountOutputType
   */

  export type ExchangesCountOutputType = {
    ExchangeItems: number
  }

  export type ExchangesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExchangeItems?: boolean | ExchangesCountOutputTypeCountExchangeItemsArgs
  }

  // Custom InputTypes
  /**
   * ExchangesCountOutputType without action
   */
  export type ExchangesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesCountOutputType
     */
    select?: ExchangesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExchangesCountOutputType without action
   */
  export type ExchangesCountOutputTypeCountExchangeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesItemsWhereInput
  }


  /**
   * Count Type ExchangesItemsCountOutputType
   */

  export type ExchangesItemsCountOutputType = {
    exchangeItemSerials: number
  }

  export type ExchangesItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangeItemSerials?: boolean | ExchangesItemsCountOutputTypeCountExchangeItemSerialsArgs
  }

  // Custom InputTypes
  /**
   * ExchangesItemsCountOutputType without action
   */
  export type ExchangesItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItemsCountOutputType
     */
    select?: ExchangesItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExchangesItemsCountOutputType without action
   */
  export type ExchangesItemsCountOutputTypeCountExchangeItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeItemSerialsWhereInput
  }


  /**
   * Count Type PurchasesCountOutputType
   */

  export type PurchasesCountOutputType = {
    PurchasesItems: number
    PurchasesReturn: number
  }

  export type PurchasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesItems?: boolean | PurchasesCountOutputTypeCountPurchasesItemsArgs
    PurchasesReturn?: boolean | PurchasesCountOutputTypeCountPurchasesReturnArgs
  }

  // Custom InputTypes
  /**
   * PurchasesCountOutputType without action
   */
  export type PurchasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesCountOutputType
     */
    select?: PurchasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasesCountOutputType without action
   */
  export type PurchasesCountOutputTypeCountPurchasesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesItemsWhereInput
  }

  /**
   * PurchasesCountOutputType without action
   */
  export type PurchasesCountOutputTypeCountPurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnWhereInput
  }


  /**
   * Count Type PurchasesItemsCountOutputType
   */

  export type PurchasesItemsCountOutputType = {
    purchaseItemSerials: number
  }

  export type PurchasesItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItemSerials?: boolean | PurchasesItemsCountOutputTypeCountPurchaseItemSerialsArgs
  }

  // Custom InputTypes
  /**
   * PurchasesItemsCountOutputType without action
   */
  export type PurchasesItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItemsCountOutputType
     */
    select?: PurchasesItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasesItemsCountOutputType without action
   */
  export type PurchasesItemsCountOutputTypeCountPurchaseItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemSerialsWhereInput
  }


  /**
   * Count Type PurchasesReturnCountOutputType
   */

  export type PurchasesReturnCountOutputType = {
    PurchasesReturnItems: number
  }

  export type PurchasesReturnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesReturnItems?: boolean | PurchasesReturnCountOutputTypeCountPurchasesReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchasesReturnCountOutputType without action
   */
  export type PurchasesReturnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnCountOutputType
     */
    select?: PurchasesReturnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasesReturnCountOutputType without action
   */
  export type PurchasesReturnCountOutputTypeCountPurchasesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnItemsWhereInput
  }


  /**
   * Count Type PurchasesReturnItemsCountOutputType
   */

  export type PurchasesReturnItemsCountOutputType = {
    purchaseReturnItemSerials: number
  }

  export type PurchasesReturnItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseReturnItemSerials?: boolean | PurchasesReturnItemsCountOutputTypeCountPurchaseReturnItemSerialsArgs
  }

  // Custom InputTypes
  /**
   * PurchasesReturnItemsCountOutputType without action
   */
  export type PurchasesReturnItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItemsCountOutputType
     */
    select?: PurchasesReturnItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchasesReturnItemsCountOutputType without action
   */
  export type PurchasesReturnItemsCountOutputTypeCountPurchaseReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemSerialsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to aggregate.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithAggregationInput | PermissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rolePermissions?: boolean | Permissions$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type PermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["permissions"]>
  export type PermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permissions$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permissions"
    objects: {
      rolePermissions: Prisma.$RolePermissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsDefaultArgs> = $Result.GetResult<Prisma.$PermissionsPayload, S>

  type PermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface PermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permissions'], meta: { name: 'Permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionsFindUniqueArgs>(args: SelectSubset<T, PermissionsFindUniqueArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionsFindFirstArgs>(args?: SelectSubset<T, PermissionsFindFirstArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionsFindManyArgs>(args?: SelectSubset<T, PermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends PermissionsCreateArgs>(args: SelectSubset<T, PermissionsCreateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionsCreateManyArgs>(args?: SelectSubset<T, PermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends PermissionsDeleteArgs>(args: SelectSubset<T, PermissionsDeleteArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionsUpdateArgs>(args: SelectSubset<T, PermissionsUpdateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionsDeleteManyArgs>(args?: SelectSubset<T, PermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionsUpdateManyArgs>(args: SelectSubset<T, PermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends PermissionsUpsertArgs>(args: SelectSubset<T, PermissionsUpsertArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permissions model
   */
  readonly fields: PermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permissions$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permissions$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permissions model
   */
  interface PermissionsFieldRefs {
    readonly id: FieldRef<"Permissions", 'Int'>
    readonly name: FieldRef<"Permissions", 'String'>
    readonly description: FieldRef<"Permissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions create
   */
  export type PermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Permissions.
     */
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }

  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permissions createManyAndReturn
   */
  export type PermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Permissions.
     */
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions updateManyAndReturn
   */
  export type PermissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     */
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     */
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }

  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter which Permissions to delete.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permissions.rolePermissions
   */
  export type Permissions$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    cursor?: RolePermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * Permissions without action
   */
  export type PermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
  }


  /**
   * Model RolePermissions
   */

  export type AggregateRolePermissions = {
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  export type RolePermissionsAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
    permission_id: number | null
  }

  export type RolePermissionsSumAggregateOutputType = {
    id: number | null
    role_id: number | null
    permission_id: number | null
  }

  export type RolePermissionsMinAggregateOutputType = {
    id: number | null
    role_id: number | null
    permission_id: number | null
    can_view: boolean | null
    can_create: boolean | null
    can_edit: boolean | null
    can_delete: boolean | null
  }

  export type RolePermissionsMaxAggregateOutputType = {
    id: number | null
    role_id: number | null
    permission_id: number | null
    can_view: boolean | null
    can_create: boolean | null
    can_edit: boolean | null
    can_delete: boolean | null
  }

  export type RolePermissionsCountAggregateOutputType = {
    id: number
    role_id: number
    permission_id: number
    can_view: number
    can_create: number
    can_edit: number
    can_delete: number
    _all: number
  }


  export type RolePermissionsAvgAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionsSumAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionsMinAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
    can_view?: true
    can_create?: true
    can_edit?: true
    can_delete?: true
  }

  export type RolePermissionsMaxAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
    can_view?: true
    can_create?: true
    can_edit?: true
    can_delete?: true
  }

  export type RolePermissionsCountAggregateInputType = {
    id?: true
    role_id?: true
    permission_id?: true
    can_view?: true
    can_create?: true
    can_edit?: true
    can_delete?: true
    _all?: true
  }

  export type RolePermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to aggregate.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type GetRolePermissionsAggregateType<T extends RolePermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermissions[P]>
      : GetScalarType<T[P], AggregateRolePermissions[P]>
  }




  export type RolePermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithAggregationInput | RolePermissionsOrderByWithAggregationInput[]
    by: RolePermissionsScalarFieldEnum[] | RolePermissionsScalarFieldEnum
    having?: RolePermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionsCountAggregateInputType | true
    _avg?: RolePermissionsAvgAggregateInputType
    _sum?: RolePermissionsSumAggregateInputType
    _min?: RolePermissionsMinAggregateInputType
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type RolePermissionsGroupByOutputType = {
    id: number
    role_id: number
    permission_id: number
    can_view: boolean
    can_create: boolean
    can_edit: boolean
    can_delete: boolean
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  type GetRolePermissionsGroupByPayload<T extends RolePermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectScalar = {
    id?: boolean
    role_id?: boolean
    permission_id?: boolean
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_id" | "permission_id" | "can_view" | "can_create" | "can_edit" | "can_delete", ExtArgs["result"]["rolePermissions"]>
  export type RolePermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }
  export type RolePermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }
  export type RolePermissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | RolesDefaultArgs<ExtArgs>
    Permissions?: boolean | PermissionsDefaultArgs<ExtArgs>
  }

  export type $RolePermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermissions"
    objects: {
      Roles: Prisma.$RolesPayload<ExtArgs>
      Permissions: Prisma.$PermissionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_id: number
      permission_id: number
      can_view: boolean
      can_create: boolean
      can_edit: boolean
      can_delete: boolean
    }, ExtArgs["result"]["rolePermissions"]>
    composites: {}
  }

  type RolePermissionsGetPayload<S extends boolean | null | undefined | RolePermissionsDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionsPayload, S>

  type RolePermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionsCountAggregateInputType | true
    }

  export interface RolePermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermissions'], meta: { name: 'RolePermissions' } }
    /**
     * Find zero or one RolePermissions that matches the filter.
     * @param {RolePermissionsFindUniqueArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionsFindUniqueArgs>(args: SelectSubset<T, RolePermissionsFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionsFindUniqueOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionsFindFirstArgs>(args?: SelectSubset<T, RolePermissionsFindFirstArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionsWithIdOnly = await prisma.rolePermissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionsFindManyArgs>(args?: SelectSubset<T, RolePermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermissions.
     * @param {RolePermissionsCreateArgs} args - Arguments to create a RolePermissions.
     * @example
     * // Create one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.create({
     *   data: {
     *     // ... data to create a RolePermissions
     *   }
     * })
     * 
     */
    create<T extends RolePermissionsCreateArgs>(args: SelectSubset<T, RolePermissionsCreateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionsCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionsCreateManyArgs>(args?: SelectSubset<T, RolePermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionsCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionsWithIdOnly = await prisma.rolePermissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermissions.
     * @param {RolePermissionsDeleteArgs} args - Arguments to delete one RolePermissions.
     * @example
     * // Delete one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.delete({
     *   where: {
     *     // ... filter to delete one RolePermissions
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionsDeleteArgs>(args: SelectSubset<T, RolePermissionsDeleteArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermissions.
     * @param {RolePermissionsUpdateArgs} args - Arguments to update one RolePermissions.
     * @example
     * // Update one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionsUpdateArgs>(args: SelectSubset<T, RolePermissionsUpdateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionsDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionsDeleteManyArgs>(args?: SelectSubset<T, RolePermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionsUpdateManyArgs>(args: SelectSubset<T, RolePermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionsUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionsWithIdOnly = await prisma.rolePermissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermissions.
     * @param {RolePermissionsUpsertArgs} args - Arguments to update or create a RolePermissions.
     * @example
     * // Update or create a RolePermissions
     * const rolePermissions = await prisma.rolePermissions.upsert({
     *   create: {
     *     // ... data to create a RolePermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermissions we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionsUpsertArgs>(args: SelectSubset<T, RolePermissionsUpsertArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermissions.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionsCountArgs>(
      args?: Subset<T, RolePermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionsAggregateArgs>(args: Subset<T, RolePermissionsAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionsAggregateType<T>>

    /**
     * Group by RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionsGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermissions model
   */
  readonly fields: RolePermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Roles<T extends RolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolesDefaultArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Permissions<T extends PermissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionsDefaultArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermissions model
   */
  interface RolePermissionsFieldRefs {
    readonly id: FieldRef<"RolePermissions", 'Int'>
    readonly role_id: FieldRef<"RolePermissions", 'Int'>
    readonly permission_id: FieldRef<"RolePermissions", 'Int'>
    readonly can_view: FieldRef<"RolePermissions", 'Boolean'>
    readonly can_create: FieldRef<"RolePermissions", 'Boolean'>
    readonly can_edit: FieldRef<"RolePermissions", 'Boolean'>
    readonly can_delete: FieldRef<"RolePermissions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RolePermissions findUnique
   */
  export type RolePermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findUniqueOrThrow
   */
  export type RolePermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findFirst
   */
  export type RolePermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findFirstOrThrow
   */
  export type RolePermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findMany
   */
  export type RolePermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions create
   */
  export type RolePermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermissions.
     */
    data: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
  }

  /**
   * RolePermissions createMany
   */
  export type RolePermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissions createManyAndReturn
   */
  export type RolePermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermissions update
   */
  export type RolePermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermissions.
     */
    data: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
    /**
     * Choose, which RolePermissions to update.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions updateMany
   */
  export type RolePermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionsWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermissions updateManyAndReturn
   */
  export type RolePermissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionsWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermissions upsert
   */
  export type RolePermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermissions to update in case it exists.
     */
    where: RolePermissionsWhereUniqueInput
    /**
     * In case the RolePermissions found by the `where` argument doesn't exist, create a new RolePermissions with this data.
     */
    create: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
    /**
     * In case the RolePermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
  }

  /**
   * RolePermissions delete
   */
  export type RolePermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter which RolePermissions to delete.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions deleteMany
   */
  export type RolePermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionsWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermissions without action
   */
  export type RolePermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Users?: boolean | Roles$UsersArgs<ExtArgs>
    rolePermissions?: boolean | Roles$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Roles$UsersArgs<ExtArgs>
    rolePermissions?: boolean | Roles$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>[]
      rolePermissions: Prisma.$RolePermissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Roles$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Roles$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rolePermissions<T extends Roles$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Roles$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly name: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles.Users
   */
  export type Roles$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Roles.rolePermissions
   */
  export type Roles$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermissions
     */
    omit?: RolePermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    cursor?: RolePermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    role_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    email: string | null
    password: string | null
    status: $Enums.Status | null
    role_id: number | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    name: string | null
    email: string | null
    password: string | null
    status: $Enums.Status | null
    role_id: number | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    email: number
    password: number
    status: number
    role_id: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    permissionOverrides: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    role_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    role_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    password?: true
    status?: true
    role_id?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    password?: true
    status?: true
    role_id?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    password?: true
    status?: true
    role_id?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    permissionOverrides?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    userId: string
    name: string
    email: string
    password: string
    status: $Enums.Status
    role_id: number
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    permissionOverrides: JsonValue | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissionOverrides?: boolean
    Roles?: boolean | Users$RolesArgs<ExtArgs>
    Session?: boolean | Users$SessionArgs<ExtArgs>
    Sales?: boolean | Users$SalesArgs<ExtArgs>
    SalesReturn?: boolean | Users$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Users$ExchangesArgs<ExtArgs>
    Purchases?: boolean | Users$PurchasesArgs<ExtArgs>
    PurchasesReturn?: boolean | Users$PurchasesReturnArgs<ExtArgs>
    Services?: boolean | Users$ServicesArgs<ExtArgs>
    createdProducts?: boolean | Users$createdProductsArgs<ExtArgs>
    updatedProducts?: boolean | Users$updatedProductsArgs<ExtArgs>
    expenses?: boolean | Users$expensesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissionOverrides?: boolean
    Roles?: boolean | Users$RolesArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissionOverrides?: boolean
    Roles?: boolean | Users$RolesArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissionOverrides?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "email" | "password" | "status" | "role_id" | "phone" | "address" | "createdAt" | "updatedAt" | "permissionOverrides", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | Users$RolesArgs<ExtArgs>
    Session?: boolean | Users$SessionArgs<ExtArgs>
    Sales?: boolean | Users$SalesArgs<ExtArgs>
    SalesReturn?: boolean | Users$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Users$ExchangesArgs<ExtArgs>
    Purchases?: boolean | Users$PurchasesArgs<ExtArgs>
    PurchasesReturn?: boolean | Users$PurchasesReturnArgs<ExtArgs>
    Services?: boolean | Users$ServicesArgs<ExtArgs>
    createdProducts?: boolean | Users$createdProductsArgs<ExtArgs>
    updatedProducts?: boolean | Users$updatedProductsArgs<ExtArgs>
    expenses?: boolean | Users$expensesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | Users$RolesArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Roles?: boolean | Users$RolesArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Roles: Prisma.$RolesPayload<ExtArgs> | null
      Session: Prisma.$SessionPayload<ExtArgs>[]
      Sales: Prisma.$SalesPayload<ExtArgs>[]
      SalesReturn: Prisma.$SalesReturnPayload<ExtArgs>[]
      Exchanges: Prisma.$ExchangesPayload<ExtArgs>[]
      Purchases: Prisma.$PurchasesPayload<ExtArgs>[]
      PurchasesReturn: Prisma.$PurchasesReturnPayload<ExtArgs>[]
      Services: Prisma.$ServicesPayload<ExtArgs>[]
      createdProducts: Prisma.$ProductsPayload<ExtArgs>[]
      updatedProducts: Prisma.$ProductsPayload<ExtArgs>[]
      expenses: Prisma.$ExpensesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      name: string
      email: string
      password: string
      status: $Enums.Status
      role_id: number
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
      permissionOverrides: Prisma.JsonValue | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Roles<T extends Users$RolesArgs<ExtArgs> = {}>(args?: Subset<T, Users$RolesArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Session<T extends Users$SessionArgs<ExtArgs> = {}>(args?: Subset<T, Users$SessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Sales<T extends Users$SalesArgs<ExtArgs> = {}>(args?: Subset<T, Users$SalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesReturn<T extends Users$SalesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Users$SalesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Exchanges<T extends Users$ExchangesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ExchangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Purchases<T extends Users$PurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Users$PurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchasesReturn<T extends Users$PurchasesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Users$PurchasesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Services<T extends Users$ServicesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProducts<T extends Users$createdProductsArgs<ExtArgs> = {}>(args?: Subset<T, Users$createdProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedProducts<T extends Users$updatedProductsArgs<ExtArgs> = {}>(args?: Subset<T, Users$updatedProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Users$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Users$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly userId: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly status: FieldRef<"Users", 'Status'>
    readonly role_id: FieldRef<"Users", 'Int'>
    readonly phone: FieldRef<"Users", 'String'>
    readonly address: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly permissionOverrides: FieldRef<"Users", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.Roles
   */
  export type Users$RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
  }

  /**
   * Users.Session
   */
  export type Users$SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Users.Sales
   */
  export type Users$SalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    where?: SalesWhereInput
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    cursor?: SalesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * Users.SalesReturn
   */
  export type Users$SalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    where?: SalesReturnWhereInput
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    cursor?: SalesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * Users.Exchanges
   */
  export type Users$ExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    where?: ExchangesWhereInput
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    cursor?: ExchangesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Users.Purchases
   */
  export type Users$PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    where?: PurchasesWhereInput
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    cursor?: PurchasesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesScalarFieldEnum | PurchasesScalarFieldEnum[]
  }

  /**
   * Users.PurchasesReturn
   */
  export type Users$PurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    where?: PurchasesReturnWhereInput
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    cursor?: PurchasesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * Users.Services
   */
  export type Users$ServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    where?: ServicesWhereInput
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    cursor?: ServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Users.createdProducts
   */
  export type Users$createdProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Users.updatedProducts
   */
  export type Users$updatedProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Users.expenses
   */
  export type Users$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    where?: ExpensesWhereInput
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    cursor?: ExpensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    custId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    custId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    custId: number
    name: number
    email: number
    phone: number
    address: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    custId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    custId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    custId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    custId: string
    name: string
    email: string | null
    phone: string
    address: string | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    custId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    Sales?: boolean | Customers$SalesArgs<ExtArgs>
    SalesReturn?: boolean | Customers$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Customers$ExchangesArgs<ExtArgs>
    Services?: boolean | Customers$ServicesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    custId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    custId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectScalar = {
    id?: boolean
    custId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }

  export type CustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "custId" | "name" | "email" | "phone" | "address", ExtArgs["result"]["customers"]>
  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | Customers$SalesArgs<ExtArgs>
    SalesReturn?: boolean | Customers$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Customers$ExchangesArgs<ExtArgs>
    Services?: boolean | Customers$ServicesArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      Sales: Prisma.$SalesPayload<ExtArgs>[]
      SalesReturn: Prisma.$SalesReturnPayload<ExtArgs>[]
      Exchanges: Prisma.$ExchangesPayload<ExtArgs>[]
      Services: Prisma.$ServicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      custId: string
      name: string
      email: string | null
      phone: string
      address: string | null
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sales<T extends Customers$SalesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$SalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesReturn<T extends Customers$SalesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Customers$SalesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Exchanges<T extends Customers$ExchangesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$ExchangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Services<T extends Customers$ServicesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$ServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'Int'>
    readonly custId: FieldRef<"Customers", 'String'>
    readonly name: FieldRef<"Customers", 'String'>
    readonly email: FieldRef<"Customers", 'String'>
    readonly phone: FieldRef<"Customers", 'String'>
    readonly address: FieldRef<"Customers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers createManyAndReturn
   */
  export type CustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customers updateManyAndReturn
   */
  export type CustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customers.Sales
   */
  export type Customers$SalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    where?: SalesWhereInput
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    cursor?: SalesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * Customers.SalesReturn
   */
  export type Customers$SalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    where?: SalesReturnWhereInput
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    cursor?: SalesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * Customers.Exchanges
   */
  export type Customers$ExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    where?: ExchangesWhereInput
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    cursor?: ExchangesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Customers.Services
   */
  export type Customers$ServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    where?: ServicesWhereInput
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    cursor?: ServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model Suppliers
   */

  export type AggregateSuppliers = {
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  export type SuppliersAvgAggregateOutputType = {
    id: number | null
  }

  export type SuppliersSumAggregateOutputType = {
    id: number | null
  }

  export type SuppliersMinAggregateOutputType = {
    id: number | null
    suppId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
  }

  export type SuppliersMaxAggregateOutputType = {
    id: number | null
    suppId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
  }

  export type SuppliersCountAggregateOutputType = {
    id: number
    suppId: number
    name: number
    email: number
    phone: number
    address: number
    _all: number
  }


  export type SuppliersAvgAggregateInputType = {
    id?: true
  }

  export type SuppliersSumAggregateInputType = {
    id?: true
  }

  export type SuppliersMinAggregateInputType = {
    id?: true
    suppId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
  }

  export type SuppliersMaxAggregateInputType = {
    id?: true
    suppId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
  }

  export type SuppliersCountAggregateInputType = {
    id?: true
    suppId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    _all?: true
  }

  export type SuppliersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to aggregate.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SuppliersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuppliersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuppliersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuppliersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuppliersMaxAggregateInputType
  }

  export type GetSuppliersAggregateType<T extends SuppliersAggregateArgs> = {
        [P in keyof T & keyof AggregateSuppliers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuppliers[P]>
      : GetScalarType<T[P], AggregateSuppliers[P]>
  }




  export type SuppliersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuppliersWhereInput
    orderBy?: SuppliersOrderByWithAggregationInput | SuppliersOrderByWithAggregationInput[]
    by: SuppliersScalarFieldEnum[] | SuppliersScalarFieldEnum
    having?: SuppliersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuppliersCountAggregateInputType | true
    _avg?: SuppliersAvgAggregateInputType
    _sum?: SuppliersSumAggregateInputType
    _min?: SuppliersMinAggregateInputType
    _max?: SuppliersMaxAggregateInputType
  }

  export type SuppliersGroupByOutputType = {
    id: number
    suppId: string
    name: string
    email: string | null
    phone: string
    address: string | null
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  type GetSuppliersGroupByPayload<T extends SuppliersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuppliersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuppliersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
            : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
        }
      >
    >


  export type SuppliersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suppId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    Purchases?: boolean | Suppliers$PurchasesArgs<ExtArgs>
    PurchasesReturn?: boolean | Suppliers$PurchasesReturnArgs<ExtArgs>
    products?: boolean | Suppliers$productsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suppliers"]>

  export type SuppliersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suppId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }, ExtArgs["result"]["suppliers"]>

  export type SuppliersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suppId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }, ExtArgs["result"]["suppliers"]>

  export type SuppliersSelectScalar = {
    id?: boolean
    suppId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
  }

  export type SuppliersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "suppId" | "name" | "email" | "phone" | "address", ExtArgs["result"]["suppliers"]>
  export type SuppliersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | Suppliers$PurchasesArgs<ExtArgs>
    PurchasesReturn?: boolean | Suppliers$PurchasesReturnArgs<ExtArgs>
    products?: boolean | Suppliers$productsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuppliersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SuppliersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SuppliersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suppliers"
    objects: {
      Purchases: Prisma.$PurchasesPayload<ExtArgs>[]
      PurchasesReturn: Prisma.$PurchasesReturnPayload<ExtArgs>[]
      products: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      suppId: string
      name: string
      email: string | null
      phone: string
      address: string | null
    }, ExtArgs["result"]["suppliers"]>
    composites: {}
  }

  type SuppliersGetPayload<S extends boolean | null | undefined | SuppliersDefaultArgs> = $Result.GetResult<Prisma.$SuppliersPayload, S>

  type SuppliersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuppliersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuppliersCountAggregateInputType | true
    }

  export interface SuppliersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suppliers'], meta: { name: 'Suppliers' } }
    /**
     * Find zero or one Suppliers that matches the filter.
     * @param {SuppliersFindUniqueArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuppliersFindUniqueArgs>(args: SelectSubset<T, SuppliersFindUniqueArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suppliers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuppliersFindUniqueOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuppliersFindUniqueOrThrowArgs>(args: SelectSubset<T, SuppliersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuppliersFindFirstArgs>(args?: SelectSubset<T, SuppliersFindFirstArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suppliers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuppliersFindFirstOrThrowArgs>(args?: SelectSubset<T, SuppliersFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.suppliers.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.suppliers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suppliersWithIdOnly = await prisma.suppliers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuppliersFindManyArgs>(args?: SelectSubset<T, SuppliersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suppliers.
     * @param {SuppliersCreateArgs} args - Arguments to create a Suppliers.
     * @example
     * // Create one Suppliers
     * const Suppliers = await prisma.suppliers.create({
     *   data: {
     *     // ... data to create a Suppliers
     *   }
     * })
     * 
     */
    create<T extends SuppliersCreateArgs>(args: SelectSubset<T, SuppliersCreateArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SuppliersCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const suppliers = await prisma.suppliers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuppliersCreateManyArgs>(args?: SelectSubset<T, SuppliersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SuppliersCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const suppliers = await prisma.suppliers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const suppliersWithIdOnly = await prisma.suppliers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuppliersCreateManyAndReturnArgs>(args?: SelectSubset<T, SuppliersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suppliers.
     * @param {SuppliersDeleteArgs} args - Arguments to delete one Suppliers.
     * @example
     * // Delete one Suppliers
     * const Suppliers = await prisma.suppliers.delete({
     *   where: {
     *     // ... filter to delete one Suppliers
     *   }
     * })
     * 
     */
    delete<T extends SuppliersDeleteArgs>(args: SelectSubset<T, SuppliersDeleteArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suppliers.
     * @param {SuppliersUpdateArgs} args - Arguments to update one Suppliers.
     * @example
     * // Update one Suppliers
     * const suppliers = await prisma.suppliers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuppliersUpdateArgs>(args: SelectSubset<T, SuppliersUpdateArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SuppliersDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.suppliers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuppliersDeleteManyArgs>(args?: SelectSubset<T, SuppliersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const suppliers = await prisma.suppliers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuppliersUpdateManyArgs>(args: SelectSubset<T, SuppliersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SuppliersUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const suppliers = await prisma.suppliers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const suppliersWithIdOnly = await prisma.suppliers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuppliersUpdateManyAndReturnArgs>(args: SelectSubset<T, SuppliersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suppliers.
     * @param {SuppliersUpsertArgs} args - Arguments to update or create a Suppliers.
     * @example
     * // Update or create a Suppliers
     * const suppliers = await prisma.suppliers.upsert({
     *   create: {
     *     // ... data to create a Suppliers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suppliers we want to update
     *   }
     * })
     */
    upsert<T extends SuppliersUpsertArgs>(args: SelectSubset<T, SuppliersUpsertArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.suppliers.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SuppliersCountArgs>(
      args?: Subset<T, SuppliersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuppliersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuppliersAggregateArgs>(args: Subset<T, SuppliersAggregateArgs>): Prisma.PrismaPromise<GetSuppliersAggregateType<T>>

    /**
     * Group by Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuppliersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuppliersGroupByArgs['orderBy'] }
        : { orderBy?: SuppliersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuppliersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuppliersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suppliers model
   */
  readonly fields: SuppliersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suppliers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuppliersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Purchases<T extends Suppliers$PurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$PurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchasesReturn<T extends Suppliers$PurchasesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$PurchasesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Suppliers$productsArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Suppliers model
   */
  interface SuppliersFieldRefs {
    readonly id: FieldRef<"Suppliers", 'Int'>
    readonly suppId: FieldRef<"Suppliers", 'String'>
    readonly name: FieldRef<"Suppliers", 'String'>
    readonly email: FieldRef<"Suppliers", 'String'>
    readonly phone: FieldRef<"Suppliers", 'String'>
    readonly address: FieldRef<"Suppliers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Suppliers findUnique
   */
  export type SuppliersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers findUniqueOrThrow
   */
  export type SuppliersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers findFirst
   */
  export type SuppliersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers findFirstOrThrow
   */
  export type SuppliersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers findMany
   */
  export type SuppliersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }

  /**
   * Suppliers create
   */
  export type SuppliersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to create a Suppliers.
     */
    data: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
  }

  /**
   * Suppliers createMany
   */
  export type SuppliersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SuppliersCreateManyInput | SuppliersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suppliers createManyAndReturn
   */
  export type SuppliersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SuppliersCreateManyInput | SuppliersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suppliers update
   */
  export type SuppliersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to update a Suppliers.
     */
    data: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
    /**
     * Choose, which Suppliers to update.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers updateMany
   */
  export type SuppliersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SuppliersUpdateManyMutationInput, SuppliersUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SuppliersWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Suppliers updateManyAndReturn
   */
  export type SuppliersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SuppliersUpdateManyMutationInput, SuppliersUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SuppliersWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Suppliers upsert
   */
  export type SuppliersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The filter to search for the Suppliers to update in case it exists.
     */
    where: SuppliersWhereUniqueInput
    /**
     * In case the Suppliers found by the `where` argument doesn't exist, create a new Suppliers with this data.
     */
    create: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
    /**
     * In case the Suppliers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
  }

  /**
   * Suppliers delete
   */
  export type SuppliersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter which Suppliers to delete.
     */
    where: SuppliersWhereUniqueInput
  }

  /**
   * Suppliers deleteMany
   */
  export type SuppliersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SuppliersWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Suppliers.Purchases
   */
  export type Suppliers$PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    where?: PurchasesWhereInput
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    cursor?: PurchasesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesScalarFieldEnum | PurchasesScalarFieldEnum[]
  }

  /**
   * Suppliers.PurchasesReturn
   */
  export type Suppliers$PurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    where?: PurchasesReturnWhereInput
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    cursor?: PurchasesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * Suppliers.products
   */
  export type Suppliers$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Suppliers without action
   */
  export type SuppliersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
  }


  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    name: string
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Products?: boolean | Categories$ProductsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["categories"]>
  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | Categories$ProductsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      Products: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesFindUniqueArgs>(args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesFindFirstArgs>(args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriesFindManyArgs>(args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends CategoriesCreateArgs>(args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesCreateManyArgs>(args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends CategoriesDeleteArgs>(args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesUpdateArgs>(args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesDeleteManyArgs>(args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesUpdateManyArgs>(args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesUpsertArgs>(args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Products<T extends Categories$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, Categories$ProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categories model
   */
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'Int'>
    readonly name: FieldRef<"Categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories createManyAndReturn
   */
  export type CategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Categories updateManyAndReturn
   */
  export type CategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Categories.Products
   */
  export type Categories$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    purchasePrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    category_id: number | null
    supplier_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    purchasePrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    category_id: number | null
    supplier_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    productCode: string | null
    name: string | null
    specification: string | null
    description: string | null
    quantity: number | null
    purchasePrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    useIndividualSerials: boolean | null
    productType: $Enums.ProductType | null
    status: $Enums.ProductStatus | null
    category_id: number | null
    supplier_id: number | null
    created_by: number | null
    updated_by: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    productCode: string | null
    name: string | null
    specification: string | null
    description: string | null
    quantity: number | null
    purchasePrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    useIndividualSerials: boolean | null
    productType: $Enums.ProductType | null
    status: $Enums.ProductStatus | null
    category_id: number | null
    supplier_id: number | null
    created_by: number | null
    updated_by: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    productCode: number
    name: number
    specification: number
    description: number
    quantity: number
    purchasePrice: number
    wholesalePrice: number
    retailPrice: number
    useIndividualSerials: number
    productType: number
    status: number
    category_id: number
    supplier_id: number
    created_by: number
    updated_by: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    quantity?: true
    purchasePrice?: true
    wholesalePrice?: true
    retailPrice?: true
    category_id?: true
    supplier_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    quantity?: true
    purchasePrice?: true
    wholesalePrice?: true
    retailPrice?: true
    category_id?: true
    supplier_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    specification?: true
    description?: true
    quantity?: true
    purchasePrice?: true
    wholesalePrice?: true
    retailPrice?: true
    useIndividualSerials?: true
    productType?: true
    status?: true
    category_id?: true
    supplier_id?: true
    created_by?: true
    updated_by?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    specification?: true
    description?: true
    quantity?: true
    purchasePrice?: true
    wholesalePrice?: true
    retailPrice?: true
    useIndividualSerials?: true
    productType?: true
    status?: true
    category_id?: true
    supplier_id?: true
    created_by?: true
    updated_by?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    productCode?: true
    name?: true
    specification?: true
    description?: true
    quantity?: true
    purchasePrice?: true
    wholesalePrice?: true
    retailPrice?: true
    useIndividualSerials?: true
    productType?: true
    status?: true
    category_id?: true
    supplier_id?: true
    created_by?: true
    updated_by?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    productCode: string
    name: string
    specification: string | null
    description: string | null
    quantity: number
    purchasePrice: Decimal
    wholesalePrice: Decimal
    retailPrice: Decimal
    useIndividualSerials: boolean
    productType: $Enums.ProductType
    status: $Enums.ProductStatus
    category_id: number
    supplier_id: number | null
    created_by: number | null
    updated_by: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productCode?: boolean
    name?: boolean
    specification?: boolean
    description?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    useIndividualSerials?: boolean
    productType?: boolean
    status?: boolean
    category_id?: boolean
    supplier_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
    SalesItems?: boolean | Products$SalesItemsArgs<ExtArgs>
    SalesReturnItems?: boolean | Products$SalesReturnItemsArgs<ExtArgs>
    exchangeItemsOld?: boolean | Products$exchangeItemsOldArgs<ExtArgs>
    exchangeItemsNew?: boolean | Products$exchangeItemsNewArgs<ExtArgs>
    PurchasesItems?: boolean | Products$PurchasesItemsArgs<ExtArgs>
    PurchasesReturnItems?: boolean | Products$PurchasesReturnItemsArgs<ExtArgs>
    productSerials?: boolean | Products$productSerialsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productCode?: boolean
    name?: boolean
    specification?: boolean
    description?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    useIndividualSerials?: boolean
    productType?: boolean
    status?: boolean
    category_id?: boolean
    supplier_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productCode?: boolean
    name?: boolean
    specification?: boolean
    description?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    useIndividualSerials?: boolean
    productType?: boolean
    status?: boolean
    category_id?: boolean
    supplier_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectScalar = {
    id?: boolean
    productCode?: boolean
    name?: boolean
    specification?: boolean
    description?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    useIndividualSerials?: boolean
    productType?: boolean
    status?: boolean
    category_id?: boolean
    supplier_id?: boolean
    created_by?: boolean
    updated_by?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productCode" | "name" | "specification" | "description" | "quantity" | "purchasePrice" | "wholesalePrice" | "retailPrice" | "useIndividualSerials" | "productType" | "status" | "category_id" | "supplier_id" | "created_by" | "updated_by" | "createdAt" | "updatedAt", ExtArgs["result"]["products"]>
  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
    SalesItems?: boolean | Products$SalesItemsArgs<ExtArgs>
    SalesReturnItems?: boolean | Products$SalesReturnItemsArgs<ExtArgs>
    exchangeItemsOld?: boolean | Products$exchangeItemsOldArgs<ExtArgs>
    exchangeItemsNew?: boolean | Products$exchangeItemsNewArgs<ExtArgs>
    PurchasesItems?: boolean | Products$PurchasesItemsArgs<ExtArgs>
    PurchasesReturnItems?: boolean | Products$PurchasesReturnItemsArgs<ExtArgs>
    productSerials?: boolean | Products$productSerialsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
  }
  export type ProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | Products$CategoriesArgs<ExtArgs>
    supplier?: boolean | Products$supplierArgs<ExtArgs>
    creator?: boolean | Products$creatorArgs<ExtArgs>
    updater?: boolean | Products$updaterArgs<ExtArgs>
  }

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      Categories: Prisma.$CategoriesPayload<ExtArgs> | null
      supplier: Prisma.$SuppliersPayload<ExtArgs> | null
      creator: Prisma.$UsersPayload<ExtArgs> | null
      updater: Prisma.$UsersPayload<ExtArgs> | null
      SalesItems: Prisma.$SalesItemsPayload<ExtArgs>[]
      SalesReturnItems: Prisma.$SalesReturnItemsPayload<ExtArgs>[]
      exchangeItemsOld: Prisma.$ExchangesItemsPayload<ExtArgs>[]
      exchangeItemsNew: Prisma.$ExchangesItemsPayload<ExtArgs>[]
      PurchasesItems: Prisma.$PurchasesItemsPayload<ExtArgs>[]
      PurchasesReturnItems: Prisma.$PurchasesReturnItemsPayload<ExtArgs>[]
      productSerials: Prisma.$ProductSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productCode: string
      name: string
      specification: string | null
      description: string | null
      quantity: number
      purchasePrice: Prisma.Decimal
      wholesalePrice: Prisma.Decimal
      retailPrice: Prisma.Decimal
      useIndividualSerials: boolean
      productType: $Enums.ProductType
      status: $Enums.ProductStatus
      category_id: number
      supplier_id: number | null
      created_by: number | null
      updated_by: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Categories<T extends Products$CategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Products$CategoriesArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplier<T extends Products$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Products$supplierArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends Products$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Products$creatorArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updater<T extends Products$updaterArgs<ExtArgs> = {}>(args?: Subset<T, Products$updaterArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SalesItems<T extends Products$SalesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Products$SalesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesReturnItems<T extends Products$SalesReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Products$SalesReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeItemsOld<T extends Products$exchangeItemsOldArgs<ExtArgs> = {}>(args?: Subset<T, Products$exchangeItemsOldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeItemsNew<T extends Products$exchangeItemsNewArgs<ExtArgs> = {}>(args?: Subset<T, Products$exchangeItemsNewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchasesItems<T extends Products$PurchasesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Products$PurchasesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchasesReturnItems<T extends Products$PurchasesReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Products$PurchasesReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productSerials<T extends Products$productSerialsArgs<ExtArgs> = {}>(args?: Subset<T, Products$productSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */
  interface ProductsFieldRefs {
    readonly id: FieldRef<"Products", 'Int'>
    readonly productCode: FieldRef<"Products", 'String'>
    readonly name: FieldRef<"Products", 'String'>
    readonly specification: FieldRef<"Products", 'String'>
    readonly description: FieldRef<"Products", 'String'>
    readonly quantity: FieldRef<"Products", 'Int'>
    readonly purchasePrice: FieldRef<"Products", 'Decimal'>
    readonly wholesalePrice: FieldRef<"Products", 'Decimal'>
    readonly retailPrice: FieldRef<"Products", 'Decimal'>
    readonly useIndividualSerials: FieldRef<"Products", 'Boolean'>
    readonly productType: FieldRef<"Products", 'ProductType'>
    readonly status: FieldRef<"Products", 'ProductStatus'>
    readonly category_id: FieldRef<"Products", 'Int'>
    readonly supplier_id: FieldRef<"Products", 'Int'>
    readonly created_by: FieldRef<"Products", 'Int'>
    readonly updated_by: FieldRef<"Products", 'Int'>
    readonly createdAt: FieldRef<"Products", 'DateTime'>
    readonly updatedAt: FieldRef<"Products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products createManyAndReturn
   */
  export type ProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Products updateManyAndReturn
   */
  export type ProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Products.Categories
   */
  export type Products$CategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    where?: CategoriesWhereInput
  }

  /**
   * Products.supplier
   */
  export type Products$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suppliers
     */
    omit?: SuppliersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuppliersInclude<ExtArgs> | null
    where?: SuppliersWhereInput
  }

  /**
   * Products.creator
   */
  export type Products$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Products.updater
   */
  export type Products$updaterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Products.SalesItems
   */
  export type Products$SalesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    where?: SalesItemsWhereInput
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    cursor?: SalesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesItemsScalarFieldEnum | SalesItemsScalarFieldEnum[]
  }

  /**
   * Products.SalesReturnItems
   */
  export type Products$SalesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    where?: SalesReturnItemsWhereInput
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    cursor?: SalesReturnItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * Products.exchangeItemsOld
   */
  export type Products$exchangeItemsOldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    where?: ExchangesItemsWhereInput
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    cursor?: ExchangesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * Products.exchangeItemsNew
   */
  export type Products$exchangeItemsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    where?: ExchangesItemsWhereInput
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    cursor?: ExchangesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * Products.PurchasesItems
   */
  export type Products$PurchasesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    where?: PurchasesItemsWhereInput
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    cursor?: PurchasesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesItemsScalarFieldEnum | PurchasesItemsScalarFieldEnum[]
  }

  /**
   * Products.PurchasesReturnItems
   */
  export type Products$PurchasesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    where?: PurchasesReturnItemsWhereInput
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    cursor?: PurchasesReturnItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesReturnItemsScalarFieldEnum | PurchasesReturnItemsScalarFieldEnum[]
  }

  /**
   * Products.productSerials
   */
  export type Products$productSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    where?: ProductSerialsWhereInput
    orderBy?: ProductSerialsOrderByWithRelationInput | ProductSerialsOrderByWithRelationInput[]
    cursor?: ProductSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductSerialsScalarFieldEnum | ProductSerialsScalarFieldEnum[]
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model ProductSerials
   */

  export type AggregateProductSerials = {
    _count: ProductSerialsCountAggregateOutputType | null
    _avg: ProductSerialsAvgAggregateOutputType | null
    _sum: ProductSerialsSumAggregateOutputType | null
    _min: ProductSerialsMinAggregateOutputType | null
    _max: ProductSerialsMaxAggregateOutputType | null
  }

  export type ProductSerialsAvgAggregateOutputType = {
    id: number | null
    product_id: number | null
  }

  export type ProductSerialsSumAggregateOutputType = {
    id: number | null
    product_id: number | null
  }

  export type ProductSerialsMinAggregateOutputType = {
    id: number | null
    serial: string | null
    product_id: number | null
    status: $Enums.SerialStatus | null
    warranty: $Enums.Warranty | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSerialsMaxAggregateOutputType = {
    id: number | null
    serial: string | null
    product_id: number | null
    status: $Enums.SerialStatus | null
    warranty: $Enums.Warranty | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSerialsCountAggregateOutputType = {
    id: number
    serial: number
    product_id: number
    status: number
    warranty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductSerialsAvgAggregateInputType = {
    id?: true
    product_id?: true
  }

  export type ProductSerialsSumAggregateInputType = {
    id?: true
    product_id?: true
  }

  export type ProductSerialsMinAggregateInputType = {
    id?: true
    serial?: true
    product_id?: true
    status?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSerialsMaxAggregateInputType = {
    id?: true
    serial?: true
    product_id?: true
    status?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSerialsCountAggregateInputType = {
    id?: true
    serial?: true
    product_id?: true
    status?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSerials to aggregate.
     */
    where?: ProductSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSerials to fetch.
     */
    orderBy?: ProductSerialsOrderByWithRelationInput | ProductSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSerials
    **/
    _count?: true | ProductSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSerialsMaxAggregateInputType
  }

  export type GetProductSerialsAggregateType<T extends ProductSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSerials[P]>
      : GetScalarType<T[P], AggregateProductSerials[P]>
  }




  export type ProductSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSerialsWhereInput
    orderBy?: ProductSerialsOrderByWithAggregationInput | ProductSerialsOrderByWithAggregationInput[]
    by: ProductSerialsScalarFieldEnum[] | ProductSerialsScalarFieldEnum
    having?: ProductSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSerialsCountAggregateInputType | true
    _avg?: ProductSerialsAvgAggregateInputType
    _sum?: ProductSerialsSumAggregateInputType
    _min?: ProductSerialsMinAggregateInputType
    _max?: ProductSerialsMaxAggregateInputType
  }

  export type ProductSerialsGroupByOutputType = {
    id: number
    serial: string
    product_id: number
    status: $Enums.SerialStatus
    warranty: $Enums.Warranty
    createdAt: Date
    updatedAt: Date
    _count: ProductSerialsCountAggregateOutputType | null
    _avg: ProductSerialsAvgAggregateOutputType | null
    _sum: ProductSerialsSumAggregateOutputType | null
    _min: ProductSerialsMinAggregateOutputType | null
    _max: ProductSerialsMaxAggregateOutputType | null
  }

  type GetProductSerialsGroupByPayload<T extends ProductSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSerialsGroupByOutputType[P]>
        }
      >
    >


  export type ProductSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    product_id?: boolean
    status?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
    SalesItemSerials?: boolean | ProductSerials$SalesItemSerialsArgs<ExtArgs>
    salesReturnItemSerials?: boolean | ProductSerials$salesReturnItemSerialsArgs<ExtArgs>
    purchaseItemSerials?: boolean | ProductSerials$purchaseItemSerialsArgs<ExtArgs>
    purchaseReturnItemSerials?: boolean | ProductSerials$purchaseReturnItemSerialsArgs<ExtArgs>
    salesReturnItems?: boolean | ProductSerials$salesReturnItemsArgs<ExtArgs>
    exchangeItemSerialsOld?: boolean | ProductSerials$exchangeItemSerialsOldArgs<ExtArgs>
    exchangeItemSerialsNew?: boolean | ProductSerials$exchangeItemSerialsNewArgs<ExtArgs>
    _count?: boolean | ProductSerialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSerials"]>

  export type ProductSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    product_id?: boolean
    status?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
  }, ExtArgs["result"]["productSerials"]>

  export type ProductSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    product_id?: boolean
    status?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
  }, ExtArgs["result"]["productSerials"]>

  export type ProductSerialsSelectScalar = {
    id?: boolean
    serial?: boolean
    product_id?: boolean
    status?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serial" | "product_id" | "status" | "warranty" | "createdAt" | "updatedAt", ExtArgs["result"]["productSerials"]>
  export type ProductSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
    SalesItemSerials?: boolean | ProductSerials$SalesItemSerialsArgs<ExtArgs>
    salesReturnItemSerials?: boolean | ProductSerials$salesReturnItemSerialsArgs<ExtArgs>
    purchaseItemSerials?: boolean | ProductSerials$purchaseItemSerialsArgs<ExtArgs>
    purchaseReturnItemSerials?: boolean | ProductSerials$purchaseReturnItemSerialsArgs<ExtArgs>
    salesReturnItems?: boolean | ProductSerials$salesReturnItemsArgs<ExtArgs>
    exchangeItemSerialsOld?: boolean | ProductSerials$exchangeItemSerialsOldArgs<ExtArgs>
    exchangeItemSerialsNew?: boolean | ProductSerials$exchangeItemSerialsNewArgs<ExtArgs>
    _count?: boolean | ProductSerialsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
  }
  export type ProductSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductSerials$ProductsArgs<ExtArgs>
  }

  export type $ProductSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSerials"
    objects: {
      Products: Prisma.$ProductsPayload<ExtArgs> | null
      SalesItemSerials: Prisma.$SalesItemSerialsPayload<ExtArgs>[]
      salesReturnItemSerials: Prisma.$SalesReturnItemSerialsPayload<ExtArgs>[]
      purchaseItemSerials: Prisma.$PurchaseItemSerialsPayload<ExtArgs>[]
      purchaseReturnItemSerials: Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>[]
      salesReturnItems: Prisma.$SalesReturnItemsPayload<ExtArgs>[]
      exchangeItemSerialsOld: Prisma.$ExchangeItemSerialsPayload<ExtArgs>[]
      exchangeItemSerialsNew: Prisma.$ExchangeItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serial: string
      product_id: number
      status: $Enums.SerialStatus
      warranty: $Enums.Warranty
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productSerials"]>
    composites: {}
  }

  type ProductSerialsGetPayload<S extends boolean | null | undefined | ProductSerialsDefaultArgs> = $Result.GetResult<Prisma.$ProductSerialsPayload, S>

  type ProductSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductSerialsCountAggregateInputType | true
    }

  export interface ProductSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSerials'], meta: { name: 'ProductSerials' } }
    /**
     * Find zero or one ProductSerials that matches the filter.
     * @param {ProductSerialsFindUniqueArgs} args - Arguments to find a ProductSerials
     * @example
     * // Get one ProductSerials
     * const productSerials = await prisma.productSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSerialsFindUniqueArgs>(args: SelectSubset<T, ProductSerialsFindUniqueArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductSerialsFindUniqueOrThrowArgs} args - Arguments to find a ProductSerials
     * @example
     * // Get one ProductSerials
     * const productSerials = await prisma.productSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsFindFirstArgs} args - Arguments to find a ProductSerials
     * @example
     * // Get one ProductSerials
     * const productSerials = await prisma.productSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSerialsFindFirstArgs>(args?: SelectSubset<T, ProductSerialsFindFirstArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsFindFirstOrThrowArgs} args - Arguments to find a ProductSerials
     * @example
     * // Get one ProductSerials
     * const productSerials = await prisma.productSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSerials
     * const productSerials = await prisma.productSerials.findMany()
     * 
     * // Get first 10 ProductSerials
     * const productSerials = await prisma.productSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSerialsWithIdOnly = await prisma.productSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSerialsFindManyArgs>(args?: SelectSubset<T, ProductSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSerials.
     * @param {ProductSerialsCreateArgs} args - Arguments to create a ProductSerials.
     * @example
     * // Create one ProductSerials
     * const ProductSerials = await prisma.productSerials.create({
     *   data: {
     *     // ... data to create a ProductSerials
     *   }
     * })
     * 
     */
    create<T extends ProductSerialsCreateArgs>(args: SelectSubset<T, ProductSerialsCreateArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSerials.
     * @param {ProductSerialsCreateManyArgs} args - Arguments to create many ProductSerials.
     * @example
     * // Create many ProductSerials
     * const productSerials = await prisma.productSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSerialsCreateManyArgs>(args?: SelectSubset<T, ProductSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSerials and returns the data saved in the database.
     * @param {ProductSerialsCreateManyAndReturnArgs} args - Arguments to create many ProductSerials.
     * @example
     * // Create many ProductSerials
     * const productSerials = await prisma.productSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSerials and only return the `id`
     * const productSerialsWithIdOnly = await prisma.productSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductSerials.
     * @param {ProductSerialsDeleteArgs} args - Arguments to delete one ProductSerials.
     * @example
     * // Delete one ProductSerials
     * const ProductSerials = await prisma.productSerials.delete({
     *   where: {
     *     // ... filter to delete one ProductSerials
     *   }
     * })
     * 
     */
    delete<T extends ProductSerialsDeleteArgs>(args: SelectSubset<T, ProductSerialsDeleteArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSerials.
     * @param {ProductSerialsUpdateArgs} args - Arguments to update one ProductSerials.
     * @example
     * // Update one ProductSerials
     * const productSerials = await prisma.productSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSerialsUpdateArgs>(args: SelectSubset<T, ProductSerialsUpdateArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSerials.
     * @param {ProductSerialsDeleteManyArgs} args - Arguments to filter ProductSerials to delete.
     * @example
     * // Delete a few ProductSerials
     * const { count } = await prisma.productSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSerialsDeleteManyArgs>(args?: SelectSubset<T, ProductSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSerials
     * const productSerials = await prisma.productSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSerialsUpdateManyArgs>(args: SelectSubset<T, ProductSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSerials and returns the data updated in the database.
     * @param {ProductSerialsUpdateManyAndReturnArgs} args - Arguments to update many ProductSerials.
     * @example
     * // Update many ProductSerials
     * const productSerials = await prisma.productSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductSerials and only return the `id`
     * const productSerialsWithIdOnly = await prisma.productSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductSerials.
     * @param {ProductSerialsUpsertArgs} args - Arguments to update or create a ProductSerials.
     * @example
     * // Update or create a ProductSerials
     * const productSerials = await prisma.productSerials.upsert({
     *   create: {
     *     // ... data to create a ProductSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSerials we want to update
     *   }
     * })
     */
    upsert<T extends ProductSerialsUpsertArgs>(args: SelectSubset<T, ProductSerialsUpsertArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsCountArgs} args - Arguments to filter ProductSerials to count.
     * @example
     * // Count the number of ProductSerials
     * const count = await prisma.productSerials.count({
     *   where: {
     *     // ... the filter for the ProductSerials we want to count
     *   }
     * })
    **/
    count<T extends ProductSerialsCountArgs>(
      args?: Subset<T, ProductSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSerialsAggregateArgs>(args: Subset<T, ProductSerialsAggregateArgs>): Prisma.PrismaPromise<GetProductSerialsAggregateType<T>>

    /**
     * Group by ProductSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSerialsGroupByArgs['orderBy'] }
        : { orderBy?: ProductSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSerials model
   */
  readonly fields: ProductSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Products<T extends ProductSerials$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$ProductsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SalesItemSerials<T extends ProductSerials$SalesItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$SalesItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesReturnItemSerials<T extends ProductSerials$salesReturnItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$salesReturnItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseItemSerials<T extends ProductSerials$purchaseItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$purchaseItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItemSerials<T extends ProductSerials$purchaseReturnItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$purchaseReturnItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesReturnItems<T extends ProductSerials$salesReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$salesReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeItemSerialsOld<T extends ProductSerials$exchangeItemSerialsOldArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$exchangeItemSerialsOldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeItemSerialsNew<T extends ProductSerials$exchangeItemSerialsNewArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerials$exchangeItemSerialsNewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSerials model
   */
  interface ProductSerialsFieldRefs {
    readonly id: FieldRef<"ProductSerials", 'Int'>
    readonly serial: FieldRef<"ProductSerials", 'String'>
    readonly product_id: FieldRef<"ProductSerials", 'Int'>
    readonly status: FieldRef<"ProductSerials", 'SerialStatus'>
    readonly warranty: FieldRef<"ProductSerials", 'Warranty'>
    readonly createdAt: FieldRef<"ProductSerials", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductSerials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductSerials findUnique
   */
  export type ProductSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ProductSerials to fetch.
     */
    where: ProductSerialsWhereUniqueInput
  }

  /**
   * ProductSerials findUniqueOrThrow
   */
  export type ProductSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ProductSerials to fetch.
     */
    where: ProductSerialsWhereUniqueInput
  }

  /**
   * ProductSerials findFirst
   */
  export type ProductSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ProductSerials to fetch.
     */
    where?: ProductSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSerials to fetch.
     */
    orderBy?: ProductSerialsOrderByWithRelationInput | ProductSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSerials.
     */
    cursor?: ProductSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSerials.
     */
    distinct?: ProductSerialsScalarFieldEnum | ProductSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials findFirstOrThrow
   */
  export type ProductSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ProductSerials to fetch.
     */
    where?: ProductSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSerials to fetch.
     */
    orderBy?: ProductSerialsOrderByWithRelationInput | ProductSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSerials.
     */
    cursor?: ProductSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSerials.
     */
    distinct?: ProductSerialsScalarFieldEnum | ProductSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials findMany
   */
  export type ProductSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ProductSerials to fetch.
     */
    where?: ProductSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSerials to fetch.
     */
    orderBy?: ProductSerialsOrderByWithRelationInput | ProductSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSerials.
     */
    cursor?: ProductSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSerials.
     */
    skip?: number
    distinct?: ProductSerialsScalarFieldEnum | ProductSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials create
   */
  export type ProductSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSerials.
     */
    data: XOR<ProductSerialsCreateInput, ProductSerialsUncheckedCreateInput>
  }

  /**
   * ProductSerials createMany
   */
  export type ProductSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSerials.
     */
    data: ProductSerialsCreateManyInput | ProductSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSerials createManyAndReturn
   */
  export type ProductSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many ProductSerials.
     */
    data: ProductSerialsCreateManyInput | ProductSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSerials update
   */
  export type ProductSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSerials.
     */
    data: XOR<ProductSerialsUpdateInput, ProductSerialsUncheckedUpdateInput>
    /**
     * Choose, which ProductSerials to update.
     */
    where: ProductSerialsWhereUniqueInput
  }

  /**
   * ProductSerials updateMany
   */
  export type ProductSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSerials.
     */
    data: XOR<ProductSerialsUpdateManyMutationInput, ProductSerialsUncheckedUpdateManyInput>
    /**
     * Filter which ProductSerials to update
     */
    where?: ProductSerialsWhereInput
    /**
     * Limit how many ProductSerials to update.
     */
    limit?: number
  }

  /**
   * ProductSerials updateManyAndReturn
   */
  export type ProductSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * The data used to update ProductSerials.
     */
    data: XOR<ProductSerialsUpdateManyMutationInput, ProductSerialsUncheckedUpdateManyInput>
    /**
     * Filter which ProductSerials to update
     */
    where?: ProductSerialsWhereInput
    /**
     * Limit how many ProductSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSerials upsert
   */
  export type ProductSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSerials to update in case it exists.
     */
    where: ProductSerialsWhereUniqueInput
    /**
     * In case the ProductSerials found by the `where` argument doesn't exist, create a new ProductSerials with this data.
     */
    create: XOR<ProductSerialsCreateInput, ProductSerialsUncheckedCreateInput>
    /**
     * In case the ProductSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSerialsUpdateInput, ProductSerialsUncheckedUpdateInput>
  }

  /**
   * ProductSerials delete
   */
  export type ProductSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    /**
     * Filter which ProductSerials to delete.
     */
    where: ProductSerialsWhereUniqueInput
  }

  /**
   * ProductSerials deleteMany
   */
  export type ProductSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSerials to delete
     */
    where?: ProductSerialsWhereInput
    /**
     * Limit how many ProductSerials to delete.
     */
    limit?: number
  }

  /**
   * ProductSerials.Products
   */
  export type ProductSerials$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * ProductSerials.SalesItemSerials
   */
  export type ProductSerials$SalesItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    where?: SalesItemSerialsWhereInput
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    cursor?: SalesItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesItemSerialsScalarFieldEnum | SalesItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials.salesReturnItemSerials
   */
  export type ProductSerials$salesReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    where?: SalesReturnItemSerialsWhereInput
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnItemSerialsScalarFieldEnum | SalesReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials.purchaseItemSerials
   */
  export type ProductSerials$purchaseItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    where?: PurchaseItemSerialsWhereInput
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    cursor?: PurchaseItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemSerialsScalarFieldEnum | PurchaseItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials.purchaseReturnItemSerials
   */
  export type ProductSerials$purchaseReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    where?: PurchaseReturnItemSerialsWhereInput
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemSerialsScalarFieldEnum | PurchaseReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials.salesReturnItems
   */
  export type ProductSerials$salesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    where?: SalesReturnItemsWhereInput
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    cursor?: SalesReturnItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * ProductSerials.exchangeItemSerialsOld
   */
  export type ProductSerials$exchangeItemSerialsOldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    where?: ExchangeItemSerialsWhereInput
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    cursor?: ExchangeItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials.exchangeItemSerialsNew
   */
  export type ProductSerials$exchangeItemSerialsNewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    where?: ExchangeItemSerialsWhereInput
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    cursor?: ExchangeItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ProductSerials without action
   */
  export type ProductSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
  }


  /**
   * Model Expenses
   */

  export type AggregateExpenses = {
    _count: ExpensesCountAggregateOutputType | null
    _avg: ExpensesAvgAggregateOutputType | null
    _sum: ExpensesSumAggregateOutputType | null
    _min: ExpensesMinAggregateOutputType | null
    _max: ExpensesMaxAggregateOutputType | null
  }

  export type ExpensesAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    user_id: number | null
  }

  export type ExpensesSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    user_id: number | null
  }

  export type ExpensesMinAggregateOutputType = {
    id: number | null
    expenseNo: string | null
    title: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpensesMaxAggregateOutputType = {
    id: number | null
    expenseNo: string | null
    title: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpensesCountAggregateOutputType = {
    id: number
    expenseNo: number
    title: number
    amount: number
    date: number
    description: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpensesAvgAggregateInputType = {
    id?: true
    amount?: true
    user_id?: true
  }

  export type ExpensesSumAggregateInputType = {
    id?: true
    amount?: true
    user_id?: true
  }

  export type ExpensesMinAggregateInputType = {
    id?: true
    expenseNo?: true
    title?: true
    amount?: true
    date?: true
    description?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpensesMaxAggregateInputType = {
    id?: true
    expenseNo?: true
    title?: true
    amount?: true
    date?: true
    description?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpensesCountAggregateInputType = {
    id?: true
    expenseNo?: true
    title?: true
    amount?: true
    date?: true
    description?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to aggregate.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpensesMaxAggregateInputType
  }

  export type GetExpensesAggregateType<T extends ExpensesAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenses[P]>
      : GetScalarType<T[P], AggregateExpenses[P]>
  }




  export type ExpensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpensesWhereInput
    orderBy?: ExpensesOrderByWithAggregationInput | ExpensesOrderByWithAggregationInput[]
    by: ExpensesScalarFieldEnum[] | ExpensesScalarFieldEnum
    having?: ExpensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpensesCountAggregateInputType | true
    _avg?: ExpensesAvgAggregateInputType
    _sum?: ExpensesSumAggregateInputType
    _min?: ExpensesMinAggregateInputType
    _max?: ExpensesMaxAggregateInputType
  }

  export type ExpensesGroupByOutputType = {
    id: number
    expenseNo: string
    title: string
    amount: Decimal
    date: Date
    description: string | null
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: ExpensesCountAggregateOutputType | null
    _avg: ExpensesAvgAggregateOutputType | null
    _sum: ExpensesSumAggregateOutputType | null
    _min: ExpensesMinAggregateOutputType | null
    _max: ExpensesMaxAggregateOutputType | null
  }

  type GetExpensesGroupByPayload<T extends ExpensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpensesGroupByOutputType[P]>
            : GetScalarType<T[P], ExpensesGroupByOutputType[P]>
        }
      >
    >


  export type ExpensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseNo?: boolean
    title?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenses"]>

  export type ExpensesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseNo?: boolean
    title?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenses"]>

  export type ExpensesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseNo?: boolean
    title?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenses"]>

  export type ExpensesSelectScalar = {
    id?: boolean
    expenseNo?: boolean
    title?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpensesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expenseNo" | "title" | "amount" | "date" | "description" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["expenses"]>
  export type ExpensesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ExpensesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ExpensesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ExpensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expenses"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      expenseNo: string
      title: string
      amount: Prisma.Decimal
      date: Date
      description: string | null
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenses"]>
    composites: {}
  }

  type ExpensesGetPayload<S extends boolean | null | undefined | ExpensesDefaultArgs> = $Result.GetResult<Prisma.$ExpensesPayload, S>

  type ExpensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpensesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpensesCountAggregateInputType | true
    }

  export interface ExpensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expenses'], meta: { name: 'Expenses' } }
    /**
     * Find zero or one Expenses that matches the filter.
     * @param {ExpensesFindUniqueArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpensesFindUniqueArgs>(args: SelectSubset<T, ExpensesFindUniqueArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expenses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpensesFindUniqueOrThrowArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpensesFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindFirstArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpensesFindFirstArgs>(args?: SelectSubset<T, ExpensesFindFirstArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindFirstOrThrowArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpensesFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expenses.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expensesWithIdOnly = await prisma.expenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpensesFindManyArgs>(args?: SelectSubset<T, ExpensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expenses.
     * @param {ExpensesCreateArgs} args - Arguments to create a Expenses.
     * @example
     * // Create one Expenses
     * const Expenses = await prisma.expenses.create({
     *   data: {
     *     // ... data to create a Expenses
     *   }
     * })
     * 
     */
    create<T extends ExpensesCreateArgs>(args: SelectSubset<T, ExpensesCreateArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpensesCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expenses = await prisma.expenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpensesCreateManyArgs>(args?: SelectSubset<T, ExpensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpensesCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expenses = await prisma.expenses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expensesWithIdOnly = await prisma.expenses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpensesCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpensesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expenses.
     * @param {ExpensesDeleteArgs} args - Arguments to delete one Expenses.
     * @example
     * // Delete one Expenses
     * const Expenses = await prisma.expenses.delete({
     *   where: {
     *     // ... filter to delete one Expenses
     *   }
     * })
     * 
     */
    delete<T extends ExpensesDeleteArgs>(args: SelectSubset<T, ExpensesDeleteArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expenses.
     * @param {ExpensesUpdateArgs} args - Arguments to update one Expenses.
     * @example
     * // Update one Expenses
     * const expenses = await prisma.expenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpensesUpdateArgs>(args: SelectSubset<T, ExpensesUpdateArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpensesDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpensesDeleteManyArgs>(args?: SelectSubset<T, ExpensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expenses = await prisma.expenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpensesUpdateManyArgs>(args: SelectSubset<T, ExpensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpensesUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expenses = await prisma.expenses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expensesWithIdOnly = await prisma.expenses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpensesUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpensesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expenses.
     * @param {ExpensesUpsertArgs} args - Arguments to update or create a Expenses.
     * @example
     * // Update or create a Expenses
     * const expenses = await prisma.expenses.upsert({
     *   create: {
     *     // ... data to create a Expenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expenses we want to update
     *   }
     * })
     */
    upsert<T extends ExpensesUpsertArgs>(args: SelectSubset<T, ExpensesUpsertArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expenses.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpensesCountArgs>(
      args?: Subset<T, ExpensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpensesAggregateArgs>(args: Subset<T, ExpensesAggregateArgs>): Prisma.PrismaPromise<GetExpensesAggregateType<T>>

    /**
     * Group by Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpensesGroupByArgs['orderBy'] }
        : { orderBy?: ExpensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expenses model
   */
  readonly fields: ExpensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expenses model
   */
  interface ExpensesFieldRefs {
    readonly id: FieldRef<"Expenses", 'Int'>
    readonly expenseNo: FieldRef<"Expenses", 'String'>
    readonly title: FieldRef<"Expenses", 'String'>
    readonly amount: FieldRef<"Expenses", 'Decimal'>
    readonly date: FieldRef<"Expenses", 'DateTime'>
    readonly description: FieldRef<"Expenses", 'String'>
    readonly user_id: FieldRef<"Expenses", 'Int'>
    readonly createdAt: FieldRef<"Expenses", 'DateTime'>
    readonly updatedAt: FieldRef<"Expenses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expenses findUnique
   */
  export type ExpensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses findUniqueOrThrow
   */
  export type ExpensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses findFirst
   */
  export type ExpensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses findFirstOrThrow
   */
  export type ExpensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses findMany
   */
  export type ExpensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses create
   */
  export type ExpensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * The data needed to create a Expenses.
     */
    data: XOR<ExpensesCreateInput, ExpensesUncheckedCreateInput>
  }

  /**
   * Expenses createMany
   */
  export type ExpensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpensesCreateManyInput | ExpensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expenses createManyAndReturn
   */
  export type ExpensesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpensesCreateManyInput | ExpensesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expenses update
   */
  export type ExpensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * The data needed to update a Expenses.
     */
    data: XOR<ExpensesUpdateInput, ExpensesUncheckedUpdateInput>
    /**
     * Choose, which Expenses to update.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses updateMany
   */
  export type ExpensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpensesUpdateManyMutationInput, ExpensesUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpensesWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expenses updateManyAndReturn
   */
  export type ExpensesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpensesUpdateManyMutationInput, ExpensesUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpensesWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expenses upsert
   */
  export type ExpensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * The filter to search for the Expenses to update in case it exists.
     */
    where: ExpensesWhereUniqueInput
    /**
     * In case the Expenses found by the `where` argument doesn't exist, create a new Expenses with this data.
     */
    create: XOR<ExpensesCreateInput, ExpensesUncheckedCreateInput>
    /**
     * In case the Expenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpensesUpdateInput, ExpensesUncheckedUpdateInput>
  }

  /**
   * Expenses delete
   */
  export type ExpensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
    /**
     * Filter which Expenses to delete.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses deleteMany
   */
  export type ExpensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpensesWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expenses without action
   */
  export type ExpensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpensesInclude<ExtArgs> | null
  }


  /**
   * Model Sales
   */

  export type AggregateSales = {
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  export type SalesAvgAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    totaldiscount: Decimal | null
    customer_id: number | null
    user_id: number | null
  }

  export type SalesSumAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    totaldiscount: Decimal | null
    customer_id: number | null
    user_id: number | null
  }

  export type SalesMinAggregateOutputType = {
    id: number | null
    saleNo: string | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    totaldiscount: Decimal | null
    dueDate: Date | null
    status: string | null
    customer_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesMaxAggregateOutputType = {
    id: number | null
    saleNo: string | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    totaldiscount: Decimal | null
    dueDate: Date | null
    status: string | null
    customer_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesCountAggregateOutputType = {
    id: number
    saleNo: number
    totalAmount: number
    totalPaid: number
    totaldiscount: number
    dueDate: number
    status: number
    customer_id: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    totalPaid?: true
    totaldiscount?: true
    customer_id?: true
    user_id?: true
  }

  export type SalesSumAggregateInputType = {
    id?: true
    totalAmount?: true
    totalPaid?: true
    totaldiscount?: true
    customer_id?: true
    user_id?: true
  }

  export type SalesMinAggregateInputType = {
    id?: true
    saleNo?: true
    totalAmount?: true
    totalPaid?: true
    totaldiscount?: true
    dueDate?: true
    status?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesMaxAggregateInputType = {
    id?: true
    saleNo?: true
    totalAmount?: true
    totalPaid?: true
    totaldiscount?: true
    dueDate?: true
    status?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesCountAggregateInputType = {
    id?: true
    saleNo?: true
    totalAmount?: true
    totalPaid?: true
    totaldiscount?: true
    dueDate?: true
    status?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to aggregate.
     */
    where?: SalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesMaxAggregateInputType
  }

  export type GetSalesAggregateType<T extends SalesAggregateArgs> = {
        [P in keyof T & keyof AggregateSales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales[P]>
      : GetScalarType<T[P], AggregateSales[P]>
  }




  export type SalesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesWhereInput
    orderBy?: SalesOrderByWithAggregationInput | SalesOrderByWithAggregationInput[]
    by: SalesScalarFieldEnum[] | SalesScalarFieldEnum
    having?: SalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesCountAggregateInputType | true
    _avg?: SalesAvgAggregateInputType
    _sum?: SalesSumAggregateInputType
    _min?: SalesMinAggregateInputType
    _max?: SalesMaxAggregateInputType
  }

  export type SalesGroupByOutputType = {
    id: number
    saleNo: string
    totalAmount: Decimal
    totalPaid: Decimal
    totaldiscount: Decimal | null
    dueDate: Date | null
    status: string
    customer_id: number | null
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: SalesCountAggregateOutputType | null
    _avg: SalesAvgAggregateOutputType | null
    _sum: SalesSumAggregateOutputType | null
    _min: SalesMinAggregateOutputType | null
    _max: SalesMaxAggregateOutputType | null
  }

  type GetSalesGroupByPayload<T extends SalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesGroupByOutputType[P]>
            : GetScalarType<T[P], SalesGroupByOutputType[P]>
        }
      >
    >


  export type SalesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    totaldiscount?: boolean
    dueDate?: boolean
    status?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
    SalesItems?: boolean | Sales$SalesItemsArgs<ExtArgs>
    SalesReturn?: boolean | Sales$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Sales$ExchangesArgs<ExtArgs>
    _count?: boolean | SalesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type SalesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    totaldiscount?: boolean
    dueDate?: boolean
    status?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type SalesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    totaldiscount?: boolean
    dueDate?: boolean
    status?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["sales"]>

  export type SalesSelectScalar = {
    id?: boolean
    saleNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    totaldiscount?: boolean
    dueDate?: boolean
    status?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleNo" | "totalAmount" | "totalPaid" | "totaldiscount" | "dueDate" | "status" | "customer_id" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["sales"]>
  export type SalesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
    SalesItems?: boolean | Sales$SalesItemsArgs<ExtArgs>
    SalesReturn?: boolean | Sales$SalesReturnArgs<ExtArgs>
    Exchanges?: boolean | Sales$ExchangesArgs<ExtArgs>
    _count?: boolean | SalesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
  }
  export type SalesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Sales$CustomersArgs<ExtArgs>
    Users?: boolean | Sales$UsersArgs<ExtArgs>
  }

  export type $SalesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sales"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs> | null
      SalesItems: Prisma.$SalesItemsPayload<ExtArgs>[]
      SalesReturn: Prisma.$SalesReturnPayload<ExtArgs>[]
      Exchanges: Prisma.$ExchangesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saleNo: string
      totalAmount: Prisma.Decimal
      totalPaid: Prisma.Decimal
      totaldiscount: Prisma.Decimal | null
      dueDate: Date | null
      status: string
      customer_id: number | null
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sales"]>
    composites: {}
  }

  type SalesGetPayload<S extends boolean | null | undefined | SalesDefaultArgs> = $Result.GetResult<Prisma.$SalesPayload, S>

  type SalesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesCountAggregateInputType | true
    }

  export interface SalesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sales'], meta: { name: 'Sales' } }
    /**
     * Find zero or one Sales that matches the filter.
     * @param {SalesFindUniqueArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesFindUniqueArgs>(args: SelectSubset<T, SalesFindUniqueArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesFindUniqueOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesFindFirstArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesFindFirstArgs>(args?: SelectSubset<T, SalesFindFirstArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesFindFirstOrThrowArgs} args - Arguments to find a Sales
     * @example
     * // Get one Sales
     * const sales = await prisma.sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sales.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesWithIdOnly = await prisma.sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesFindManyArgs>(args?: SelectSubset<T, SalesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sales.
     * @param {SalesCreateArgs} args - Arguments to create a Sales.
     * @example
     * // Create one Sales
     * const Sales = await prisma.sales.create({
     *   data: {
     *     // ... data to create a Sales
     *   }
     * })
     * 
     */
    create<T extends SalesCreateArgs>(args: SelectSubset<T, SalesCreateArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SalesCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sales = await prisma.sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesCreateManyArgs>(args?: SelectSubset<T, SalesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SalesCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sales = await prisma.sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const salesWithIdOnly = await prisma.sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sales.
     * @param {SalesDeleteArgs} args - Arguments to delete one Sales.
     * @example
     * // Delete one Sales
     * const Sales = await prisma.sales.delete({
     *   where: {
     *     // ... filter to delete one Sales
     *   }
     * })
     * 
     */
    delete<T extends SalesDeleteArgs>(args: SelectSubset<T, SalesDeleteArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sales.
     * @param {SalesUpdateArgs} args - Arguments to update one Sales.
     * @example
     * // Update one Sales
     * const sales = await prisma.sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesUpdateArgs>(args: SelectSubset<T, SalesUpdateArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SalesDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesDeleteManyArgs>(args?: SelectSubset<T, SalesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sales = await prisma.sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesUpdateManyArgs>(args: SelectSubset<T, SalesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SalesUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sales = await prisma.sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const salesWithIdOnly = await prisma.sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sales.
     * @param {SalesUpsertArgs} args - Arguments to update or create a Sales.
     * @example
     * // Update or create a Sales
     * const sales = await prisma.sales.upsert({
     *   create: {
     *     // ... data to create a Sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales we want to update
     *   }
     * })
     */
    upsert<T extends SalesUpsertArgs>(args: SelectSubset<T, SalesUpsertArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sales.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SalesCountArgs>(
      args?: Subset<T, SalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesAggregateArgs>(args: Subset<T, SalesAggregateArgs>): Prisma.PrismaPromise<GetSalesAggregateType<T>>

    /**
     * Group by Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesGroupByArgs['orderBy'] }
        : { orderBy?: SalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sales model
   */
  readonly fields: SalesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends Sales$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Sales$CustomersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends Sales$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Sales$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SalesItems<T extends Sales$SalesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Sales$SalesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesReturn<T extends Sales$SalesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Sales$SalesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Exchanges<T extends Sales$ExchangesArgs<ExtArgs> = {}>(args?: Subset<T, Sales$ExchangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sales model
   */
  interface SalesFieldRefs {
    readonly id: FieldRef<"Sales", 'Int'>
    readonly saleNo: FieldRef<"Sales", 'String'>
    readonly totalAmount: FieldRef<"Sales", 'Decimal'>
    readonly totalPaid: FieldRef<"Sales", 'Decimal'>
    readonly totaldiscount: FieldRef<"Sales", 'Decimal'>
    readonly dueDate: FieldRef<"Sales", 'DateTime'>
    readonly status: FieldRef<"Sales", 'String'>
    readonly customer_id: FieldRef<"Sales", 'Int'>
    readonly user_id: FieldRef<"Sales", 'Int'>
    readonly createdAt: FieldRef<"Sales", 'DateTime'>
    readonly updatedAt: FieldRef<"Sales", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sales findUnique
   */
  export type SalesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where: SalesWhereUniqueInput
  }

  /**
   * Sales findUniqueOrThrow
   */
  export type SalesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where: SalesWhereUniqueInput
  }

  /**
   * Sales findFirst
   */
  export type SalesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * Sales findFirstOrThrow
   */
  export type SalesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * Sales findMany
   */
  export type SalesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SalesOrderByWithRelationInput | SalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SalesScalarFieldEnum | SalesScalarFieldEnum[]
  }

  /**
   * Sales create
   */
  export type SalesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * The data needed to create a Sales.
     */
    data: XOR<SalesCreateInput, SalesUncheckedCreateInput>
  }

  /**
   * Sales createMany
   */
  export type SalesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SalesCreateManyInput | SalesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sales createManyAndReturn
   */
  export type SalesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SalesCreateManyInput | SalesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sales update
   */
  export type SalesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * The data needed to update a Sales.
     */
    data: XOR<SalesUpdateInput, SalesUncheckedUpdateInput>
    /**
     * Choose, which Sales to update.
     */
    where: SalesWhereUniqueInput
  }

  /**
   * Sales updateMany
   */
  export type SalesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SalesUpdateManyMutationInput, SalesUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SalesWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sales updateManyAndReturn
   */
  export type SalesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SalesUpdateManyMutationInput, SalesUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SalesWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sales upsert
   */
  export type SalesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * The filter to search for the Sales to update in case it exists.
     */
    where: SalesWhereUniqueInput
    /**
     * In case the Sales found by the `where` argument doesn't exist, create a new Sales with this data.
     */
    create: XOR<SalesCreateInput, SalesUncheckedCreateInput>
    /**
     * In case the Sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesUpdateInput, SalesUncheckedUpdateInput>
  }

  /**
   * Sales delete
   */
  export type SalesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    /**
     * Filter which Sales to delete.
     */
    where: SalesWhereUniqueInput
  }

  /**
   * Sales deleteMany
   */
  export type SalesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SalesWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sales.Customers
   */
  export type Sales$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }

  /**
   * Sales.Users
   */
  export type Sales$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Sales.SalesItems
   */
  export type Sales$SalesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    where?: SalesItemsWhereInput
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    cursor?: SalesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesItemsScalarFieldEnum | SalesItemsScalarFieldEnum[]
  }

  /**
   * Sales.SalesReturn
   */
  export type Sales$SalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    where?: SalesReturnWhereInput
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    cursor?: SalesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * Sales.Exchanges
   */
  export type Sales$ExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    where?: ExchangesWhereInput
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    cursor?: ExchangesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Sales without action
   */
  export type SalesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
  }


  /**
   * Model SalesItems
   */

  export type AggregateSalesItems = {
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  export type SalesItemsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    sales_id: number | null
    product_id: number | null
  }

  export type SalesItemsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    sales_id: number | null
    product_id: number | null
  }

  export type SalesItemsMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    sales_id: number | null
    product_id: number | null
  }

  export type SalesItemsMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    sales_id: number | null
    product_id: number | null
  }

  export type SalesItemsCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    discount: number
    sales_id: number
    product_id: number
    _all: number
  }


  export type SalesItemsAvgAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    sales_id?: true
    product_id?: true
  }

  export type SalesItemsSumAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    sales_id?: true
    product_id?: true
  }

  export type SalesItemsMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    sales_id?: true
    product_id?: true
  }

  export type SalesItemsMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    sales_id?: true
    product_id?: true
  }

  export type SalesItemsCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    sales_id?: true
    product_id?: true
    _all?: true
  }

  export type SalesItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesItems to aggregate.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesItems
    **/
    _count?: true | SalesItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesItemsMaxAggregateInputType
  }

  export type GetSalesItemsAggregateType<T extends SalesItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesItems[P]>
      : GetScalarType<T[P], AggregateSalesItems[P]>
  }




  export type SalesItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemsWhereInput
    orderBy?: SalesItemsOrderByWithAggregationInput | SalesItemsOrderByWithAggregationInput[]
    by: SalesItemsScalarFieldEnum[] | SalesItemsScalarFieldEnum
    having?: SalesItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesItemsCountAggregateInputType | true
    _avg?: SalesItemsAvgAggregateInputType
    _sum?: SalesItemsSumAggregateInputType
    _min?: SalesItemsMinAggregateInputType
    _max?: SalesItemsMaxAggregateInputType
  }

  export type SalesItemsGroupByOutputType = {
    id: number
    quantity: number
    unitPrice: Decimal
    discount: Decimal | null
    sales_id: number
    product_id: number
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  type GetSalesItemsGroupByPayload<T extends SalesItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
        }
      >
    >


  export type SalesItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    sales_id?: boolean
    product_id?: boolean
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
    salesItemSerials?: boolean | SalesItems$salesItemSerialsArgs<ExtArgs>
    _count?: boolean | SalesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesItems"]>

  export type SalesItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    sales_id?: boolean
    product_id?: boolean
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
  }, ExtArgs["result"]["salesItems"]>

  export type SalesItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    sales_id?: boolean
    product_id?: boolean
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
  }, ExtArgs["result"]["salesItems"]>

  export type SalesItemsSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    sales_id?: boolean
    product_id?: boolean
  }

  export type SalesItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "discount" | "sales_id" | "product_id", ExtArgs["result"]["salesItems"]>
  export type SalesItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
    salesItemSerials?: boolean | SalesItems$salesItemSerialsArgs<ExtArgs>
    _count?: boolean | SalesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
  }
  export type SalesItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesItems$SalesArgs<ExtArgs>
    Products?: boolean | SalesItems$ProductsArgs<ExtArgs>
  }

  export type $SalesItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesItems"
    objects: {
      Sales: Prisma.$SalesPayload<ExtArgs> | null
      Products: Prisma.$ProductsPayload<ExtArgs> | null
      salesItemSerials: Prisma.$SalesItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal | null
      sales_id: number
      product_id: number
    }, ExtArgs["result"]["salesItems"]>
    composites: {}
  }

  type SalesItemsGetPayload<S extends boolean | null | undefined | SalesItemsDefaultArgs> = $Result.GetResult<Prisma.$SalesItemsPayload, S>

  type SalesItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesItemsCountAggregateInputType | true
    }

  export interface SalesItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesItems'], meta: { name: 'SalesItems' } }
    /**
     * Find zero or one SalesItems that matches the filter.
     * @param {SalesItemsFindUniqueArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesItemsFindUniqueArgs>(args: SelectSubset<T, SalesItemsFindUniqueArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesItemsFindUniqueOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindFirstArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesItemsFindFirstArgs>(args?: SelectSubset<T, SalesItemsFindFirstArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindFirstOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesItems
     * const salesItems = await prisma.salesItems.findMany()
     * 
     * // Get first 10 SalesItems
     * const salesItems = await prisma.salesItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesItemsWithIdOnly = await prisma.salesItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesItemsFindManyArgs>(args?: SelectSubset<T, SalesItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesItems.
     * @param {SalesItemsCreateArgs} args - Arguments to create a SalesItems.
     * @example
     * // Create one SalesItems
     * const SalesItems = await prisma.salesItems.create({
     *   data: {
     *     // ... data to create a SalesItems
     *   }
     * })
     * 
     */
    create<T extends SalesItemsCreateArgs>(args: SelectSubset<T, SalesItemsCreateArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesItems.
     * @param {SalesItemsCreateManyArgs} args - Arguments to create many SalesItems.
     * @example
     * // Create many SalesItems
     * const salesItems = await prisma.salesItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesItemsCreateManyArgs>(args?: SelectSubset<T, SalesItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesItems and returns the data saved in the database.
     * @param {SalesItemsCreateManyAndReturnArgs} args - Arguments to create many SalesItems.
     * @example
     * // Create many SalesItems
     * const salesItems = await prisma.salesItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesItems and only return the `id`
     * const salesItemsWithIdOnly = await prisma.salesItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesItems.
     * @param {SalesItemsDeleteArgs} args - Arguments to delete one SalesItems.
     * @example
     * // Delete one SalesItems
     * const SalesItems = await prisma.salesItems.delete({
     *   where: {
     *     // ... filter to delete one SalesItems
     *   }
     * })
     * 
     */
    delete<T extends SalesItemsDeleteArgs>(args: SelectSubset<T, SalesItemsDeleteArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesItems.
     * @param {SalesItemsUpdateArgs} args - Arguments to update one SalesItems.
     * @example
     * // Update one SalesItems
     * const salesItems = await prisma.salesItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesItemsUpdateArgs>(args: SelectSubset<T, SalesItemsUpdateArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesItems.
     * @param {SalesItemsDeleteManyArgs} args - Arguments to filter SalesItems to delete.
     * @example
     * // Delete a few SalesItems
     * const { count } = await prisma.salesItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesItemsDeleteManyArgs>(args?: SelectSubset<T, SalesItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesItems
     * const salesItems = await prisma.salesItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesItemsUpdateManyArgs>(args: SelectSubset<T, SalesItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItems and returns the data updated in the database.
     * @param {SalesItemsUpdateManyAndReturnArgs} args - Arguments to update many SalesItems.
     * @example
     * // Update many SalesItems
     * const salesItems = await prisma.salesItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesItems and only return the `id`
     * const salesItemsWithIdOnly = await prisma.salesItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesItems.
     * @param {SalesItemsUpsertArgs} args - Arguments to update or create a SalesItems.
     * @example
     * // Update or create a SalesItems
     * const salesItems = await prisma.salesItems.upsert({
     *   create: {
     *     // ... data to create a SalesItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesItems we want to update
     *   }
     * })
     */
    upsert<T extends SalesItemsUpsertArgs>(args: SelectSubset<T, SalesItemsUpsertArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsCountArgs} args - Arguments to filter SalesItems to count.
     * @example
     * // Count the number of SalesItems
     * const count = await prisma.salesItems.count({
     *   where: {
     *     // ... the filter for the SalesItems we want to count
     *   }
     * })
    **/
    count<T extends SalesItemsCountArgs>(
      args?: Subset<T, SalesItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesItemsAggregateArgs>(args: Subset<T, SalesItemsAggregateArgs>): Prisma.PrismaPromise<GetSalesItemsAggregateType<T>>

    /**
     * Group by SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesItemsGroupByArgs['orderBy'] }
        : { orderBy?: SalesItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesItems model
   */
  readonly fields: SalesItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sales<T extends SalesItems$SalesArgs<ExtArgs> = {}>(args?: Subset<T, SalesItems$SalesArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Products<T extends SalesItems$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, SalesItems$ProductsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salesItemSerials<T extends SalesItems$salesItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, SalesItems$salesItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesItems model
   */
  interface SalesItemsFieldRefs {
    readonly id: FieldRef<"SalesItems", 'Int'>
    readonly quantity: FieldRef<"SalesItems", 'Int'>
    readonly unitPrice: FieldRef<"SalesItems", 'Decimal'>
    readonly discount: FieldRef<"SalesItems", 'Decimal'>
    readonly sales_id: FieldRef<"SalesItems", 'Int'>
    readonly product_id: FieldRef<"SalesItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalesItems findUnique
   */
  export type SalesItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where: SalesItemsWhereUniqueInput
  }

  /**
   * SalesItems findUniqueOrThrow
   */
  export type SalesItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where: SalesItemsWhereUniqueInput
  }

  /**
   * SalesItems findFirst
   */
  export type SalesItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItems.
     */
    distinct?: SalesItemsScalarFieldEnum | SalesItemsScalarFieldEnum[]
  }

  /**
   * SalesItems findFirstOrThrow
   */
  export type SalesItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItems.
     */
    distinct?: SalesItemsScalarFieldEnum | SalesItemsScalarFieldEnum[]
  }

  /**
   * SalesItems findMany
   */
  export type SalesItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: SalesItemsOrderByWithRelationInput | SalesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    distinct?: SalesItemsScalarFieldEnum | SalesItemsScalarFieldEnum[]
  }

  /**
   * SalesItems create
   */
  export type SalesItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesItems.
     */
    data: XOR<SalesItemsCreateInput, SalesItemsUncheckedCreateInput>
  }

  /**
   * SalesItems createMany
   */
  export type SalesItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesItems.
     */
    data: SalesItemsCreateManyInput | SalesItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesItems createManyAndReturn
   */
  export type SalesItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * The data used to create many SalesItems.
     */
    data: SalesItemsCreateManyInput | SalesItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesItems update
   */
  export type SalesItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesItems.
     */
    data: XOR<SalesItemsUpdateInput, SalesItemsUncheckedUpdateInput>
    /**
     * Choose, which SalesItems to update.
     */
    where: SalesItemsWhereUniqueInput
  }

  /**
   * SalesItems updateMany
   */
  export type SalesItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesItems.
     */
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyInput>
    /**
     * Filter which SalesItems to update
     */
    where?: SalesItemsWhereInput
    /**
     * Limit how many SalesItems to update.
     */
    limit?: number
  }

  /**
   * SalesItems updateManyAndReturn
   */
  export type SalesItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * The data used to update SalesItems.
     */
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyInput>
    /**
     * Filter which SalesItems to update
     */
    where?: SalesItemsWhereInput
    /**
     * Limit how many SalesItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesItems upsert
   */
  export type SalesItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesItems to update in case it exists.
     */
    where: SalesItemsWhereUniqueInput
    /**
     * In case the SalesItems found by the `where` argument doesn't exist, create a new SalesItems with this data.
     */
    create: XOR<SalesItemsCreateInput, SalesItemsUncheckedCreateInput>
    /**
     * In case the SalesItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesItemsUpdateInput, SalesItemsUncheckedUpdateInput>
  }

  /**
   * SalesItems delete
   */
  export type SalesItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
    /**
     * Filter which SalesItems to delete.
     */
    where: SalesItemsWhereUniqueInput
  }

  /**
   * SalesItems deleteMany
   */
  export type SalesItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesItems to delete
     */
    where?: SalesItemsWhereInput
    /**
     * Limit how many SalesItems to delete.
     */
    limit?: number
  }

  /**
   * SalesItems.Sales
   */
  export type SalesItems$SalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    where?: SalesWhereInput
  }

  /**
   * SalesItems.Products
   */
  export type SalesItems$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * SalesItems.salesItemSerials
   */
  export type SalesItems$salesItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    where?: SalesItemSerialsWhereInput
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    cursor?: SalesItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesItemSerialsScalarFieldEnum | SalesItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesItems without action
   */
  export type SalesItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItems
     */
    omit?: SalesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemsInclude<ExtArgs> | null
  }


  /**
   * Model SalesItemSerials
   */

  export type AggregateSalesItemSerials = {
    _count: SalesItemSerialsCountAggregateOutputType | null
    _avg: SalesItemSerialsAvgAggregateOutputType | null
    _sum: SalesItemSerialsSumAggregateOutputType | null
    _min: SalesItemSerialsMinAggregateOutputType | null
    _max: SalesItemSerialsMaxAggregateOutputType | null
  }

  export type SalesItemSerialsAvgAggregateOutputType = {
    id: number | null
    salesItem_id: number | null
    serial_id: number | null
  }

  export type SalesItemSerialsSumAggregateOutputType = {
    id: number | null
    salesItem_id: number | null
    serial_id: number | null
  }

  export type SalesItemSerialsMinAggregateOutputType = {
    id: number | null
    salesItem_id: number | null
    serial_id: number | null
  }

  export type SalesItemSerialsMaxAggregateOutputType = {
    id: number | null
    salesItem_id: number | null
    serial_id: number | null
  }

  export type SalesItemSerialsCountAggregateOutputType = {
    id: number
    salesItem_id: number
    serial_id: number
    _all: number
  }


  export type SalesItemSerialsAvgAggregateInputType = {
    id?: true
    salesItem_id?: true
    serial_id?: true
  }

  export type SalesItemSerialsSumAggregateInputType = {
    id?: true
    salesItem_id?: true
    serial_id?: true
  }

  export type SalesItemSerialsMinAggregateInputType = {
    id?: true
    salesItem_id?: true
    serial_id?: true
  }

  export type SalesItemSerialsMaxAggregateInputType = {
    id?: true
    salesItem_id?: true
    serial_id?: true
  }

  export type SalesItemSerialsCountAggregateInputType = {
    id?: true
    salesItem_id?: true
    serial_id?: true
    _all?: true
  }

  export type SalesItemSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesItemSerials to aggregate.
     */
    where?: SalesItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItemSerials to fetch.
     */
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesItemSerials
    **/
    _count?: true | SalesItemSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesItemSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesItemSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesItemSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesItemSerialsMaxAggregateInputType
  }

  export type GetSalesItemSerialsAggregateType<T extends SalesItemSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesItemSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesItemSerials[P]>
      : GetScalarType<T[P], AggregateSalesItemSerials[P]>
  }




  export type SalesItemSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesItemSerialsWhereInput
    orderBy?: SalesItemSerialsOrderByWithAggregationInput | SalesItemSerialsOrderByWithAggregationInput[]
    by: SalesItemSerialsScalarFieldEnum[] | SalesItemSerialsScalarFieldEnum
    having?: SalesItemSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesItemSerialsCountAggregateInputType | true
    _avg?: SalesItemSerialsAvgAggregateInputType
    _sum?: SalesItemSerialsSumAggregateInputType
    _min?: SalesItemSerialsMinAggregateInputType
    _max?: SalesItemSerialsMaxAggregateInputType
  }

  export type SalesItemSerialsGroupByOutputType = {
    id: number
    salesItem_id: number
    serial_id: number
    _count: SalesItemSerialsCountAggregateOutputType | null
    _avg: SalesItemSerialsAvgAggregateOutputType | null
    _sum: SalesItemSerialsSumAggregateOutputType | null
    _min: SalesItemSerialsMinAggregateOutputType | null
    _max: SalesItemSerialsMaxAggregateOutputType | null
  }

  type GetSalesItemSerialsGroupByPayload<T extends SalesItemSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesItemSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesItemSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesItemSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesItemSerialsGroupByOutputType[P]>
        }
      >
    >


  export type SalesItemSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesItem_id?: boolean
    serial_id?: boolean
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesItemSerials"]>

  export type SalesItemSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesItem_id?: boolean
    serial_id?: boolean
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesItemSerials"]>

  export type SalesItemSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesItem_id?: boolean
    serial_id?: boolean
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesItemSerials"]>

  export type SalesItemSerialsSelectScalar = {
    id?: boolean
    salesItem_id?: boolean
    serial_id?: boolean
  }

  export type SalesItemSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesItem_id" | "serial_id", ExtArgs["result"]["salesItemSerials"]>
  export type SalesItemSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type SalesItemSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type SalesItemSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesItems?: boolean | SalesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }

  export type $SalesItemSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesItemSerials"
    objects: {
      SalesItems: Prisma.$SalesItemsPayload<ExtArgs>
      ProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesItem_id: number
      serial_id: number
    }, ExtArgs["result"]["salesItemSerials"]>
    composites: {}
  }

  type SalesItemSerialsGetPayload<S extends boolean | null | undefined | SalesItemSerialsDefaultArgs> = $Result.GetResult<Prisma.$SalesItemSerialsPayload, S>

  type SalesItemSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesItemSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesItemSerialsCountAggregateInputType | true
    }

  export interface SalesItemSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesItemSerials'], meta: { name: 'SalesItemSerials' } }
    /**
     * Find zero or one SalesItemSerials that matches the filter.
     * @param {SalesItemSerialsFindUniqueArgs} args - Arguments to find a SalesItemSerials
     * @example
     * // Get one SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesItemSerialsFindUniqueArgs>(args: SelectSubset<T, SalesItemSerialsFindUniqueArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesItemSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesItemSerialsFindUniqueOrThrowArgs} args - Arguments to find a SalesItemSerials
     * @example
     * // Get one SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesItemSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesItemSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsFindFirstArgs} args - Arguments to find a SalesItemSerials
     * @example
     * // Get one SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesItemSerialsFindFirstArgs>(args?: SelectSubset<T, SalesItemSerialsFindFirstArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesItemSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsFindFirstOrThrowArgs} args - Arguments to find a SalesItemSerials
     * @example
     * // Get one SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesItemSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesItemSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findMany()
     * 
     * // Get first 10 SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesItemSerialsWithIdOnly = await prisma.salesItemSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesItemSerialsFindManyArgs>(args?: SelectSubset<T, SalesItemSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesItemSerials.
     * @param {SalesItemSerialsCreateArgs} args - Arguments to create a SalesItemSerials.
     * @example
     * // Create one SalesItemSerials
     * const SalesItemSerials = await prisma.salesItemSerials.create({
     *   data: {
     *     // ... data to create a SalesItemSerials
     *   }
     * })
     * 
     */
    create<T extends SalesItemSerialsCreateArgs>(args: SelectSubset<T, SalesItemSerialsCreateArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesItemSerials.
     * @param {SalesItemSerialsCreateManyArgs} args - Arguments to create many SalesItemSerials.
     * @example
     * // Create many SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesItemSerialsCreateManyArgs>(args?: SelectSubset<T, SalesItemSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesItemSerials and returns the data saved in the database.
     * @param {SalesItemSerialsCreateManyAndReturnArgs} args - Arguments to create many SalesItemSerials.
     * @example
     * // Create many SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesItemSerials and only return the `id`
     * const salesItemSerialsWithIdOnly = await prisma.salesItemSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesItemSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesItemSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesItemSerials.
     * @param {SalesItemSerialsDeleteArgs} args - Arguments to delete one SalesItemSerials.
     * @example
     * // Delete one SalesItemSerials
     * const SalesItemSerials = await prisma.salesItemSerials.delete({
     *   where: {
     *     // ... filter to delete one SalesItemSerials
     *   }
     * })
     * 
     */
    delete<T extends SalesItemSerialsDeleteArgs>(args: SelectSubset<T, SalesItemSerialsDeleteArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesItemSerials.
     * @param {SalesItemSerialsUpdateArgs} args - Arguments to update one SalesItemSerials.
     * @example
     * // Update one SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesItemSerialsUpdateArgs>(args: SelectSubset<T, SalesItemSerialsUpdateArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesItemSerials.
     * @param {SalesItemSerialsDeleteManyArgs} args - Arguments to filter SalesItemSerials to delete.
     * @example
     * // Delete a few SalesItemSerials
     * const { count } = await prisma.salesItemSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesItemSerialsDeleteManyArgs>(args?: SelectSubset<T, SalesItemSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesItemSerialsUpdateManyArgs>(args: SelectSubset<T, SalesItemSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItemSerials and returns the data updated in the database.
     * @param {SalesItemSerialsUpdateManyAndReturnArgs} args - Arguments to update many SalesItemSerials.
     * @example
     * // Update many SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesItemSerials and only return the `id`
     * const salesItemSerialsWithIdOnly = await prisma.salesItemSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesItemSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesItemSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesItemSerials.
     * @param {SalesItemSerialsUpsertArgs} args - Arguments to update or create a SalesItemSerials.
     * @example
     * // Update or create a SalesItemSerials
     * const salesItemSerials = await prisma.salesItemSerials.upsert({
     *   create: {
     *     // ... data to create a SalesItemSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesItemSerials we want to update
     *   }
     * })
     */
    upsert<T extends SalesItemSerialsUpsertArgs>(args: SelectSubset<T, SalesItemSerialsUpsertArgs<ExtArgs>>): Prisma__SalesItemSerialsClient<$Result.GetResult<Prisma.$SalesItemSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsCountArgs} args - Arguments to filter SalesItemSerials to count.
     * @example
     * // Count the number of SalesItemSerials
     * const count = await prisma.salesItemSerials.count({
     *   where: {
     *     // ... the filter for the SalesItemSerials we want to count
     *   }
     * })
    **/
    count<T extends SalesItemSerialsCountArgs>(
      args?: Subset<T, SalesItemSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesItemSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesItemSerialsAggregateArgs>(args: Subset<T, SalesItemSerialsAggregateArgs>): Prisma.PrismaPromise<GetSalesItemSerialsAggregateType<T>>

    /**
     * Group by SalesItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesItemSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesItemSerialsGroupByArgs['orderBy'] }
        : { orderBy?: SalesItemSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesItemSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesItemSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesItemSerials model
   */
  readonly fields: SalesItemSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesItemSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesItemSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SalesItems<T extends SalesItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesItemsDefaultArgs<ExtArgs>>): Prisma__SalesItemsClient<$Result.GetResult<Prisma.$SalesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesItemSerials model
   */
  interface SalesItemSerialsFieldRefs {
    readonly id: FieldRef<"SalesItemSerials", 'Int'>
    readonly salesItem_id: FieldRef<"SalesItemSerials", 'Int'>
    readonly serial_id: FieldRef<"SalesItemSerials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalesItemSerials findUnique
   */
  export type SalesItemSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItemSerials to fetch.
     */
    where: SalesItemSerialsWhereUniqueInput
  }

  /**
   * SalesItemSerials findUniqueOrThrow
   */
  export type SalesItemSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItemSerials to fetch.
     */
    where: SalesItemSerialsWhereUniqueInput
  }

  /**
   * SalesItemSerials findFirst
   */
  export type SalesItemSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItemSerials to fetch.
     */
    where?: SalesItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItemSerials to fetch.
     */
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItemSerials.
     */
    cursor?: SalesItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItemSerials.
     */
    distinct?: SalesItemSerialsScalarFieldEnum | SalesItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesItemSerials findFirstOrThrow
   */
  export type SalesItemSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItemSerials to fetch.
     */
    where?: SalesItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItemSerials to fetch.
     */
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItemSerials.
     */
    cursor?: SalesItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItemSerials.
     */
    distinct?: SalesItemSerialsScalarFieldEnum | SalesItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesItemSerials findMany
   */
  export type SalesItemSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesItemSerials to fetch.
     */
    where?: SalesItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItemSerials to fetch.
     */
    orderBy?: SalesItemSerialsOrderByWithRelationInput | SalesItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesItemSerials.
     */
    cursor?: SalesItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItemSerials.
     */
    skip?: number
    distinct?: SalesItemSerialsScalarFieldEnum | SalesItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesItemSerials create
   */
  export type SalesItemSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesItemSerials.
     */
    data: XOR<SalesItemSerialsCreateInput, SalesItemSerialsUncheckedCreateInput>
  }

  /**
   * SalesItemSerials createMany
   */
  export type SalesItemSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesItemSerials.
     */
    data: SalesItemSerialsCreateManyInput | SalesItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesItemSerials createManyAndReturn
   */
  export type SalesItemSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many SalesItemSerials.
     */
    data: SalesItemSerialsCreateManyInput | SalesItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesItemSerials update
   */
  export type SalesItemSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesItemSerials.
     */
    data: XOR<SalesItemSerialsUpdateInput, SalesItemSerialsUncheckedUpdateInput>
    /**
     * Choose, which SalesItemSerials to update.
     */
    where: SalesItemSerialsWhereUniqueInput
  }

  /**
   * SalesItemSerials updateMany
   */
  export type SalesItemSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesItemSerials.
     */
    data: XOR<SalesItemSerialsUpdateManyMutationInput, SalesItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which SalesItemSerials to update
     */
    where?: SalesItemSerialsWhereInput
    /**
     * Limit how many SalesItemSerials to update.
     */
    limit?: number
  }

  /**
   * SalesItemSerials updateManyAndReturn
   */
  export type SalesItemSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to update SalesItemSerials.
     */
    data: XOR<SalesItemSerialsUpdateManyMutationInput, SalesItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which SalesItemSerials to update
     */
    where?: SalesItemSerialsWhereInput
    /**
     * Limit how many SalesItemSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesItemSerials upsert
   */
  export type SalesItemSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesItemSerials to update in case it exists.
     */
    where: SalesItemSerialsWhereUniqueInput
    /**
     * In case the SalesItemSerials found by the `where` argument doesn't exist, create a new SalesItemSerials with this data.
     */
    create: XOR<SalesItemSerialsCreateInput, SalesItemSerialsUncheckedCreateInput>
    /**
     * In case the SalesItemSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesItemSerialsUpdateInput, SalesItemSerialsUncheckedUpdateInput>
  }

  /**
   * SalesItemSerials delete
   */
  export type SalesItemSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
    /**
     * Filter which SalesItemSerials to delete.
     */
    where: SalesItemSerialsWhereUniqueInput
  }

  /**
   * SalesItemSerials deleteMany
   */
  export type SalesItemSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesItemSerials to delete
     */
    where?: SalesItemSerialsWhereInput
    /**
     * Limit how many SalesItemSerials to delete.
     */
    limit?: number
  }

  /**
   * SalesItemSerials without action
   */
  export type SalesItemSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesItemSerials
     */
    select?: SalesItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesItemSerials
     */
    omit?: SalesItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesItemSerialsInclude<ExtArgs> | null
  }


  /**
   * Model SalesReturn
   */

  export type AggregateSalesReturn = {
    _count: SalesReturnCountAggregateOutputType | null
    _avg: SalesReturnAvgAggregateOutputType | null
    _sum: SalesReturnSumAggregateOutputType | null
    _min: SalesReturnMinAggregateOutputType | null
    _max: SalesReturnMaxAggregateOutputType | null
  }

  export type SalesReturnAvgAggregateOutputType = {
    id: number | null
    total_payback: Decimal | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
  }

  export type SalesReturnSumAggregateOutputType = {
    id: number | null
    total_payback: Decimal | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
  }

  export type SalesReturnMinAggregateOutputType = {
    id: number | null
    returnNo: string | null
    total_payback: Decimal | null
    note: string | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnMaxAggregateOutputType = {
    id: number | null
    returnNo: string | null
    total_payback: Decimal | null
    note: string | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnCountAggregateOutputType = {
    id: number
    returnNo: number
    total_payback: number
    note: number
    sales_id: number
    user_id: number
    customer_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesReturnAvgAggregateInputType = {
    id?: true
    total_payback?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
  }

  export type SalesReturnSumAggregateInputType = {
    id?: true
    total_payback?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
  }

  export type SalesReturnMinAggregateInputType = {
    id?: true
    returnNo?: true
    total_payback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnMaxAggregateInputType = {
    id?: true
    returnNo?: true
    total_payback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnCountAggregateInputType = {
    id?: true
    returnNo?: true
    total_payback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturn to aggregate.
     */
    where?: SalesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturns to fetch.
     */
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReturns
    **/
    _count?: true | SalesReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReturnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReturnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReturnMaxAggregateInputType
  }

  export type GetSalesReturnAggregateType<T extends SalesReturnAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReturn[P]>
      : GetScalarType<T[P], AggregateSalesReturn[P]>
  }




  export type SalesReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnWhereInput
    orderBy?: SalesReturnOrderByWithAggregationInput | SalesReturnOrderByWithAggregationInput[]
    by: SalesReturnScalarFieldEnum[] | SalesReturnScalarFieldEnum
    having?: SalesReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReturnCountAggregateInputType | true
    _avg?: SalesReturnAvgAggregateInputType
    _sum?: SalesReturnSumAggregateInputType
    _min?: SalesReturnMinAggregateInputType
    _max?: SalesReturnMaxAggregateInputType
  }

  export type SalesReturnGroupByOutputType = {
    id: number
    returnNo: string
    total_payback: Decimal
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt: Date
    updatedAt: Date
    _count: SalesReturnCountAggregateOutputType | null
    _avg: SalesReturnAvgAggregateOutputType | null
    _sum: SalesReturnSumAggregateOutputType | null
    _min: SalesReturnMinAggregateOutputType | null
    _max: SalesReturnMaxAggregateOutputType | null
  }

  type GetSalesReturnGroupByPayload<T extends SalesReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReturnGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReturnGroupByOutputType[P]>
        }
      >
    >


  export type SalesReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    total_payback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    SalesReturnItems?: boolean | SalesReturn$SalesReturnItemsArgs<ExtArgs>
    _count?: boolean | SalesReturnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturn"]>

  export type SalesReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    total_payback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturn"]>

  export type SalesReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    total_payback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturn"]>

  export type SalesReturnSelectScalar = {
    id?: boolean
    returnNo?: boolean
    total_payback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnNo" | "total_payback" | "note" | "sales_id" | "user_id" | "customer_id" | "createdAt" | "updatedAt", ExtArgs["result"]["salesReturn"]>
  export type SalesReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
    SalesReturnItems?: boolean | SalesReturn$SalesReturnItemsArgs<ExtArgs>
    _count?: boolean | SalesReturnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
  }
  export type SalesReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | SalesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Customers?: boolean | CustomersDefaultArgs<ExtArgs>
  }

  export type $SalesReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReturn"
    objects: {
      Sales: Prisma.$SalesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      Customers: Prisma.$CustomersPayload<ExtArgs>
      SalesReturnItems: Prisma.$SalesReturnItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      returnNo: string
      total_payback: Prisma.Decimal
      note: string
      sales_id: number
      user_id: number
      customer_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesReturn"]>
    composites: {}
  }

  type SalesReturnGetPayload<S extends boolean | null | undefined | SalesReturnDefaultArgs> = $Result.GetResult<Prisma.$SalesReturnPayload, S>

  type SalesReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesReturnCountAggregateInputType | true
    }

  export interface SalesReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReturn'], meta: { name: 'SalesReturn' } }
    /**
     * Find zero or one SalesReturn that matches the filter.
     * @param {SalesReturnFindUniqueArgs} args - Arguments to find a SalesReturn
     * @example
     * // Get one SalesReturn
     * const salesReturn = await prisma.salesReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReturnFindUniqueArgs>(args: SelectSubset<T, SalesReturnFindUniqueArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesReturn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesReturnFindUniqueOrThrowArgs} args - Arguments to find a SalesReturn
     * @example
     * // Get one SalesReturn
     * const salesReturn = await prisma.salesReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnFindFirstArgs} args - Arguments to find a SalesReturn
     * @example
     * // Get one SalesReturn
     * const salesReturn = await prisma.salesReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReturnFindFirstArgs>(args?: SelectSubset<T, SalesReturnFindFirstArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnFindFirstOrThrowArgs} args - Arguments to find a SalesReturn
     * @example
     * // Get one SalesReturn
     * const salesReturn = await prisma.salesReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReturns
     * const salesReturns = await prisma.salesReturn.findMany()
     * 
     * // Get first 10 SalesReturns
     * const salesReturns = await prisma.salesReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReturnWithIdOnly = await prisma.salesReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReturnFindManyArgs>(args?: SelectSubset<T, SalesReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesReturn.
     * @param {SalesReturnCreateArgs} args - Arguments to create a SalesReturn.
     * @example
     * // Create one SalesReturn
     * const SalesReturn = await prisma.salesReturn.create({
     *   data: {
     *     // ... data to create a SalesReturn
     *   }
     * })
     * 
     */
    create<T extends SalesReturnCreateArgs>(args: SelectSubset<T, SalesReturnCreateArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesReturns.
     * @param {SalesReturnCreateManyArgs} args - Arguments to create many SalesReturns.
     * @example
     * // Create many SalesReturns
     * const salesReturn = await prisma.salesReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReturnCreateManyArgs>(args?: SelectSubset<T, SalesReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReturns and returns the data saved in the database.
     * @param {SalesReturnCreateManyAndReturnArgs} args - Arguments to create many SalesReturns.
     * @example
     * // Create many SalesReturns
     * const salesReturn = await prisma.salesReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReturns and only return the `id`
     * const salesReturnWithIdOnly = await prisma.salesReturn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesReturn.
     * @param {SalesReturnDeleteArgs} args - Arguments to delete one SalesReturn.
     * @example
     * // Delete one SalesReturn
     * const SalesReturn = await prisma.salesReturn.delete({
     *   where: {
     *     // ... filter to delete one SalesReturn
     *   }
     * })
     * 
     */
    delete<T extends SalesReturnDeleteArgs>(args: SelectSubset<T, SalesReturnDeleteArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesReturn.
     * @param {SalesReturnUpdateArgs} args - Arguments to update one SalesReturn.
     * @example
     * // Update one SalesReturn
     * const salesReturn = await prisma.salesReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReturnUpdateArgs>(args: SelectSubset<T, SalesReturnUpdateArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesReturns.
     * @param {SalesReturnDeleteManyArgs} args - Arguments to filter SalesReturns to delete.
     * @example
     * // Delete a few SalesReturns
     * const { count } = await prisma.salesReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReturnDeleteManyArgs>(args?: SelectSubset<T, SalesReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReturns
     * const salesReturn = await prisma.salesReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReturnUpdateManyArgs>(args: SelectSubset<T, SalesReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturns and returns the data updated in the database.
     * @param {SalesReturnUpdateManyAndReturnArgs} args - Arguments to update many SalesReturns.
     * @example
     * // Update many SalesReturns
     * const salesReturn = await prisma.salesReturn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesReturns and only return the `id`
     * const salesReturnWithIdOnly = await prisma.salesReturn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesReturn.
     * @param {SalesReturnUpsertArgs} args - Arguments to update or create a SalesReturn.
     * @example
     * // Update or create a SalesReturn
     * const salesReturn = await prisma.salesReturn.upsert({
     *   create: {
     *     // ... data to create a SalesReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReturn we want to update
     *   }
     * })
     */
    upsert<T extends SalesReturnUpsertArgs>(args: SelectSubset<T, SalesReturnUpsertArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnCountArgs} args - Arguments to filter SalesReturns to count.
     * @example
     * // Count the number of SalesReturns
     * const count = await prisma.salesReturn.count({
     *   where: {
     *     // ... the filter for the SalesReturns we want to count
     *   }
     * })
    **/
    count<T extends SalesReturnCountArgs>(
      args?: Subset<T, SalesReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReturnAggregateArgs>(args: Subset<T, SalesReturnAggregateArgs>): Prisma.PrismaPromise<GetSalesReturnAggregateType<T>>

    /**
     * Group by SalesReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReturnGroupByArgs['orderBy'] }
        : { orderBy?: SalesReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReturn model
   */
  readonly fields: SalesReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sales<T extends SalesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesDefaultArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SalesReturnItems<T extends SalesReturn$SalesReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturn$SalesReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReturn model
   */
  interface SalesReturnFieldRefs {
    readonly id: FieldRef<"SalesReturn", 'Int'>
    readonly returnNo: FieldRef<"SalesReturn", 'String'>
    readonly total_payback: FieldRef<"SalesReturn", 'Decimal'>
    readonly note: FieldRef<"SalesReturn", 'String'>
    readonly sales_id: FieldRef<"SalesReturn", 'Int'>
    readonly user_id: FieldRef<"SalesReturn", 'Int'>
    readonly customer_id: FieldRef<"SalesReturn", 'Int'>
    readonly createdAt: FieldRef<"SalesReturn", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesReturn findUnique
   */
  export type SalesReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturn to fetch.
     */
    where: SalesReturnWhereUniqueInput
  }

  /**
   * SalesReturn findUniqueOrThrow
   */
  export type SalesReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturn to fetch.
     */
    where: SalesReturnWhereUniqueInput
  }

  /**
   * SalesReturn findFirst
   */
  export type SalesReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturn to fetch.
     */
    where?: SalesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturns to fetch.
     */
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturns.
     */
    cursor?: SalesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturns.
     */
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * SalesReturn findFirstOrThrow
   */
  export type SalesReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturn to fetch.
     */
    where?: SalesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturns to fetch.
     */
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturns.
     */
    cursor?: SalesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturns.
     */
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * SalesReturn findMany
   */
  export type SalesReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturns to fetch.
     */
    where?: SalesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturns to fetch.
     */
    orderBy?: SalesReturnOrderByWithRelationInput | SalesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReturns.
     */
    cursor?: SalesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturns.
     */
    skip?: number
    distinct?: SalesReturnScalarFieldEnum | SalesReturnScalarFieldEnum[]
  }

  /**
   * SalesReturn create
   */
  export type SalesReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReturn.
     */
    data: XOR<SalesReturnCreateInput, SalesReturnUncheckedCreateInput>
  }

  /**
   * SalesReturn createMany
   */
  export type SalesReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReturns.
     */
    data: SalesReturnCreateManyInput | SalesReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReturn createManyAndReturn
   */
  export type SalesReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * The data used to create many SalesReturns.
     */
    data: SalesReturnCreateManyInput | SalesReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturn update
   */
  export type SalesReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReturn.
     */
    data: XOR<SalesReturnUpdateInput, SalesReturnUncheckedUpdateInput>
    /**
     * Choose, which SalesReturn to update.
     */
    where: SalesReturnWhereUniqueInput
  }

  /**
   * SalesReturn updateMany
   */
  export type SalesReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReturns.
     */
    data: XOR<SalesReturnUpdateManyMutationInput, SalesReturnUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturns to update
     */
    where?: SalesReturnWhereInput
    /**
     * Limit how many SalesReturns to update.
     */
    limit?: number
  }

  /**
   * SalesReturn updateManyAndReturn
   */
  export type SalesReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * The data used to update SalesReturns.
     */
    data: XOR<SalesReturnUpdateManyMutationInput, SalesReturnUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturns to update
     */
    where?: SalesReturnWhereInput
    /**
     * Limit how many SalesReturns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturn upsert
   */
  export type SalesReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReturn to update in case it exists.
     */
    where: SalesReturnWhereUniqueInput
    /**
     * In case the SalesReturn found by the `where` argument doesn't exist, create a new SalesReturn with this data.
     */
    create: XOR<SalesReturnCreateInput, SalesReturnUncheckedCreateInput>
    /**
     * In case the SalesReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReturnUpdateInput, SalesReturnUncheckedUpdateInput>
  }

  /**
   * SalesReturn delete
   */
  export type SalesReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    /**
     * Filter which SalesReturn to delete.
     */
    where: SalesReturnWhereUniqueInput
  }

  /**
   * SalesReturn deleteMany
   */
  export type SalesReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturns to delete
     */
    where?: SalesReturnWhereInput
    /**
     * Limit how many SalesReturns to delete.
     */
    limit?: number
  }

  /**
   * SalesReturn.SalesReturnItems
   */
  export type SalesReturn$SalesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    where?: SalesReturnItemsWhereInput
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    cursor?: SalesReturnItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * SalesReturn without action
   */
  export type SalesReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
  }


  /**
   * Model SalesReturnItems
   */

  export type AggregateSalesReturnItems = {
    _count: SalesReturnItemsCountAggregateOutputType | null
    _avg: SalesReturnItemsAvgAggregateOutputType | null
    _sum: SalesReturnItemsSumAggregateOutputType | null
    _min: SalesReturnItemsMinAggregateOutputType | null
    _max: SalesReturnItemsMaxAggregateOutputType | null
  }

  export type SalesReturnItemsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    product_id: number | null
    salesReturn_id: number | null
    productSerialsId: number | null
  }

  export type SalesReturnItemsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    product_id: number | null
    salesReturn_id: number | null
    productSerialsId: number | null
  }

  export type SalesReturnItemsMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    product_id: number | null
    salesReturn_id: number | null
    productSerialsId: number | null
  }

  export type SalesReturnItemsMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    product_id: number | null
    salesReturn_id: number | null
    productSerialsId: number | null
  }

  export type SalesReturnItemsCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    product_id: number
    salesReturn_id: number
    productSerialsId: number
    _all: number
  }


  export type SalesReturnItemsAvgAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    product_id?: true
    salesReturn_id?: true
    productSerialsId?: true
  }

  export type SalesReturnItemsSumAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    product_id?: true
    salesReturn_id?: true
    productSerialsId?: true
  }

  export type SalesReturnItemsMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    product_id?: true
    salesReturn_id?: true
    productSerialsId?: true
  }

  export type SalesReturnItemsMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    product_id?: true
    salesReturn_id?: true
    productSerialsId?: true
  }

  export type SalesReturnItemsCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    product_id?: true
    salesReturn_id?: true
    productSerialsId?: true
    _all?: true
  }

  export type SalesReturnItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnItems to aggregate.
     */
    where?: SalesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItems to fetch.
     */
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReturnItems
    **/
    _count?: true | SalesReturnItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReturnItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReturnItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReturnItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReturnItemsMaxAggregateInputType
  }

  export type GetSalesReturnItemsAggregateType<T extends SalesReturnItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReturnItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReturnItems[P]>
      : GetScalarType<T[P], AggregateSalesReturnItems[P]>
  }




  export type SalesReturnItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemsWhereInput
    orderBy?: SalesReturnItemsOrderByWithAggregationInput | SalesReturnItemsOrderByWithAggregationInput[]
    by: SalesReturnItemsScalarFieldEnum[] | SalesReturnItemsScalarFieldEnum
    having?: SalesReturnItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReturnItemsCountAggregateInputType | true
    _avg?: SalesReturnItemsAvgAggregateInputType
    _sum?: SalesReturnItemsSumAggregateInputType
    _min?: SalesReturnItemsMinAggregateInputType
    _max?: SalesReturnItemsMaxAggregateInputType
  }

  export type SalesReturnItemsGroupByOutputType = {
    id: number
    quantity: number
    unitPrice: Decimal
    product_id: number
    salesReturn_id: number
    productSerialsId: number | null
    _count: SalesReturnItemsCountAggregateOutputType | null
    _avg: SalesReturnItemsAvgAggregateOutputType | null
    _sum: SalesReturnItemsSumAggregateOutputType | null
    _min: SalesReturnItemsMinAggregateOutputType | null
    _max: SalesReturnItemsMaxAggregateOutputType | null
  }

  type GetSalesReturnItemsGroupByPayload<T extends SalesReturnItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReturnItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReturnItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReturnItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReturnItemsGroupByOutputType[P]>
        }
      >
    >


  export type SalesReturnItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    product_id?: boolean
    salesReturn_id?: boolean
    productSerialsId?: boolean
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
    salesReturnItemSerials?: boolean | SalesReturnItems$salesReturnItemSerialsArgs<ExtArgs>
    _count?: boolean | SalesReturnItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItems"]>

  export type SalesReturnItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    product_id?: boolean
    salesReturn_id?: boolean
    productSerialsId?: boolean
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItems"]>

  export type SalesReturnItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    product_id?: boolean
    salesReturn_id?: boolean
    productSerialsId?: boolean
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItems"]>

  export type SalesReturnItemsSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    product_id?: boolean
    salesReturn_id?: boolean
    productSerialsId?: boolean
  }

  export type SalesReturnItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "product_id" | "salesReturn_id" | "productSerialsId", ExtArgs["result"]["salesReturnItems"]>
  export type SalesReturnItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
    salesReturnItemSerials?: boolean | SalesReturnItems$salesReturnItemSerialsArgs<ExtArgs>
    _count?: boolean | SalesReturnItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesReturnItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
  }
  export type SalesReturnItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | SalesReturnItems$ProductsArgs<ExtArgs>
    SalesReturn?: boolean | SalesReturnItems$SalesReturnArgs<ExtArgs>
    productSerials?: boolean | SalesReturnItems$productSerialsArgs<ExtArgs>
  }

  export type $SalesReturnItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReturnItems"
    objects: {
      Products: Prisma.$ProductsPayload<ExtArgs> | null
      SalesReturn: Prisma.$SalesReturnPayload<ExtArgs> | null
      productSerials: Prisma.$ProductSerialsPayload<ExtArgs> | null
      salesReturnItemSerials: Prisma.$SalesReturnItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      unitPrice: Prisma.Decimal
      product_id: number
      salesReturn_id: number
      productSerialsId: number | null
    }, ExtArgs["result"]["salesReturnItems"]>
    composites: {}
  }

  type SalesReturnItemsGetPayload<S extends boolean | null | undefined | SalesReturnItemsDefaultArgs> = $Result.GetResult<Prisma.$SalesReturnItemsPayload, S>

  type SalesReturnItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesReturnItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesReturnItemsCountAggregateInputType | true
    }

  export interface SalesReturnItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReturnItems'], meta: { name: 'SalesReturnItems' } }
    /**
     * Find zero or one SalesReturnItems that matches the filter.
     * @param {SalesReturnItemsFindUniqueArgs} args - Arguments to find a SalesReturnItems
     * @example
     * // Get one SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReturnItemsFindUniqueArgs>(args: SelectSubset<T, SalesReturnItemsFindUniqueArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesReturnItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesReturnItemsFindUniqueOrThrowArgs} args - Arguments to find a SalesReturnItems
     * @example
     * // Get one SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReturnItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReturnItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsFindFirstArgs} args - Arguments to find a SalesReturnItems
     * @example
     * // Get one SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReturnItemsFindFirstArgs>(args?: SelectSubset<T, SalesReturnItemsFindFirstArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsFindFirstOrThrowArgs} args - Arguments to find a SalesReturnItems
     * @example
     * // Get one SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReturnItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReturnItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findMany()
     * 
     * // Get first 10 SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReturnItemsWithIdOnly = await prisma.salesReturnItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReturnItemsFindManyArgs>(args?: SelectSubset<T, SalesReturnItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesReturnItems.
     * @param {SalesReturnItemsCreateArgs} args - Arguments to create a SalesReturnItems.
     * @example
     * // Create one SalesReturnItems
     * const SalesReturnItems = await prisma.salesReturnItems.create({
     *   data: {
     *     // ... data to create a SalesReturnItems
     *   }
     * })
     * 
     */
    create<T extends SalesReturnItemsCreateArgs>(args: SelectSubset<T, SalesReturnItemsCreateArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesReturnItems.
     * @param {SalesReturnItemsCreateManyArgs} args - Arguments to create many SalesReturnItems.
     * @example
     * // Create many SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReturnItemsCreateManyArgs>(args?: SelectSubset<T, SalesReturnItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReturnItems and returns the data saved in the database.
     * @param {SalesReturnItemsCreateManyAndReturnArgs} args - Arguments to create many SalesReturnItems.
     * @example
     * // Create many SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReturnItems and only return the `id`
     * const salesReturnItemsWithIdOnly = await prisma.salesReturnItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReturnItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReturnItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesReturnItems.
     * @param {SalesReturnItemsDeleteArgs} args - Arguments to delete one SalesReturnItems.
     * @example
     * // Delete one SalesReturnItems
     * const SalesReturnItems = await prisma.salesReturnItems.delete({
     *   where: {
     *     // ... filter to delete one SalesReturnItems
     *   }
     * })
     * 
     */
    delete<T extends SalesReturnItemsDeleteArgs>(args: SelectSubset<T, SalesReturnItemsDeleteArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesReturnItems.
     * @param {SalesReturnItemsUpdateArgs} args - Arguments to update one SalesReturnItems.
     * @example
     * // Update one SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReturnItemsUpdateArgs>(args: SelectSubset<T, SalesReturnItemsUpdateArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesReturnItems.
     * @param {SalesReturnItemsDeleteManyArgs} args - Arguments to filter SalesReturnItems to delete.
     * @example
     * // Delete a few SalesReturnItems
     * const { count } = await prisma.salesReturnItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReturnItemsDeleteManyArgs>(args?: SelectSubset<T, SalesReturnItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReturnItemsUpdateManyArgs>(args: SelectSubset<T, SalesReturnItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnItems and returns the data updated in the database.
     * @param {SalesReturnItemsUpdateManyAndReturnArgs} args - Arguments to update many SalesReturnItems.
     * @example
     * // Update many SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesReturnItems and only return the `id`
     * const salesReturnItemsWithIdOnly = await prisma.salesReturnItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesReturnItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesReturnItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesReturnItems.
     * @param {SalesReturnItemsUpsertArgs} args - Arguments to update or create a SalesReturnItems.
     * @example
     * // Update or create a SalesReturnItems
     * const salesReturnItems = await prisma.salesReturnItems.upsert({
     *   create: {
     *     // ... data to create a SalesReturnItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReturnItems we want to update
     *   }
     * })
     */
    upsert<T extends SalesReturnItemsUpsertArgs>(args: SelectSubset<T, SalesReturnItemsUpsertArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsCountArgs} args - Arguments to filter SalesReturnItems to count.
     * @example
     * // Count the number of SalesReturnItems
     * const count = await prisma.salesReturnItems.count({
     *   where: {
     *     // ... the filter for the SalesReturnItems we want to count
     *   }
     * })
    **/
    count<T extends SalesReturnItemsCountArgs>(
      args?: Subset<T, SalesReturnItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReturnItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReturnItemsAggregateArgs>(args: Subset<T, SalesReturnItemsAggregateArgs>): Prisma.PrismaPromise<GetSalesReturnItemsAggregateType<T>>

    /**
     * Group by SalesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReturnItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReturnItemsGroupByArgs['orderBy'] }
        : { orderBy?: SalesReturnItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReturnItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReturnItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReturnItems model
   */
  readonly fields: SalesReturnItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReturnItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReturnItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Products<T extends SalesReturnItems$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnItems$ProductsArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SalesReturn<T extends SalesReturnItems$SalesReturnArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnItems$SalesReturnArgs<ExtArgs>>): Prisma__SalesReturnClient<$Result.GetResult<Prisma.$SalesReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productSerials<T extends SalesReturnItems$productSerialsArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnItems$productSerialsArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salesReturnItemSerials<T extends SalesReturnItems$salesReturnItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnItems$salesReturnItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReturnItems model
   */
  interface SalesReturnItemsFieldRefs {
    readonly id: FieldRef<"SalesReturnItems", 'Int'>
    readonly quantity: FieldRef<"SalesReturnItems", 'Int'>
    readonly unitPrice: FieldRef<"SalesReturnItems", 'Decimal'>
    readonly product_id: FieldRef<"SalesReturnItems", 'Int'>
    readonly salesReturn_id: FieldRef<"SalesReturnItems", 'Int'>
    readonly productSerialsId: FieldRef<"SalesReturnItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalesReturnItems findUnique
   */
  export type SalesReturnItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItems to fetch.
     */
    where: SalesReturnItemsWhereUniqueInput
  }

  /**
   * SalesReturnItems findUniqueOrThrow
   */
  export type SalesReturnItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItems to fetch.
     */
    where: SalesReturnItemsWhereUniqueInput
  }

  /**
   * SalesReturnItems findFirst
   */
  export type SalesReturnItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItems to fetch.
     */
    where?: SalesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItems to fetch.
     */
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnItems.
     */
    cursor?: SalesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnItems.
     */
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * SalesReturnItems findFirstOrThrow
   */
  export type SalesReturnItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItems to fetch.
     */
    where?: SalesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItems to fetch.
     */
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnItems.
     */
    cursor?: SalesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnItems.
     */
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * SalesReturnItems findMany
   */
  export type SalesReturnItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItems to fetch.
     */
    where?: SalesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItems to fetch.
     */
    orderBy?: SalesReturnItemsOrderByWithRelationInput | SalesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReturnItems.
     */
    cursor?: SalesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItems.
     */
    skip?: number
    distinct?: SalesReturnItemsScalarFieldEnum | SalesReturnItemsScalarFieldEnum[]
  }

  /**
   * SalesReturnItems create
   */
  export type SalesReturnItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReturnItems.
     */
    data: XOR<SalesReturnItemsCreateInput, SalesReturnItemsUncheckedCreateInput>
  }

  /**
   * SalesReturnItems createMany
   */
  export type SalesReturnItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReturnItems.
     */
    data: SalesReturnItemsCreateManyInput | SalesReturnItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReturnItems createManyAndReturn
   */
  export type SalesReturnItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * The data used to create many SalesReturnItems.
     */
    data: SalesReturnItemsCreateManyInput | SalesReturnItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnItems update
   */
  export type SalesReturnItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReturnItems.
     */
    data: XOR<SalesReturnItemsUpdateInput, SalesReturnItemsUncheckedUpdateInput>
    /**
     * Choose, which SalesReturnItems to update.
     */
    where: SalesReturnItemsWhereUniqueInput
  }

  /**
   * SalesReturnItems updateMany
   */
  export type SalesReturnItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReturnItems.
     */
    data: XOR<SalesReturnItemsUpdateManyMutationInput, SalesReturnItemsUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnItems to update
     */
    where?: SalesReturnItemsWhereInput
    /**
     * Limit how many SalesReturnItems to update.
     */
    limit?: number
  }

  /**
   * SalesReturnItems updateManyAndReturn
   */
  export type SalesReturnItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * The data used to update SalesReturnItems.
     */
    data: XOR<SalesReturnItemsUpdateManyMutationInput, SalesReturnItemsUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnItems to update
     */
    where?: SalesReturnItemsWhereInput
    /**
     * Limit how many SalesReturnItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnItems upsert
   */
  export type SalesReturnItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReturnItems to update in case it exists.
     */
    where: SalesReturnItemsWhereUniqueInput
    /**
     * In case the SalesReturnItems found by the `where` argument doesn't exist, create a new SalesReturnItems with this data.
     */
    create: XOR<SalesReturnItemsCreateInput, SalesReturnItemsUncheckedCreateInput>
    /**
     * In case the SalesReturnItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReturnItemsUpdateInput, SalesReturnItemsUncheckedUpdateInput>
  }

  /**
   * SalesReturnItems delete
   */
  export type SalesReturnItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter which SalesReturnItems to delete.
     */
    where: SalesReturnItemsWhereUniqueInput
  }

  /**
   * SalesReturnItems deleteMany
   */
  export type SalesReturnItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnItems to delete
     */
    where?: SalesReturnItemsWhereInput
    /**
     * Limit how many SalesReturnItems to delete.
     */
    limit?: number
  }

  /**
   * SalesReturnItems.Products
   */
  export type SalesReturnItems$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * SalesReturnItems.SalesReturn
   */
  export type SalesReturnItems$SalesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturn
     */
    select?: SalesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturn
     */
    omit?: SalesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInclude<ExtArgs> | null
    where?: SalesReturnWhereInput
  }

  /**
   * SalesReturnItems.productSerials
   */
  export type SalesReturnItems$productSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSerials
     */
    select?: ProductSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSerials
     */
    omit?: ProductSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSerialsInclude<ExtArgs> | null
    where?: ProductSerialsWhereInput
  }

  /**
   * SalesReturnItems.salesReturnItemSerials
   */
  export type SalesReturnItems$salesReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    where?: SalesReturnItemSerialsWhereInput
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnItemSerialsScalarFieldEnum | SalesReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesReturnItems without action
   */
  export type SalesReturnItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItems
     */
    select?: SalesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItems
     */
    omit?: SalesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemsInclude<ExtArgs> | null
  }


  /**
   * Model SalesReturnItemSerials
   */

  export type AggregateSalesReturnItemSerials = {
    _count: SalesReturnItemSerialsCountAggregateOutputType | null
    _avg: SalesReturnItemSerialsAvgAggregateOutputType | null
    _sum: SalesReturnItemSerialsSumAggregateOutputType | null
    _min: SalesReturnItemSerialsMinAggregateOutputType | null
    _max: SalesReturnItemSerialsMaxAggregateOutputType | null
  }

  export type SalesReturnItemSerialsAvgAggregateOutputType = {
    id: number | null
    salesReturnItem_id: number | null
    serial_id: number | null
  }

  export type SalesReturnItemSerialsSumAggregateOutputType = {
    id: number | null
    salesReturnItem_id: number | null
    serial_id: number | null
  }

  export type SalesReturnItemSerialsMinAggregateOutputType = {
    id: number | null
    salesReturnItem_id: number | null
    serial_id: number | null
  }

  export type SalesReturnItemSerialsMaxAggregateOutputType = {
    id: number | null
    salesReturnItem_id: number | null
    serial_id: number | null
  }

  export type SalesReturnItemSerialsCountAggregateOutputType = {
    id: number
    salesReturnItem_id: number
    serial_id: number
    _all: number
  }


  export type SalesReturnItemSerialsAvgAggregateInputType = {
    id?: true
    salesReturnItem_id?: true
    serial_id?: true
  }

  export type SalesReturnItemSerialsSumAggregateInputType = {
    id?: true
    salesReturnItem_id?: true
    serial_id?: true
  }

  export type SalesReturnItemSerialsMinAggregateInputType = {
    id?: true
    salesReturnItem_id?: true
    serial_id?: true
  }

  export type SalesReturnItemSerialsMaxAggregateInputType = {
    id?: true
    salesReturnItem_id?: true
    serial_id?: true
  }

  export type SalesReturnItemSerialsCountAggregateInputType = {
    id?: true
    salesReturnItem_id?: true
    serial_id?: true
    _all?: true
  }

  export type SalesReturnItemSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnItemSerials to aggregate.
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItemSerials to fetch.
     */
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReturnItemSerials
    **/
    _count?: true | SalesReturnItemSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReturnItemSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReturnItemSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReturnItemSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReturnItemSerialsMaxAggregateInputType
  }

  export type GetSalesReturnItemSerialsAggregateType<T extends SalesReturnItemSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReturnItemSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReturnItemSerials[P]>
      : GetScalarType<T[P], AggregateSalesReturnItemSerials[P]>
  }




  export type SalesReturnItemSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnItemSerialsWhereInput
    orderBy?: SalesReturnItemSerialsOrderByWithAggregationInput | SalesReturnItemSerialsOrderByWithAggregationInput[]
    by: SalesReturnItemSerialsScalarFieldEnum[] | SalesReturnItemSerialsScalarFieldEnum
    having?: SalesReturnItemSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReturnItemSerialsCountAggregateInputType | true
    _avg?: SalesReturnItemSerialsAvgAggregateInputType
    _sum?: SalesReturnItemSerialsSumAggregateInputType
    _min?: SalesReturnItemSerialsMinAggregateInputType
    _max?: SalesReturnItemSerialsMaxAggregateInputType
  }

  export type SalesReturnItemSerialsGroupByOutputType = {
    id: number
    salesReturnItem_id: number
    serial_id: number
    _count: SalesReturnItemSerialsCountAggregateOutputType | null
    _avg: SalesReturnItemSerialsAvgAggregateOutputType | null
    _sum: SalesReturnItemSerialsSumAggregateOutputType | null
    _min: SalesReturnItemSerialsMinAggregateOutputType | null
    _max: SalesReturnItemSerialsMaxAggregateOutputType | null
  }

  type GetSalesReturnItemSerialsGroupByPayload<T extends SalesReturnItemSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReturnItemSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReturnItemSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReturnItemSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReturnItemSerialsGroupByOutputType[P]>
        }
      >
    >


  export type SalesReturnItemSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesReturnItem_id?: boolean
    serial_id?: boolean
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItemSerials"]>

  export type SalesReturnItemSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesReturnItem_id?: boolean
    serial_id?: boolean
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItemSerials"]>

  export type SalesReturnItemSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesReturnItem_id?: boolean
    serial_id?: boolean
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnItemSerials"]>

  export type SalesReturnItemSerialsSelectScalar = {
    id?: boolean
    salesReturnItem_id?: boolean
    serial_id?: boolean
  }

  export type SalesReturnItemSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesReturnItem_id" | "serial_id", ExtArgs["result"]["salesReturnItemSerials"]>
  export type SalesReturnItemSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type SalesReturnItemSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type SalesReturnItemSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnItems?: boolean | SalesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }

  export type $SalesReturnItemSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReturnItemSerials"
    objects: {
      SalesReturnItems: Prisma.$SalesReturnItemsPayload<ExtArgs>
      ProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesReturnItem_id: number
      serial_id: number
    }, ExtArgs["result"]["salesReturnItemSerials"]>
    composites: {}
  }

  type SalesReturnItemSerialsGetPayload<S extends boolean | null | undefined | SalesReturnItemSerialsDefaultArgs> = $Result.GetResult<Prisma.$SalesReturnItemSerialsPayload, S>

  type SalesReturnItemSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesReturnItemSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesReturnItemSerialsCountAggregateInputType | true
    }

  export interface SalesReturnItemSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReturnItemSerials'], meta: { name: 'SalesReturnItemSerials' } }
    /**
     * Find zero or one SalesReturnItemSerials that matches the filter.
     * @param {SalesReturnItemSerialsFindUniqueArgs} args - Arguments to find a SalesReturnItemSerials
     * @example
     * // Get one SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReturnItemSerialsFindUniqueArgs>(args: SelectSubset<T, SalesReturnItemSerialsFindUniqueArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesReturnItemSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesReturnItemSerialsFindUniqueOrThrowArgs} args - Arguments to find a SalesReturnItemSerials
     * @example
     * // Get one SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReturnItemSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsFindFirstArgs} args - Arguments to find a SalesReturnItemSerials
     * @example
     * // Get one SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReturnItemSerialsFindFirstArgs>(args?: SelectSubset<T, SalesReturnItemSerialsFindFirstArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnItemSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsFindFirstOrThrowArgs} args - Arguments to find a SalesReturnItemSerials
     * @example
     * // Get one SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReturnItemSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReturnItemSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesReturnItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findMany()
     * 
     * // Get first 10 SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReturnItemSerialsWithIdOnly = await prisma.salesReturnItemSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReturnItemSerialsFindManyArgs>(args?: SelectSubset<T, SalesReturnItemSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsCreateArgs} args - Arguments to create a SalesReturnItemSerials.
     * @example
     * // Create one SalesReturnItemSerials
     * const SalesReturnItemSerials = await prisma.salesReturnItemSerials.create({
     *   data: {
     *     // ... data to create a SalesReturnItemSerials
     *   }
     * })
     * 
     */
    create<T extends SalesReturnItemSerialsCreateArgs>(args: SelectSubset<T, SalesReturnItemSerialsCreateArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsCreateManyArgs} args - Arguments to create many SalesReturnItemSerials.
     * @example
     * // Create many SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReturnItemSerialsCreateManyArgs>(args?: SelectSubset<T, SalesReturnItemSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReturnItemSerials and returns the data saved in the database.
     * @param {SalesReturnItemSerialsCreateManyAndReturnArgs} args - Arguments to create many SalesReturnItemSerials.
     * @example
     * // Create many SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReturnItemSerials and only return the `id`
     * const salesReturnItemSerialsWithIdOnly = await prisma.salesReturnItemSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReturnItemSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReturnItemSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsDeleteArgs} args - Arguments to delete one SalesReturnItemSerials.
     * @example
     * // Delete one SalesReturnItemSerials
     * const SalesReturnItemSerials = await prisma.salesReturnItemSerials.delete({
     *   where: {
     *     // ... filter to delete one SalesReturnItemSerials
     *   }
     * })
     * 
     */
    delete<T extends SalesReturnItemSerialsDeleteArgs>(args: SelectSubset<T, SalesReturnItemSerialsDeleteArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsUpdateArgs} args - Arguments to update one SalesReturnItemSerials.
     * @example
     * // Update one SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReturnItemSerialsUpdateArgs>(args: SelectSubset<T, SalesReturnItemSerialsUpdateArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsDeleteManyArgs} args - Arguments to filter SalesReturnItemSerials to delete.
     * @example
     * // Delete a few SalesReturnItemSerials
     * const { count } = await prisma.salesReturnItemSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReturnItemSerialsDeleteManyArgs>(args?: SelectSubset<T, SalesReturnItemSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReturnItemSerialsUpdateManyArgs>(args: SelectSubset<T, SalesReturnItemSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnItemSerials and returns the data updated in the database.
     * @param {SalesReturnItemSerialsUpdateManyAndReturnArgs} args - Arguments to update many SalesReturnItemSerials.
     * @example
     * // Update many SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesReturnItemSerials and only return the `id`
     * const salesReturnItemSerialsWithIdOnly = await prisma.salesReturnItemSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesReturnItemSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesReturnItemSerials.
     * @param {SalesReturnItemSerialsUpsertArgs} args - Arguments to update or create a SalesReturnItemSerials.
     * @example
     * // Update or create a SalesReturnItemSerials
     * const salesReturnItemSerials = await prisma.salesReturnItemSerials.upsert({
     *   create: {
     *     // ... data to create a SalesReturnItemSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReturnItemSerials we want to update
     *   }
     * })
     */
    upsert<T extends SalesReturnItemSerialsUpsertArgs>(args: SelectSubset<T, SalesReturnItemSerialsUpsertArgs<ExtArgs>>): Prisma__SalesReturnItemSerialsClient<$Result.GetResult<Prisma.$SalesReturnItemSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsCountArgs} args - Arguments to filter SalesReturnItemSerials to count.
     * @example
     * // Count the number of SalesReturnItemSerials
     * const count = await prisma.salesReturnItemSerials.count({
     *   where: {
     *     // ... the filter for the SalesReturnItemSerials we want to count
     *   }
     * })
    **/
    count<T extends SalesReturnItemSerialsCountArgs>(
      args?: Subset<T, SalesReturnItemSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReturnItemSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReturnItemSerialsAggregateArgs>(args: Subset<T, SalesReturnItemSerialsAggregateArgs>): Prisma.PrismaPromise<GetSalesReturnItemSerialsAggregateType<T>>

    /**
     * Group by SalesReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnItemSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReturnItemSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReturnItemSerialsGroupByArgs['orderBy'] }
        : { orderBy?: SalesReturnItemSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReturnItemSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReturnItemSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReturnItemSerials model
   */
  readonly fields: SalesReturnItemSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReturnItemSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReturnItemSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SalesReturnItems<T extends SalesReturnItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnItemsDefaultArgs<ExtArgs>>): Prisma__SalesReturnItemsClient<$Result.GetResult<Prisma.$SalesReturnItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReturnItemSerials model
   */
  interface SalesReturnItemSerialsFieldRefs {
    readonly id: FieldRef<"SalesReturnItemSerials", 'Int'>
    readonly salesReturnItem_id: FieldRef<"SalesReturnItemSerials", 'Int'>
    readonly serial_id: FieldRef<"SalesReturnItemSerials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalesReturnItemSerials findUnique
   */
  export type SalesReturnItemSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItemSerials to fetch.
     */
    where: SalesReturnItemSerialsWhereUniqueInput
  }

  /**
   * SalesReturnItemSerials findUniqueOrThrow
   */
  export type SalesReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItemSerials to fetch.
     */
    where: SalesReturnItemSerialsWhereUniqueInput
  }

  /**
   * SalesReturnItemSerials findFirst
   */
  export type SalesReturnItemSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItemSerials to fetch.
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItemSerials to fetch.
     */
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnItemSerials.
     */
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnItemSerials.
     */
    distinct?: SalesReturnItemSerialsScalarFieldEnum | SalesReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesReturnItemSerials findFirstOrThrow
   */
  export type SalesReturnItemSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItemSerials to fetch.
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItemSerials to fetch.
     */
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnItemSerials.
     */
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnItemSerials.
     */
    distinct?: SalesReturnItemSerialsScalarFieldEnum | SalesReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesReturnItemSerials findMany
   */
  export type SalesReturnItemSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnItemSerials to fetch.
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnItemSerials to fetch.
     */
    orderBy?: SalesReturnItemSerialsOrderByWithRelationInput | SalesReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReturnItemSerials.
     */
    cursor?: SalesReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnItemSerials.
     */
    skip?: number
    distinct?: SalesReturnItemSerialsScalarFieldEnum | SalesReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * SalesReturnItemSerials create
   */
  export type SalesReturnItemSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReturnItemSerials.
     */
    data: XOR<SalesReturnItemSerialsCreateInput, SalesReturnItemSerialsUncheckedCreateInput>
  }

  /**
   * SalesReturnItemSerials createMany
   */
  export type SalesReturnItemSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReturnItemSerials.
     */
    data: SalesReturnItemSerialsCreateManyInput | SalesReturnItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReturnItemSerials createManyAndReturn
   */
  export type SalesReturnItemSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many SalesReturnItemSerials.
     */
    data: SalesReturnItemSerialsCreateManyInput | SalesReturnItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnItemSerials update
   */
  export type SalesReturnItemSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReturnItemSerials.
     */
    data: XOR<SalesReturnItemSerialsUpdateInput, SalesReturnItemSerialsUncheckedUpdateInput>
    /**
     * Choose, which SalesReturnItemSerials to update.
     */
    where: SalesReturnItemSerialsWhereUniqueInput
  }

  /**
   * SalesReturnItemSerials updateMany
   */
  export type SalesReturnItemSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReturnItemSerials.
     */
    data: XOR<SalesReturnItemSerialsUpdateManyMutationInput, SalesReturnItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnItemSerials to update
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * Limit how many SalesReturnItemSerials to update.
     */
    limit?: number
  }

  /**
   * SalesReturnItemSerials updateManyAndReturn
   */
  export type SalesReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to update SalesReturnItemSerials.
     */
    data: XOR<SalesReturnItemSerialsUpdateManyMutationInput, SalesReturnItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnItemSerials to update
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * Limit how many SalesReturnItemSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnItemSerials upsert
   */
  export type SalesReturnItemSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReturnItemSerials to update in case it exists.
     */
    where: SalesReturnItemSerialsWhereUniqueInput
    /**
     * In case the SalesReturnItemSerials found by the `where` argument doesn't exist, create a new SalesReturnItemSerials with this data.
     */
    create: XOR<SalesReturnItemSerialsCreateInput, SalesReturnItemSerialsUncheckedCreateInput>
    /**
     * In case the SalesReturnItemSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReturnItemSerialsUpdateInput, SalesReturnItemSerialsUncheckedUpdateInput>
  }

  /**
   * SalesReturnItemSerials delete
   */
  export type SalesReturnItemSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter which SalesReturnItemSerials to delete.
     */
    where: SalesReturnItemSerialsWhereUniqueInput
  }

  /**
   * SalesReturnItemSerials deleteMany
   */
  export type SalesReturnItemSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnItemSerials to delete
     */
    where?: SalesReturnItemSerialsWhereInput
    /**
     * Limit how many SalesReturnItemSerials to delete.
     */
    limit?: number
  }

  /**
   * SalesReturnItemSerials without action
   */
  export type SalesReturnItemSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnItemSerials
     */
    select?: SalesReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnItemSerials
     */
    omit?: SalesReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnItemSerialsInclude<ExtArgs> | null
  }


  /**
   * Model Exchanges
   */

  export type AggregateExchanges = {
    _count: ExchangesCountAggregateOutputType | null
    _avg: ExchangesAvgAggregateOutputType | null
    _sum: ExchangesSumAggregateOutputType | null
    _min: ExchangesMinAggregateOutputType | null
    _max: ExchangesMaxAggregateOutputType | null
  }

  export type ExchangesAvgAggregateOutputType = {
    id: number | null
    totalPaid: Decimal | null
    totalPayback: Decimal | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
  }

  export type ExchangesSumAggregateOutputType = {
    id: number | null
    totalPaid: Decimal | null
    totalPayback: Decimal | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
  }

  export type ExchangesMinAggregateOutputType = {
    id: number | null
    exchangeNo: string | null
    totalPaid: Decimal | null
    totalPayback: Decimal | null
    note: string | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangesMaxAggregateOutputType = {
    id: number | null
    exchangeNo: string | null
    totalPaid: Decimal | null
    totalPayback: Decimal | null
    note: string | null
    sales_id: number | null
    user_id: number | null
    customer_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangesCountAggregateOutputType = {
    id: number
    exchangeNo: number
    totalPaid: number
    totalPayback: number
    note: number
    sales_id: number
    user_id: number
    customer_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExchangesAvgAggregateInputType = {
    id?: true
    totalPaid?: true
    totalPayback?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
  }

  export type ExchangesSumAggregateInputType = {
    id?: true
    totalPaid?: true
    totalPayback?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
  }

  export type ExchangesMinAggregateInputType = {
    id?: true
    exchangeNo?: true
    totalPaid?: true
    totalPayback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangesMaxAggregateInputType = {
    id?: true
    exchangeNo?: true
    totalPaid?: true
    totalPayback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangesCountAggregateInputType = {
    id?: true
    exchangeNo?: true
    totalPaid?: true
    totalPayback?: true
    note?: true
    sales_id?: true
    user_id?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExchangesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exchanges to aggregate.
     */
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     */
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exchanges
    **/
    _count?: true | ExchangesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangesMaxAggregateInputType
  }

  export type GetExchangesAggregateType<T extends ExchangesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchanges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchanges[P]>
      : GetScalarType<T[P], AggregateExchanges[P]>
  }




  export type ExchangesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesWhereInput
    orderBy?: ExchangesOrderByWithAggregationInput | ExchangesOrderByWithAggregationInput[]
    by: ExchangesScalarFieldEnum[] | ExchangesScalarFieldEnum
    having?: ExchangesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangesCountAggregateInputType | true
    _avg?: ExchangesAvgAggregateInputType
    _sum?: ExchangesSumAggregateInputType
    _min?: ExchangesMinAggregateInputType
    _max?: ExchangesMaxAggregateInputType
  }

  export type ExchangesGroupByOutputType = {
    id: number
    exchangeNo: string
    totalPaid: Decimal
    totalPayback: Decimal
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt: Date
    updatedAt: Date
    _count: ExchangesCountAggregateOutputType | null
    _avg: ExchangesAvgAggregateOutputType | null
    _sum: ExchangesSumAggregateOutputType | null
    _min: ExchangesMinAggregateOutputType | null
    _max: ExchangesMaxAggregateOutputType | null
  }

  type GetExchangesGroupByPayload<T extends ExchangesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangesGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangesGroupByOutputType[P]>
        }
      >
    >


  export type ExchangesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNo?: boolean
    totalPaid?: boolean
    totalPayback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
    ExchangeItems?: boolean | Exchanges$ExchangeItemsArgs<ExtArgs>
    _count?: boolean | ExchangesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchanges"]>

  export type ExchangesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNo?: boolean
    totalPaid?: boolean
    totalPayback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
  }, ExtArgs["result"]["exchanges"]>

  export type ExchangesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNo?: boolean
    totalPaid?: boolean
    totalPayback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
  }, ExtArgs["result"]["exchanges"]>

  export type ExchangesSelectScalar = {
    id?: boolean
    exchangeNo?: boolean
    totalPaid?: boolean
    totalPayback?: boolean
    note?: boolean
    sales_id?: boolean
    user_id?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExchangesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exchangeNo" | "totalPaid" | "totalPayback" | "note" | "sales_id" | "user_id" | "customer_id" | "createdAt" | "updatedAt", ExtArgs["result"]["exchanges"]>
  export type ExchangesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
    ExchangeItems?: boolean | Exchanges$ExchangeItemsArgs<ExtArgs>
    _count?: boolean | ExchangesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExchangesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
  }
  export type ExchangesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sales?: boolean | Exchanges$SalesArgs<ExtArgs>
    Users?: boolean | Exchanges$UsersArgs<ExtArgs>
    Customers?: boolean | Exchanges$CustomersArgs<ExtArgs>
  }

  export type $ExchangesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exchanges"
    objects: {
      Sales: Prisma.$SalesPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Customers: Prisma.$CustomersPayload<ExtArgs> | null
      ExchangeItems: Prisma.$ExchangesItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exchangeNo: string
      totalPaid: Prisma.Decimal
      totalPayback: Prisma.Decimal
      note: string
      sales_id: number
      user_id: number
      customer_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exchanges"]>
    composites: {}
  }

  type ExchangesGetPayload<S extends boolean | null | undefined | ExchangesDefaultArgs> = $Result.GetResult<Prisma.$ExchangesPayload, S>

  type ExchangesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangesCountAggregateInputType | true
    }

  export interface ExchangesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exchanges'], meta: { name: 'Exchanges' } }
    /**
     * Find zero or one Exchanges that matches the filter.
     * @param {ExchangesFindUniqueArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangesFindUniqueArgs>(args: SelectSubset<T, ExchangesFindUniqueArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exchanges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangesFindUniqueOrThrowArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangesFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindFirstArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangesFindFirstArgs>(args?: SelectSubset<T, ExchangesFindFirstArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchanges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindFirstOrThrowArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangesFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchanges
     * const exchanges = await prisma.exchanges.findMany()
     * 
     * // Get first 10 Exchanges
     * const exchanges = await prisma.exchanges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangesWithIdOnly = await prisma.exchanges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangesFindManyArgs>(args?: SelectSubset<T, ExchangesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exchanges.
     * @param {ExchangesCreateArgs} args - Arguments to create a Exchanges.
     * @example
     * // Create one Exchanges
     * const Exchanges = await prisma.exchanges.create({
     *   data: {
     *     // ... data to create a Exchanges
     *   }
     * })
     * 
     */
    create<T extends ExchangesCreateArgs>(args: SelectSubset<T, ExchangesCreateArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exchanges.
     * @param {ExchangesCreateManyArgs} args - Arguments to create many Exchanges.
     * @example
     * // Create many Exchanges
     * const exchanges = await prisma.exchanges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangesCreateManyArgs>(args?: SelectSubset<T, ExchangesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exchanges and returns the data saved in the database.
     * @param {ExchangesCreateManyAndReturnArgs} args - Arguments to create many Exchanges.
     * @example
     * // Create many Exchanges
     * const exchanges = await prisma.exchanges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exchanges and only return the `id`
     * const exchangesWithIdOnly = await prisma.exchanges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangesCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exchanges.
     * @param {ExchangesDeleteArgs} args - Arguments to delete one Exchanges.
     * @example
     * // Delete one Exchanges
     * const Exchanges = await prisma.exchanges.delete({
     *   where: {
     *     // ... filter to delete one Exchanges
     *   }
     * })
     * 
     */
    delete<T extends ExchangesDeleteArgs>(args: SelectSubset<T, ExchangesDeleteArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exchanges.
     * @param {ExchangesUpdateArgs} args - Arguments to update one Exchanges.
     * @example
     * // Update one Exchanges
     * const exchanges = await prisma.exchanges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangesUpdateArgs>(args: SelectSubset<T, ExchangesUpdateArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exchanges.
     * @param {ExchangesDeleteManyArgs} args - Arguments to filter Exchanges to delete.
     * @example
     * // Delete a few Exchanges
     * const { count } = await prisma.exchanges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangesDeleteManyArgs>(args?: SelectSubset<T, ExchangesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchanges
     * const exchanges = await prisma.exchanges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangesUpdateManyArgs>(args: SelectSubset<T, ExchangesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchanges and returns the data updated in the database.
     * @param {ExchangesUpdateManyAndReturnArgs} args - Arguments to update many Exchanges.
     * @example
     * // Update many Exchanges
     * const exchanges = await prisma.exchanges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exchanges and only return the `id`
     * const exchangesWithIdOnly = await prisma.exchanges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangesUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exchanges.
     * @param {ExchangesUpsertArgs} args - Arguments to update or create a Exchanges.
     * @example
     * // Update or create a Exchanges
     * const exchanges = await prisma.exchanges.upsert({
     *   create: {
     *     // ... data to create a Exchanges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchanges we want to update
     *   }
     * })
     */
    upsert<T extends ExchangesUpsertArgs>(args: SelectSubset<T, ExchangesUpsertArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesCountArgs} args - Arguments to filter Exchanges to count.
     * @example
     * // Count the number of Exchanges
     * const count = await prisma.exchanges.count({
     *   where: {
     *     // ... the filter for the Exchanges we want to count
     *   }
     * })
    **/
    count<T extends ExchangesCountArgs>(
      args?: Subset<T, ExchangesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangesAggregateArgs>(args: Subset<T, ExchangesAggregateArgs>): Prisma.PrismaPromise<GetExchangesAggregateType<T>>

    /**
     * Group by Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangesGroupByArgs['orderBy'] }
        : { orderBy?: ExchangesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exchanges model
   */
  readonly fields: ExchangesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exchanges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sales<T extends Exchanges$SalesArgs<ExtArgs> = {}>(args?: Subset<T, Exchanges$SalesArgs<ExtArgs>>): Prisma__SalesClient<$Result.GetResult<Prisma.$SalesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends Exchanges$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Exchanges$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Customers<T extends Exchanges$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Exchanges$CustomersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ExchangeItems<T extends Exchanges$ExchangeItemsArgs<ExtArgs> = {}>(args?: Subset<T, Exchanges$ExchangeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exchanges model
   */
  interface ExchangesFieldRefs {
    readonly id: FieldRef<"Exchanges", 'Int'>
    readonly exchangeNo: FieldRef<"Exchanges", 'String'>
    readonly totalPaid: FieldRef<"Exchanges", 'Decimal'>
    readonly totalPayback: FieldRef<"Exchanges", 'Decimal'>
    readonly note: FieldRef<"Exchanges", 'String'>
    readonly sales_id: FieldRef<"Exchanges", 'Int'>
    readonly user_id: FieldRef<"Exchanges", 'Int'>
    readonly customer_id: FieldRef<"Exchanges", 'Int'>
    readonly createdAt: FieldRef<"Exchanges", 'DateTime'>
    readonly updatedAt: FieldRef<"Exchanges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exchanges findUnique
   */
  export type ExchangesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter, which Exchanges to fetch.
     */
    where: ExchangesWhereUniqueInput
  }

  /**
   * Exchanges findUniqueOrThrow
   */
  export type ExchangesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter, which Exchanges to fetch.
     */
    where: ExchangesWhereUniqueInput
  }

  /**
   * Exchanges findFirst
   */
  export type ExchangesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter, which Exchanges to fetch.
     */
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     */
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exchanges.
     */
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exchanges.
     */
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Exchanges findFirstOrThrow
   */
  export type ExchangesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter, which Exchanges to fetch.
     */
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     */
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exchanges.
     */
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exchanges.
     */
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Exchanges findMany
   */
  export type ExchangesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter, which Exchanges to fetch.
     */
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     */
    orderBy?: ExchangesOrderByWithRelationInput | ExchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exchanges.
     */
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     */
    skip?: number
    distinct?: ExchangesScalarFieldEnum | ExchangesScalarFieldEnum[]
  }

  /**
   * Exchanges create
   */
  export type ExchangesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * The data needed to create a Exchanges.
     */
    data: XOR<ExchangesCreateInput, ExchangesUncheckedCreateInput>
  }

  /**
   * Exchanges createMany
   */
  export type ExchangesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exchanges.
     */
    data: ExchangesCreateManyInput | ExchangesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exchanges createManyAndReturn
   */
  export type ExchangesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * The data used to create many Exchanges.
     */
    data: ExchangesCreateManyInput | ExchangesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exchanges update
   */
  export type ExchangesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * The data needed to update a Exchanges.
     */
    data: XOR<ExchangesUpdateInput, ExchangesUncheckedUpdateInput>
    /**
     * Choose, which Exchanges to update.
     */
    where: ExchangesWhereUniqueInput
  }

  /**
   * Exchanges updateMany
   */
  export type ExchangesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exchanges.
     */
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyInput>
    /**
     * Filter which Exchanges to update
     */
    where?: ExchangesWhereInput
    /**
     * Limit how many Exchanges to update.
     */
    limit?: number
  }

  /**
   * Exchanges updateManyAndReturn
   */
  export type ExchangesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * The data used to update Exchanges.
     */
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyInput>
    /**
     * Filter which Exchanges to update
     */
    where?: ExchangesWhereInput
    /**
     * Limit how many Exchanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exchanges upsert
   */
  export type ExchangesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * The filter to search for the Exchanges to update in case it exists.
     */
    where: ExchangesWhereUniqueInput
    /**
     * In case the Exchanges found by the `where` argument doesn't exist, create a new Exchanges with this data.
     */
    create: XOR<ExchangesCreateInput, ExchangesUncheckedCreateInput>
    /**
     * In case the Exchanges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangesUpdateInput, ExchangesUncheckedUpdateInput>
  }

  /**
   * Exchanges delete
   */
  export type ExchangesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    /**
     * Filter which Exchanges to delete.
     */
    where: ExchangesWhereUniqueInput
  }

  /**
   * Exchanges deleteMany
   */
  export type ExchangesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exchanges to delete
     */
    where?: ExchangesWhereInput
    /**
     * Limit how many Exchanges to delete.
     */
    limit?: number
  }

  /**
   * Exchanges.Sales
   */
  export type Exchanges$SalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sales
     */
    select?: SalesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sales
     */
    omit?: SalesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInclude<ExtArgs> | null
    where?: SalesWhereInput
  }

  /**
   * Exchanges.Users
   */
  export type Exchanges$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Exchanges.Customers
   */
  export type Exchanges$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }

  /**
   * Exchanges.ExchangeItems
   */
  export type Exchanges$ExchangeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    where?: ExchangesItemsWhereInput
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    cursor?: ExchangesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * Exchanges without action
   */
  export type ExchangesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
  }


  /**
   * Model ExchangesItems
   */

  export type AggregateExchangesItems = {
    _count: ExchangesItemsCountAggregateOutputType | null
    _avg: ExchangesItemsAvgAggregateOutputType | null
    _sum: ExchangesItemsSumAggregateOutputType | null
    _min: ExchangesItemsMinAggregateOutputType | null
    _max: ExchangesItemsMaxAggregateOutputType | null
  }

  export type ExchangesItemsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    oldProduct_id: number | null
    newProduct_id: number | null
    exchangeId: number | null
  }

  export type ExchangesItemsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    oldProduct_id: number | null
    newProduct_id: number | null
    exchangeId: number | null
  }

  export type ExchangesItemsMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    note: string | null
    oldProduct_id: number | null
    newProduct_id: number | null
    exchangeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangesItemsMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    note: string | null
    oldProduct_id: number | null
    newProduct_id: number | null
    exchangeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExchangesItemsCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    note: number
    oldProduct_id: number
    newProduct_id: number
    exchangeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExchangesItemsAvgAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    oldProduct_id?: true
    newProduct_id?: true
    exchangeId?: true
  }

  export type ExchangesItemsSumAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    oldProduct_id?: true
    newProduct_id?: true
    exchangeId?: true
  }

  export type ExchangesItemsMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    note?: true
    oldProduct_id?: true
    newProduct_id?: true
    exchangeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangesItemsMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    note?: true
    oldProduct_id?: true
    newProduct_id?: true
    exchangeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExchangesItemsCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    note?: true
    oldProduct_id?: true
    newProduct_id?: true
    exchangeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExchangesItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangesItems to aggregate.
     */
    where?: ExchangesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangesItems to fetch.
     */
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangesItems
    **/
    _count?: true | ExchangesItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangesItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangesItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangesItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangesItemsMaxAggregateInputType
  }

  export type GetExchangesItemsAggregateType<T extends ExchangesItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangesItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangesItems[P]>
      : GetScalarType<T[P], AggregateExchangesItems[P]>
  }




  export type ExchangesItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangesItemsWhereInput
    orderBy?: ExchangesItemsOrderByWithAggregationInput | ExchangesItemsOrderByWithAggregationInput[]
    by: ExchangesItemsScalarFieldEnum[] | ExchangesItemsScalarFieldEnum
    having?: ExchangesItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangesItemsCountAggregateInputType | true
    _avg?: ExchangesItemsAvgAggregateInputType
    _sum?: ExchangesItemsSumAggregateInputType
    _min?: ExchangesItemsMinAggregateInputType
    _max?: ExchangesItemsMaxAggregateInputType
  }

  export type ExchangesItemsGroupByOutputType = {
    id: number
    quantity: number
    unitPrice: Decimal
    note: string
    oldProduct_id: number
    newProduct_id: number
    exchangeId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ExchangesItemsCountAggregateOutputType | null
    _avg: ExchangesItemsAvgAggregateOutputType | null
    _sum: ExchangesItemsSumAggregateOutputType | null
    _min: ExchangesItemsMinAggregateOutputType | null
    _max: ExchangesItemsMaxAggregateOutputType | null
  }

  type GetExchangesItemsGroupByPayload<T extends ExchangesItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangesItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangesItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangesItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangesItemsGroupByOutputType[P]>
        }
      >
    >


  export type ExchangesItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    note?: boolean
    oldProduct_id?: boolean
    newProduct_id?: boolean
    exchangeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
    exchangeItemSerials?: boolean | ExchangesItems$exchangeItemSerialsArgs<ExtArgs>
    _count?: boolean | ExchangesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangesItems"]>

  export type ExchangesItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    note?: boolean
    oldProduct_id?: boolean
    newProduct_id?: boolean
    exchangeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
  }, ExtArgs["result"]["exchangesItems"]>

  export type ExchangesItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    note?: boolean
    oldProduct_id?: boolean
    newProduct_id?: boolean
    exchangeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
  }, ExtArgs["result"]["exchangesItems"]>

  export type ExchangesItemsSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    note?: boolean
    oldProduct_id?: boolean
    newProduct_id?: boolean
    exchangeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExchangesItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "note" | "oldProduct_id" | "newProduct_id" | "exchangeId" | "createdAt" | "updatedAt", ExtArgs["result"]["exchangesItems"]>
  export type ExchangesItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
    exchangeItemSerials?: boolean | ExchangesItems$exchangeItemSerialsArgs<ExtArgs>
    _count?: boolean | ExchangesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExchangesItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
  }
  export type ExchangesItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oldProduct?: boolean | ExchangesItems$oldProductArgs<ExtArgs>
    newProduct?: boolean | ExchangesItems$newProductArgs<ExtArgs>
    Exchanges?: boolean | ExchangesItems$ExchangesArgs<ExtArgs>
  }

  export type $ExchangesItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangesItems"
    objects: {
      oldProduct: Prisma.$ProductsPayload<ExtArgs> | null
      newProduct: Prisma.$ProductsPayload<ExtArgs> | null
      Exchanges: Prisma.$ExchangesPayload<ExtArgs> | null
      exchangeItemSerials: Prisma.$ExchangeItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      unitPrice: Prisma.Decimal
      note: string
      oldProduct_id: number
      newProduct_id: number
      exchangeId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exchangesItems"]>
    composites: {}
  }

  type ExchangesItemsGetPayload<S extends boolean | null | undefined | ExchangesItemsDefaultArgs> = $Result.GetResult<Prisma.$ExchangesItemsPayload, S>

  type ExchangesItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangesItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangesItemsCountAggregateInputType | true
    }

  export interface ExchangesItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangesItems'], meta: { name: 'ExchangesItems' } }
    /**
     * Find zero or one ExchangesItems that matches the filter.
     * @param {ExchangesItemsFindUniqueArgs} args - Arguments to find a ExchangesItems
     * @example
     * // Get one ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangesItemsFindUniqueArgs>(args: SelectSubset<T, ExchangesItemsFindUniqueArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExchangesItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangesItemsFindUniqueOrThrowArgs} args - Arguments to find a ExchangesItems
     * @example
     * // Get one ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangesItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangesItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsFindFirstArgs} args - Arguments to find a ExchangesItems
     * @example
     * // Get one ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangesItemsFindFirstArgs>(args?: SelectSubset<T, ExchangesItemsFindFirstArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangesItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsFindFirstOrThrowArgs} args - Arguments to find a ExchangesItems
     * @example
     * // Get one ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangesItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangesItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExchangesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findMany()
     * 
     * // Get first 10 ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangesItemsWithIdOnly = await prisma.exchangesItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangesItemsFindManyArgs>(args?: SelectSubset<T, ExchangesItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExchangesItems.
     * @param {ExchangesItemsCreateArgs} args - Arguments to create a ExchangesItems.
     * @example
     * // Create one ExchangesItems
     * const ExchangesItems = await prisma.exchangesItems.create({
     *   data: {
     *     // ... data to create a ExchangesItems
     *   }
     * })
     * 
     */
    create<T extends ExchangesItemsCreateArgs>(args: SelectSubset<T, ExchangesItemsCreateArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExchangesItems.
     * @param {ExchangesItemsCreateManyArgs} args - Arguments to create many ExchangesItems.
     * @example
     * // Create many ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangesItemsCreateManyArgs>(args?: SelectSubset<T, ExchangesItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangesItems and returns the data saved in the database.
     * @param {ExchangesItemsCreateManyAndReturnArgs} args - Arguments to create many ExchangesItems.
     * @example
     * // Create many ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangesItems and only return the `id`
     * const exchangesItemsWithIdOnly = await prisma.exchangesItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangesItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangesItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExchangesItems.
     * @param {ExchangesItemsDeleteArgs} args - Arguments to delete one ExchangesItems.
     * @example
     * // Delete one ExchangesItems
     * const ExchangesItems = await prisma.exchangesItems.delete({
     *   where: {
     *     // ... filter to delete one ExchangesItems
     *   }
     * })
     * 
     */
    delete<T extends ExchangesItemsDeleteArgs>(args: SelectSubset<T, ExchangesItemsDeleteArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExchangesItems.
     * @param {ExchangesItemsUpdateArgs} args - Arguments to update one ExchangesItems.
     * @example
     * // Update one ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangesItemsUpdateArgs>(args: SelectSubset<T, ExchangesItemsUpdateArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExchangesItems.
     * @param {ExchangesItemsDeleteManyArgs} args - Arguments to filter ExchangesItems to delete.
     * @example
     * // Delete a few ExchangesItems
     * const { count } = await prisma.exchangesItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangesItemsDeleteManyArgs>(args?: SelectSubset<T, ExchangesItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangesItemsUpdateManyArgs>(args: SelectSubset<T, ExchangesItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangesItems and returns the data updated in the database.
     * @param {ExchangesItemsUpdateManyAndReturnArgs} args - Arguments to update many ExchangesItems.
     * @example
     * // Update many ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExchangesItems and only return the `id`
     * const exchangesItemsWithIdOnly = await prisma.exchangesItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangesItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangesItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExchangesItems.
     * @param {ExchangesItemsUpsertArgs} args - Arguments to update or create a ExchangesItems.
     * @example
     * // Update or create a ExchangesItems
     * const exchangesItems = await prisma.exchangesItems.upsert({
     *   create: {
     *     // ... data to create a ExchangesItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangesItems we want to update
     *   }
     * })
     */
    upsert<T extends ExchangesItemsUpsertArgs>(args: SelectSubset<T, ExchangesItemsUpsertArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExchangesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsCountArgs} args - Arguments to filter ExchangesItems to count.
     * @example
     * // Count the number of ExchangesItems
     * const count = await prisma.exchangesItems.count({
     *   where: {
     *     // ... the filter for the ExchangesItems we want to count
     *   }
     * })
    **/
    count<T extends ExchangesItemsCountArgs>(
      args?: Subset<T, ExchangesItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangesItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangesItemsAggregateArgs>(args: Subset<T, ExchangesItemsAggregateArgs>): Prisma.PrismaPromise<GetExchangesItemsAggregateType<T>>

    /**
     * Group by ExchangesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangesItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangesItemsGroupByArgs['orderBy'] }
        : { orderBy?: ExchangesItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangesItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangesItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangesItems model
   */
  readonly fields: ExchangesItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangesItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangesItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    oldProduct<T extends ExchangesItems$oldProductArgs<ExtArgs> = {}>(args?: Subset<T, ExchangesItems$oldProductArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    newProduct<T extends ExchangesItems$newProductArgs<ExtArgs> = {}>(args?: Subset<T, ExchangesItems$newProductArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Exchanges<T extends ExchangesItems$ExchangesArgs<ExtArgs> = {}>(args?: Subset<T, ExchangesItems$ExchangesArgs<ExtArgs>>): Prisma__ExchangesClient<$Result.GetResult<Prisma.$ExchangesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    exchangeItemSerials<T extends ExchangesItems$exchangeItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, ExchangesItems$exchangeItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangesItems model
   */
  interface ExchangesItemsFieldRefs {
    readonly id: FieldRef<"ExchangesItems", 'Int'>
    readonly quantity: FieldRef<"ExchangesItems", 'Int'>
    readonly unitPrice: FieldRef<"ExchangesItems", 'Decimal'>
    readonly note: FieldRef<"ExchangesItems", 'String'>
    readonly oldProduct_id: FieldRef<"ExchangesItems", 'Int'>
    readonly newProduct_id: FieldRef<"ExchangesItems", 'Int'>
    readonly exchangeId: FieldRef<"ExchangesItems", 'Int'>
    readonly createdAt: FieldRef<"ExchangesItems", 'DateTime'>
    readonly updatedAt: FieldRef<"ExchangesItems", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExchangesItems findUnique
   */
  export type ExchangesItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangesItems to fetch.
     */
    where: ExchangesItemsWhereUniqueInput
  }

  /**
   * ExchangesItems findUniqueOrThrow
   */
  export type ExchangesItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangesItems to fetch.
     */
    where: ExchangesItemsWhereUniqueInput
  }

  /**
   * ExchangesItems findFirst
   */
  export type ExchangesItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangesItems to fetch.
     */
    where?: ExchangesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangesItems to fetch.
     */
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangesItems.
     */
    cursor?: ExchangesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangesItems.
     */
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * ExchangesItems findFirstOrThrow
   */
  export type ExchangesItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangesItems to fetch.
     */
    where?: ExchangesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangesItems to fetch.
     */
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangesItems.
     */
    cursor?: ExchangesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangesItems.
     */
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * ExchangesItems findMany
   */
  export type ExchangesItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangesItems to fetch.
     */
    where?: ExchangesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangesItems to fetch.
     */
    orderBy?: ExchangesItemsOrderByWithRelationInput | ExchangesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangesItems.
     */
    cursor?: ExchangesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangesItems.
     */
    skip?: number
    distinct?: ExchangesItemsScalarFieldEnum | ExchangesItemsScalarFieldEnum[]
  }

  /**
   * ExchangesItems create
   */
  export type ExchangesItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a ExchangesItems.
     */
    data: XOR<ExchangesItemsCreateInput, ExchangesItemsUncheckedCreateInput>
  }

  /**
   * ExchangesItems createMany
   */
  export type ExchangesItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangesItems.
     */
    data: ExchangesItemsCreateManyInput | ExchangesItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangesItems createManyAndReturn
   */
  export type ExchangesItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * The data used to create many ExchangesItems.
     */
    data: ExchangesItemsCreateManyInput | ExchangesItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangesItems update
   */
  export type ExchangesItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a ExchangesItems.
     */
    data: XOR<ExchangesItemsUpdateInput, ExchangesItemsUncheckedUpdateInput>
    /**
     * Choose, which ExchangesItems to update.
     */
    where: ExchangesItemsWhereUniqueInput
  }

  /**
   * ExchangesItems updateMany
   */
  export type ExchangesItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangesItems.
     */
    data: XOR<ExchangesItemsUpdateManyMutationInput, ExchangesItemsUncheckedUpdateManyInput>
    /**
     * Filter which ExchangesItems to update
     */
    where?: ExchangesItemsWhereInput
    /**
     * Limit how many ExchangesItems to update.
     */
    limit?: number
  }

  /**
   * ExchangesItems updateManyAndReturn
   */
  export type ExchangesItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * The data used to update ExchangesItems.
     */
    data: XOR<ExchangesItemsUpdateManyMutationInput, ExchangesItemsUncheckedUpdateManyInput>
    /**
     * Filter which ExchangesItems to update
     */
    where?: ExchangesItemsWhereInput
    /**
     * Limit how many ExchangesItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangesItems upsert
   */
  export type ExchangesItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the ExchangesItems to update in case it exists.
     */
    where: ExchangesItemsWhereUniqueInput
    /**
     * In case the ExchangesItems found by the `where` argument doesn't exist, create a new ExchangesItems with this data.
     */
    create: XOR<ExchangesItemsCreateInput, ExchangesItemsUncheckedCreateInput>
    /**
     * In case the ExchangesItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangesItemsUpdateInput, ExchangesItemsUncheckedUpdateInput>
  }

  /**
   * ExchangesItems delete
   */
  export type ExchangesItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
    /**
     * Filter which ExchangesItems to delete.
     */
    where: ExchangesItemsWhereUniqueInput
  }

  /**
   * ExchangesItems deleteMany
   */
  export type ExchangesItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangesItems to delete
     */
    where?: ExchangesItemsWhereInput
    /**
     * Limit how many ExchangesItems to delete.
     */
    limit?: number
  }

  /**
   * ExchangesItems.oldProduct
   */
  export type ExchangesItems$oldProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * ExchangesItems.newProduct
   */
  export type ExchangesItems$newProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * ExchangesItems.Exchanges
   */
  export type ExchangesItems$ExchangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exchanges
     */
    select?: ExchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exchanges
     */
    omit?: ExchangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesInclude<ExtArgs> | null
    where?: ExchangesWhereInput
  }

  /**
   * ExchangesItems.exchangeItemSerials
   */
  export type ExchangesItems$exchangeItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    where?: ExchangeItemSerialsWhereInput
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    cursor?: ExchangeItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ExchangesItems without action
   */
  export type ExchangesItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangesItems
     */
    select?: ExchangesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangesItems
     */
    omit?: ExchangesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangesItemsInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeItemSerials
   */

  export type AggregateExchangeItemSerials = {
    _count: ExchangeItemSerialsCountAggregateOutputType | null
    _avg: ExchangeItemSerialsAvgAggregateOutputType | null
    _sum: ExchangeItemSerialsSumAggregateOutputType | null
    _min: ExchangeItemSerialsMinAggregateOutputType | null
    _max: ExchangeItemSerialsMaxAggregateOutputType | null
  }

  export type ExchangeItemSerialsAvgAggregateOutputType = {
    id: number | null
    exchangeItem_id: number | null
    serial_id_old: number | null
    serial_id_new: number | null
  }

  export type ExchangeItemSerialsSumAggregateOutputType = {
    id: number | null
    exchangeItem_id: number | null
    serial_id_old: number | null
    serial_id_new: number | null
  }

  export type ExchangeItemSerialsMinAggregateOutputType = {
    id: number | null
    exchangeItem_id: number | null
    serial_id_old: number | null
    serial_id_new: number | null
  }

  export type ExchangeItemSerialsMaxAggregateOutputType = {
    id: number | null
    exchangeItem_id: number | null
    serial_id_old: number | null
    serial_id_new: number | null
  }

  export type ExchangeItemSerialsCountAggregateOutputType = {
    id: number
    exchangeItem_id: number
    serial_id_old: number
    serial_id_new: number
    _all: number
  }


  export type ExchangeItemSerialsAvgAggregateInputType = {
    id?: true
    exchangeItem_id?: true
    serial_id_old?: true
    serial_id_new?: true
  }

  export type ExchangeItemSerialsSumAggregateInputType = {
    id?: true
    exchangeItem_id?: true
    serial_id_old?: true
    serial_id_new?: true
  }

  export type ExchangeItemSerialsMinAggregateInputType = {
    id?: true
    exchangeItem_id?: true
    serial_id_old?: true
    serial_id_new?: true
  }

  export type ExchangeItemSerialsMaxAggregateInputType = {
    id?: true
    exchangeItem_id?: true
    serial_id_old?: true
    serial_id_new?: true
  }

  export type ExchangeItemSerialsCountAggregateInputType = {
    id?: true
    exchangeItem_id?: true
    serial_id_old?: true
    serial_id_new?: true
    _all?: true
  }

  export type ExchangeItemSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeItemSerials to aggregate.
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeItemSerials to fetch.
     */
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeItemSerials
    **/
    _count?: true | ExchangeItemSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeItemSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeItemSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeItemSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeItemSerialsMaxAggregateInputType
  }

  export type GetExchangeItemSerialsAggregateType<T extends ExchangeItemSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeItemSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeItemSerials[P]>
      : GetScalarType<T[P], AggregateExchangeItemSerials[P]>
  }




  export type ExchangeItemSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeItemSerialsWhereInput
    orderBy?: ExchangeItemSerialsOrderByWithAggregationInput | ExchangeItemSerialsOrderByWithAggregationInput[]
    by: ExchangeItemSerialsScalarFieldEnum[] | ExchangeItemSerialsScalarFieldEnum
    having?: ExchangeItemSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeItemSerialsCountAggregateInputType | true
    _avg?: ExchangeItemSerialsAvgAggregateInputType
    _sum?: ExchangeItemSerialsSumAggregateInputType
    _min?: ExchangeItemSerialsMinAggregateInputType
    _max?: ExchangeItemSerialsMaxAggregateInputType
  }

  export type ExchangeItemSerialsGroupByOutputType = {
    id: number
    exchangeItem_id: number
    serial_id_old: number
    serial_id_new: number
    _count: ExchangeItemSerialsCountAggregateOutputType | null
    _avg: ExchangeItemSerialsAvgAggregateOutputType | null
    _sum: ExchangeItemSerialsSumAggregateOutputType | null
    _min: ExchangeItemSerialsMinAggregateOutputType | null
    _max: ExchangeItemSerialsMaxAggregateOutputType | null
  }

  type GetExchangeItemSerialsGroupByPayload<T extends ExchangeItemSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeItemSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeItemSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeItemSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeItemSerialsGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeItemSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeItem_id?: boolean
    serial_id_old?: boolean
    serial_id_new?: boolean
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeItemSerials"]>

  export type ExchangeItemSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeItem_id?: boolean
    serial_id_old?: boolean
    serial_id_new?: boolean
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeItemSerials"]>

  export type ExchangeItemSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeItem_id?: boolean
    serial_id_old?: boolean
    serial_id_new?: boolean
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeItemSerials"]>

  export type ExchangeItemSerialsSelectScalar = {
    id?: boolean
    exchangeItem_id?: boolean
    serial_id_old?: boolean
    serial_id_new?: boolean
  }

  export type ExchangeItemSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exchangeItem_id" | "serial_id_old" | "serial_id_new", ExtArgs["result"]["exchangeItemSerials"]>
  export type ExchangeItemSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type ExchangeItemSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type ExchangeItemSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExchangesItems?: boolean | ExchangesItemsDefaultArgs<ExtArgs>
    OldProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
    NewProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }

  export type $ExchangeItemSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeItemSerials"
    objects: {
      ExchangesItems: Prisma.$ExchangesItemsPayload<ExtArgs>
      OldProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
      NewProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exchangeItem_id: number
      serial_id_old: number
      serial_id_new: number
    }, ExtArgs["result"]["exchangeItemSerials"]>
    composites: {}
  }

  type ExchangeItemSerialsGetPayload<S extends boolean | null | undefined | ExchangeItemSerialsDefaultArgs> = $Result.GetResult<Prisma.$ExchangeItemSerialsPayload, S>

  type ExchangeItemSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangeItemSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangeItemSerialsCountAggregateInputType | true
    }

  export interface ExchangeItemSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeItemSerials'], meta: { name: 'ExchangeItemSerials' } }
    /**
     * Find zero or one ExchangeItemSerials that matches the filter.
     * @param {ExchangeItemSerialsFindUniqueArgs} args - Arguments to find a ExchangeItemSerials
     * @example
     * // Get one ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeItemSerialsFindUniqueArgs>(args: SelectSubset<T, ExchangeItemSerialsFindUniqueArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExchangeItemSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangeItemSerialsFindUniqueOrThrowArgs} args - Arguments to find a ExchangeItemSerials
     * @example
     * // Get one ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeItemSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeItemSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsFindFirstArgs} args - Arguments to find a ExchangeItemSerials
     * @example
     * // Get one ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeItemSerialsFindFirstArgs>(args?: SelectSubset<T, ExchangeItemSerialsFindFirstArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeItemSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsFindFirstOrThrowArgs} args - Arguments to find a ExchangeItemSerials
     * @example
     * // Get one ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeItemSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeItemSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExchangeItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findMany()
     * 
     * // Get first 10 ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeItemSerialsWithIdOnly = await prisma.exchangeItemSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeItemSerialsFindManyArgs>(args?: SelectSubset<T, ExchangeItemSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExchangeItemSerials.
     * @param {ExchangeItemSerialsCreateArgs} args - Arguments to create a ExchangeItemSerials.
     * @example
     * // Create one ExchangeItemSerials
     * const ExchangeItemSerials = await prisma.exchangeItemSerials.create({
     *   data: {
     *     // ... data to create a ExchangeItemSerials
     *   }
     * })
     * 
     */
    create<T extends ExchangeItemSerialsCreateArgs>(args: SelectSubset<T, ExchangeItemSerialsCreateArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExchangeItemSerials.
     * @param {ExchangeItemSerialsCreateManyArgs} args - Arguments to create many ExchangeItemSerials.
     * @example
     * // Create many ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeItemSerialsCreateManyArgs>(args?: SelectSubset<T, ExchangeItemSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeItemSerials and returns the data saved in the database.
     * @param {ExchangeItemSerialsCreateManyAndReturnArgs} args - Arguments to create many ExchangeItemSerials.
     * @example
     * // Create many ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeItemSerials and only return the `id`
     * const exchangeItemSerialsWithIdOnly = await prisma.exchangeItemSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeItemSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeItemSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExchangeItemSerials.
     * @param {ExchangeItemSerialsDeleteArgs} args - Arguments to delete one ExchangeItemSerials.
     * @example
     * // Delete one ExchangeItemSerials
     * const ExchangeItemSerials = await prisma.exchangeItemSerials.delete({
     *   where: {
     *     // ... filter to delete one ExchangeItemSerials
     *   }
     * })
     * 
     */
    delete<T extends ExchangeItemSerialsDeleteArgs>(args: SelectSubset<T, ExchangeItemSerialsDeleteArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExchangeItemSerials.
     * @param {ExchangeItemSerialsUpdateArgs} args - Arguments to update one ExchangeItemSerials.
     * @example
     * // Update one ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeItemSerialsUpdateArgs>(args: SelectSubset<T, ExchangeItemSerialsUpdateArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExchangeItemSerials.
     * @param {ExchangeItemSerialsDeleteManyArgs} args - Arguments to filter ExchangeItemSerials to delete.
     * @example
     * // Delete a few ExchangeItemSerials
     * const { count } = await prisma.exchangeItemSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeItemSerialsDeleteManyArgs>(args?: SelectSubset<T, ExchangeItemSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeItemSerialsUpdateManyArgs>(args: SelectSubset<T, ExchangeItemSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeItemSerials and returns the data updated in the database.
     * @param {ExchangeItemSerialsUpdateManyAndReturnArgs} args - Arguments to update many ExchangeItemSerials.
     * @example
     * // Update many ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExchangeItemSerials and only return the `id`
     * const exchangeItemSerialsWithIdOnly = await prisma.exchangeItemSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangeItemSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangeItemSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExchangeItemSerials.
     * @param {ExchangeItemSerialsUpsertArgs} args - Arguments to update or create a ExchangeItemSerials.
     * @example
     * // Update or create a ExchangeItemSerials
     * const exchangeItemSerials = await prisma.exchangeItemSerials.upsert({
     *   create: {
     *     // ... data to create a ExchangeItemSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeItemSerials we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeItemSerialsUpsertArgs>(args: SelectSubset<T, ExchangeItemSerialsUpsertArgs<ExtArgs>>): Prisma__ExchangeItemSerialsClient<$Result.GetResult<Prisma.$ExchangeItemSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExchangeItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsCountArgs} args - Arguments to filter ExchangeItemSerials to count.
     * @example
     * // Count the number of ExchangeItemSerials
     * const count = await prisma.exchangeItemSerials.count({
     *   where: {
     *     // ... the filter for the ExchangeItemSerials we want to count
     *   }
     * })
    **/
    count<T extends ExchangeItemSerialsCountArgs>(
      args?: Subset<T, ExchangeItemSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeItemSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeItemSerialsAggregateArgs>(args: Subset<T, ExchangeItemSerialsAggregateArgs>): Prisma.PrismaPromise<GetExchangeItemSerialsAggregateType<T>>

    /**
     * Group by ExchangeItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeItemSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeItemSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeItemSerialsGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeItemSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeItemSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeItemSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeItemSerials model
   */
  readonly fields: ExchangeItemSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeItemSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeItemSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ExchangesItems<T extends ExchangesItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExchangesItemsDefaultArgs<ExtArgs>>): Prisma__ExchangesItemsClient<$Result.GetResult<Prisma.$ExchangesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OldProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    NewProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeItemSerials model
   */
  interface ExchangeItemSerialsFieldRefs {
    readonly id: FieldRef<"ExchangeItemSerials", 'Int'>
    readonly exchangeItem_id: FieldRef<"ExchangeItemSerials", 'Int'>
    readonly serial_id_old: FieldRef<"ExchangeItemSerials", 'Int'>
    readonly serial_id_new: FieldRef<"ExchangeItemSerials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeItemSerials findUnique
   */
  export type ExchangeItemSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeItemSerials to fetch.
     */
    where: ExchangeItemSerialsWhereUniqueInput
  }

  /**
   * ExchangeItemSerials findUniqueOrThrow
   */
  export type ExchangeItemSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeItemSerials to fetch.
     */
    where: ExchangeItemSerialsWhereUniqueInput
  }

  /**
   * ExchangeItemSerials findFirst
   */
  export type ExchangeItemSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeItemSerials to fetch.
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeItemSerials to fetch.
     */
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeItemSerials.
     */
    cursor?: ExchangeItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeItemSerials.
     */
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ExchangeItemSerials findFirstOrThrow
   */
  export type ExchangeItemSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeItemSerials to fetch.
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeItemSerials to fetch.
     */
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeItemSerials.
     */
    cursor?: ExchangeItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeItemSerials.
     */
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ExchangeItemSerials findMany
   */
  export type ExchangeItemSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeItemSerials to fetch.
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeItemSerials to fetch.
     */
    orderBy?: ExchangeItemSerialsOrderByWithRelationInput | ExchangeItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeItemSerials.
     */
    cursor?: ExchangeItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeItemSerials.
     */
    skip?: number
    distinct?: ExchangeItemSerialsScalarFieldEnum | ExchangeItemSerialsScalarFieldEnum[]
  }

  /**
   * ExchangeItemSerials create
   */
  export type ExchangeItemSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a ExchangeItemSerials.
     */
    data: XOR<ExchangeItemSerialsCreateInput, ExchangeItemSerialsUncheckedCreateInput>
  }

  /**
   * ExchangeItemSerials createMany
   */
  export type ExchangeItemSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeItemSerials.
     */
    data: ExchangeItemSerialsCreateManyInput | ExchangeItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeItemSerials createManyAndReturn
   */
  export type ExchangeItemSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many ExchangeItemSerials.
     */
    data: ExchangeItemSerialsCreateManyInput | ExchangeItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeItemSerials update
   */
  export type ExchangeItemSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a ExchangeItemSerials.
     */
    data: XOR<ExchangeItemSerialsUpdateInput, ExchangeItemSerialsUncheckedUpdateInput>
    /**
     * Choose, which ExchangeItemSerials to update.
     */
    where: ExchangeItemSerialsWhereUniqueInput
  }

  /**
   * ExchangeItemSerials updateMany
   */
  export type ExchangeItemSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeItemSerials.
     */
    data: XOR<ExchangeItemSerialsUpdateManyMutationInput, ExchangeItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeItemSerials to update
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * Limit how many ExchangeItemSerials to update.
     */
    limit?: number
  }

  /**
   * ExchangeItemSerials updateManyAndReturn
   */
  export type ExchangeItemSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to update ExchangeItemSerials.
     */
    data: XOR<ExchangeItemSerialsUpdateManyMutationInput, ExchangeItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeItemSerials to update
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * Limit how many ExchangeItemSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeItemSerials upsert
   */
  export type ExchangeItemSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the ExchangeItemSerials to update in case it exists.
     */
    where: ExchangeItemSerialsWhereUniqueInput
    /**
     * In case the ExchangeItemSerials found by the `where` argument doesn't exist, create a new ExchangeItemSerials with this data.
     */
    create: XOR<ExchangeItemSerialsCreateInput, ExchangeItemSerialsUncheckedCreateInput>
    /**
     * In case the ExchangeItemSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeItemSerialsUpdateInput, ExchangeItemSerialsUncheckedUpdateInput>
  }

  /**
   * ExchangeItemSerials delete
   */
  export type ExchangeItemSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
    /**
     * Filter which ExchangeItemSerials to delete.
     */
    where: ExchangeItemSerialsWhereUniqueInput
  }

  /**
   * ExchangeItemSerials deleteMany
   */
  export type ExchangeItemSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeItemSerials to delete
     */
    where?: ExchangeItemSerialsWhereInput
    /**
     * Limit how many ExchangeItemSerials to delete.
     */
    limit?: number
  }

  /**
   * ExchangeItemSerials without action
   */
  export type ExchangeItemSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeItemSerials
     */
    select?: ExchangeItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeItemSerials
     */
    omit?: ExchangeItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeItemSerialsInclude<ExtArgs> | null
  }


  /**
   * Model Purchases
   */

  export type AggregatePurchases = {
    _count: PurchasesCountAggregateOutputType | null
    _avg: PurchasesAvgAggregateOutputType | null
    _sum: PurchasesSumAggregateOutputType | null
    _min: PurchasesMinAggregateOutputType | null
    _max: PurchasesMaxAggregateOutputType | null
  }

  export type PurchasesAvgAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    supplier_id: number | null
    user_id: number | null
  }

  export type PurchasesSumAggregateOutputType = {
    id: number | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    supplier_id: number | null
    user_id: number | null
  }

  export type PurchasesMinAggregateOutputType = {
    id: number | null
    purchaseNo: string | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    dueDate: Date | null
    note: string | null
    supplier_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesMaxAggregateOutputType = {
    id: number | null
    purchaseNo: string | null
    totalAmount: Decimal | null
    totalPaid: Decimal | null
    dueDate: Date | null
    note: string | null
    supplier_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesCountAggregateOutputType = {
    id: number
    purchaseNo: number
    totalAmount: number
    totalPaid: number
    dueDate: number
    note: number
    supplier_id: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasesAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    totalPaid?: true
    supplier_id?: true
    user_id?: true
  }

  export type PurchasesSumAggregateInputType = {
    id?: true
    totalAmount?: true
    totalPaid?: true
    supplier_id?: true
    user_id?: true
  }

  export type PurchasesMinAggregateInputType = {
    id?: true
    purchaseNo?: true
    totalAmount?: true
    totalPaid?: true
    dueDate?: true
    note?: true
    supplier_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesMaxAggregateInputType = {
    id?: true
    purchaseNo?: true
    totalAmount?: true
    totalPaid?: true
    dueDate?: true
    note?: true
    supplier_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesCountAggregateInputType = {
    id?: true
    purchaseNo?: true
    totalAmount?: true
    totalPaid?: true
    dueDate?: true
    note?: true
    supplier_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to aggregate.
     */
    where?: PurchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesMaxAggregateInputType
  }

  export type GetPurchasesAggregateType<T extends PurchasesAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchases[P]>
      : GetScalarType<T[P], AggregatePurchases[P]>
  }




  export type PurchasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesWhereInput
    orderBy?: PurchasesOrderByWithAggregationInput | PurchasesOrderByWithAggregationInput[]
    by: PurchasesScalarFieldEnum[] | PurchasesScalarFieldEnum
    having?: PurchasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesCountAggregateInputType | true
    _avg?: PurchasesAvgAggregateInputType
    _sum?: PurchasesSumAggregateInputType
    _min?: PurchasesMinAggregateInputType
    _max?: PurchasesMaxAggregateInputType
  }

  export type PurchasesGroupByOutputType = {
    id: number
    purchaseNo: string
    totalAmount: Decimal
    totalPaid: Decimal
    dueDate: Date
    note: string | null
    supplier_id: number
    user_id: number
    createdAt: Date
    updatedAt: Date
    _count: PurchasesCountAggregateOutputType | null
    _avg: PurchasesAvgAggregateOutputType | null
    _sum: PurchasesSumAggregateOutputType | null
    _min: PurchasesMinAggregateOutputType | null
    _max: PurchasesMaxAggregateOutputType | null
  }

  type GetPurchasesGroupByPayload<T extends PurchasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    dueDate?: boolean
    note?: boolean
    supplier_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    PurchasesItems?: boolean | Purchases$PurchasesItemsArgs<ExtArgs>
    PurchasesReturn?: boolean | Purchases$PurchasesReturnArgs<ExtArgs>
    _count?: boolean | PurchasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchases"]>

  export type PurchasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    dueDate?: boolean
    note?: boolean
    supplier_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchases"]>

  export type PurchasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    dueDate?: boolean
    note?: boolean
    supplier_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchases"]>

  export type PurchasesSelectScalar = {
    id?: boolean
    purchaseNo?: boolean
    totalAmount?: boolean
    totalPaid?: boolean
    dueDate?: boolean
    note?: boolean
    supplier_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseNo" | "totalAmount" | "totalPaid" | "dueDate" | "note" | "supplier_id" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["purchases"]>
  export type PurchasesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    PurchasesItems?: boolean | Purchases$PurchasesItemsArgs<ExtArgs>
    PurchasesReturn?: boolean | Purchases$PurchasesReturnArgs<ExtArgs>
    _count?: boolean | PurchasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PurchasesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PurchasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchases"
    objects: {
      Suppliers: Prisma.$SuppliersPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      PurchasesItems: Prisma.$PurchasesItemsPayload<ExtArgs>[]
      PurchasesReturn: Prisma.$PurchasesReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseNo: string
      totalAmount: Prisma.Decimal
      totalPaid: Prisma.Decimal
      dueDate: Date
      note: string | null
      supplier_id: number
      user_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchases"]>
    composites: {}
  }

  type PurchasesGetPayload<S extends boolean | null | undefined | PurchasesDefaultArgs> = $Result.GetResult<Prisma.$PurchasesPayload, S>

  type PurchasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasesCountAggregateInputType | true
    }

  export interface PurchasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchases'], meta: { name: 'Purchases' } }
    /**
     * Find zero or one Purchases that matches the filter.
     * @param {PurchasesFindUniqueArgs} args - Arguments to find a Purchases
     * @example
     * // Get one Purchases
     * const purchases = await prisma.purchases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasesFindUniqueArgs>(args: SelectSubset<T, PurchasesFindUniqueArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasesFindUniqueOrThrowArgs} args - Arguments to find a Purchases
     * @example
     * // Get one Purchases
     * const purchases = await prisma.purchases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasesFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesFindFirstArgs} args - Arguments to find a Purchases
     * @example
     * // Get one Purchases
     * const purchases = await prisma.purchases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasesFindFirstArgs>(args?: SelectSubset<T, PurchasesFindFirstArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesFindFirstOrThrowArgs} args - Arguments to find a Purchases
     * @example
     * // Get one Purchases
     * const purchases = await prisma.purchases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasesFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchases.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesWithIdOnly = await prisma.purchases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasesFindManyArgs>(args?: SelectSubset<T, PurchasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchases.
     * @param {PurchasesCreateArgs} args - Arguments to create a Purchases.
     * @example
     * // Create one Purchases
     * const Purchases = await prisma.purchases.create({
     *   data: {
     *     // ... data to create a Purchases
     *   }
     * })
     * 
     */
    create<T extends PurchasesCreateArgs>(args: SelectSubset<T, PurchasesCreateArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchasesCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchases = await prisma.purchases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasesCreateManyArgs>(args?: SelectSubset<T, PurchasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchasesCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchases = await prisma.purchases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchasesWithIdOnly = await prisma.purchases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasesCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchases.
     * @param {PurchasesDeleteArgs} args - Arguments to delete one Purchases.
     * @example
     * // Delete one Purchases
     * const Purchases = await prisma.purchases.delete({
     *   where: {
     *     // ... filter to delete one Purchases
     *   }
     * })
     * 
     */
    delete<T extends PurchasesDeleteArgs>(args: SelectSubset<T, PurchasesDeleteArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchases.
     * @param {PurchasesUpdateArgs} args - Arguments to update one Purchases.
     * @example
     * // Update one Purchases
     * const purchases = await prisma.purchases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasesUpdateArgs>(args: SelectSubset<T, PurchasesUpdateArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchasesDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasesDeleteManyArgs>(args?: SelectSubset<T, PurchasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchases = await prisma.purchases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasesUpdateManyArgs>(args: SelectSubset<T, PurchasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchasesUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchases = await prisma.purchases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchasesWithIdOnly = await prisma.purchases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasesUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchases.
     * @param {PurchasesUpsertArgs} args - Arguments to update or create a Purchases.
     * @example
     * // Update or create a Purchases
     * const purchases = await prisma.purchases.upsert({
     *   create: {
     *     // ... data to create a Purchases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchases we want to update
     *   }
     * })
     */
    upsert<T extends PurchasesUpsertArgs>(args: SelectSubset<T, PurchasesUpsertArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchases.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchasesCountArgs>(
      args?: Subset<T, PurchasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesAggregateArgs>(args: Subset<T, PurchasesAggregateArgs>): Prisma.PrismaPromise<GetPurchasesAggregateType<T>>

    /**
     * Group by Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchases model
   */
  readonly fields: PurchasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Suppliers<T extends SuppliersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuppliersDefaultArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PurchasesItems<T extends Purchases$PurchasesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchases$PurchasesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchasesReturn<T extends Purchases$PurchasesReturnArgs<ExtArgs> = {}>(args?: Subset<T, Purchases$PurchasesReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchases model
   */
  interface PurchasesFieldRefs {
    readonly id: FieldRef<"Purchases", 'Int'>
    readonly purchaseNo: FieldRef<"Purchases", 'String'>
    readonly totalAmount: FieldRef<"Purchases", 'Decimal'>
    readonly totalPaid: FieldRef<"Purchases", 'Decimal'>
    readonly dueDate: FieldRef<"Purchases", 'DateTime'>
    readonly note: FieldRef<"Purchases", 'String'>
    readonly supplier_id: FieldRef<"Purchases", 'Int'>
    readonly user_id: FieldRef<"Purchases", 'Int'>
    readonly createdAt: FieldRef<"Purchases", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchases findUnique
   */
  export type PurchasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where: PurchasesWhereUniqueInput
  }

  /**
   * Purchases findUniqueOrThrow
   */
  export type PurchasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where: PurchasesWhereUniqueInput
  }

  /**
   * Purchases findFirst
   */
  export type PurchasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchasesScalarFieldEnum | PurchasesScalarFieldEnum[]
  }

  /**
   * Purchases findFirstOrThrow
   */
  export type PurchasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchasesScalarFieldEnum | PurchasesScalarFieldEnum[]
  }

  /**
   * Purchases findMany
   */
  export type PurchasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchasesOrderByWithRelationInput | PurchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchasesScalarFieldEnum | PurchasesScalarFieldEnum[]
  }

  /**
   * Purchases create
   */
  export type PurchasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchases.
     */
    data: XOR<PurchasesCreateInput, PurchasesUncheckedCreateInput>
  }

  /**
   * Purchases createMany
   */
  export type PurchasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchasesCreateManyInput | PurchasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchases createManyAndReturn
   */
  export type PurchasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchasesCreateManyInput | PurchasesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchases update
   */
  export type PurchasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchases.
     */
    data: XOR<PurchasesUpdateInput, PurchasesUncheckedUpdateInput>
    /**
     * Choose, which Purchases to update.
     */
    where: PurchasesWhereUniqueInput
  }

  /**
   * Purchases updateMany
   */
  export type PurchasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchasesUpdateManyMutationInput, PurchasesUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchasesWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchases updateManyAndReturn
   */
  export type PurchasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchasesUpdateManyMutationInput, PurchasesUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchasesWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchases upsert
   */
  export type PurchasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchases to update in case it exists.
     */
    where: PurchasesWhereUniqueInput
    /**
     * In case the Purchases found by the `where` argument doesn't exist, create a new Purchases with this data.
     */
    create: XOR<PurchasesCreateInput, PurchasesUncheckedCreateInput>
    /**
     * In case the Purchases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasesUpdateInput, PurchasesUncheckedUpdateInput>
  }

  /**
   * Purchases delete
   */
  export type PurchasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
    /**
     * Filter which Purchases to delete.
     */
    where: PurchasesWhereUniqueInput
  }

  /**
   * Purchases deleteMany
   */
  export type PurchasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchasesWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchases.PurchasesItems
   */
  export type Purchases$PurchasesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    where?: PurchasesItemsWhereInput
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    cursor?: PurchasesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesItemsScalarFieldEnum | PurchasesItemsScalarFieldEnum[]
  }

  /**
   * Purchases.PurchasesReturn
   */
  export type Purchases$PurchasesReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    where?: PurchasesReturnWhereInput
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    cursor?: PurchasesReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * Purchases without action
   */
  export type PurchasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchases
     */
    select?: PurchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchases
     */
    omit?: PurchasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesInclude<ExtArgs> | null
  }


  /**
   * Model PurchasesItems
   */

  export type AggregatePurchasesItems = {
    _count: PurchasesItemsCountAggregateOutputType | null
    _avg: PurchasesItemsAvgAggregateOutputType | null
    _sum: PurchasesItemsSumAggregateOutputType | null
    _min: PurchasesItemsMinAggregateOutputType | null
    _max: PurchasesItemsMaxAggregateOutputType | null
  }

  export type PurchasesItemsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    purchase_id: number | null
    product_id: number | null
  }

  export type PurchasesItemsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    purchase_id: number | null
    product_id: number | null
  }

  export type PurchasesItemsMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    purchase_id: number | null
    product_id: number | null
  }

  export type PurchasesItemsMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    purchase_id: number | null
    product_id: number | null
  }

  export type PurchasesItemsCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    purchase_id: number
    product_id: number
    _all: number
  }


  export type PurchasesItemsAvgAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    purchase_id?: true
    product_id?: true
  }

  export type PurchasesItemsSumAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    purchase_id?: true
    product_id?: true
  }

  export type PurchasesItemsMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    purchase_id?: true
    product_id?: true
  }

  export type PurchasesItemsMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    purchase_id?: true
    product_id?: true
  }

  export type PurchasesItemsCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    purchase_id?: true
    product_id?: true
    _all?: true
  }

  export type PurchasesItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesItems to aggregate.
     */
    where?: PurchasesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesItems to fetch.
     */
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasesItems
    **/
    _count?: true | PurchasesItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesItemsMaxAggregateInputType
  }

  export type GetPurchasesItemsAggregateType<T extends PurchasesItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesItems[P]>
      : GetScalarType<T[P], AggregatePurchasesItems[P]>
  }




  export type PurchasesItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesItemsWhereInput
    orderBy?: PurchasesItemsOrderByWithAggregationInput | PurchasesItemsOrderByWithAggregationInput[]
    by: PurchasesItemsScalarFieldEnum[] | PurchasesItemsScalarFieldEnum
    having?: PurchasesItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesItemsCountAggregateInputType | true
    _avg?: PurchasesItemsAvgAggregateInputType
    _sum?: PurchasesItemsSumAggregateInputType
    _min?: PurchasesItemsMinAggregateInputType
    _max?: PurchasesItemsMaxAggregateInputType
  }

  export type PurchasesItemsGroupByOutputType = {
    id: number
    quantity: number
    unitPrice: Decimal
    purchase_id: number
    product_id: number
    _count: PurchasesItemsCountAggregateOutputType | null
    _avg: PurchasesItemsAvgAggregateOutputType | null
    _sum: PurchasesItemsSumAggregateOutputType | null
    _min: PurchasesItemsMinAggregateOutputType | null
    _max: PurchasesItemsMaxAggregateOutputType | null
  }

  type GetPurchasesItemsGroupByPayload<T extends PurchasesItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesItemsGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    purchase_id?: boolean
    product_id?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    purchaseItemSerials?: boolean | PurchasesItems$purchaseItemSerialsArgs<ExtArgs>
    _count?: boolean | PurchasesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesItems"]>

  export type PurchasesItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    purchase_id?: boolean
    product_id?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesItems"]>

  export type PurchasesItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    purchase_id?: boolean
    product_id?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesItems"]>

  export type PurchasesItemsSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    purchase_id?: boolean
    product_id?: boolean
  }

  export type PurchasesItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "purchase_id" | "product_id", ExtArgs["result"]["purchasesItems"]>
  export type PurchasesItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    purchaseItemSerials?: boolean | PurchasesItems$purchaseItemSerialsArgs<ExtArgs>
    _count?: boolean | PurchasesItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasesItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }
  export type PurchasesItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
  }

  export type $PurchasesItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasesItems"
    objects: {
      Purchases: Prisma.$PurchasesPayload<ExtArgs>
      Products: Prisma.$ProductsPayload<ExtArgs>
      purchaseItemSerials: Prisma.$PurchaseItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      unitPrice: Prisma.Decimal
      purchase_id: number
      product_id: number
    }, ExtArgs["result"]["purchasesItems"]>
    composites: {}
  }

  type PurchasesItemsGetPayload<S extends boolean | null | undefined | PurchasesItemsDefaultArgs> = $Result.GetResult<Prisma.$PurchasesItemsPayload, S>

  type PurchasesItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasesItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasesItemsCountAggregateInputType | true
    }

  export interface PurchasesItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasesItems'], meta: { name: 'PurchasesItems' } }
    /**
     * Find zero or one PurchasesItems that matches the filter.
     * @param {PurchasesItemsFindUniqueArgs} args - Arguments to find a PurchasesItems
     * @example
     * // Get one PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasesItemsFindUniqueArgs>(args: SelectSubset<T, PurchasesItemsFindUniqueArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasesItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasesItemsFindUniqueOrThrowArgs} args - Arguments to find a PurchasesItems
     * @example
     * // Get one PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasesItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasesItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsFindFirstArgs} args - Arguments to find a PurchasesItems
     * @example
     * // Get one PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasesItemsFindFirstArgs>(args?: SelectSubset<T, PurchasesItemsFindFirstArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsFindFirstOrThrowArgs} args - Arguments to find a PurchasesItems
     * @example
     * // Get one PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasesItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasesItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findMany()
     * 
     * // Get first 10 PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesItemsWithIdOnly = await prisma.purchasesItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasesItemsFindManyArgs>(args?: SelectSubset<T, PurchasesItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasesItems.
     * @param {PurchasesItemsCreateArgs} args - Arguments to create a PurchasesItems.
     * @example
     * // Create one PurchasesItems
     * const PurchasesItems = await prisma.purchasesItems.create({
     *   data: {
     *     // ... data to create a PurchasesItems
     *   }
     * })
     * 
     */
    create<T extends PurchasesItemsCreateArgs>(args: SelectSubset<T, PurchasesItemsCreateArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasesItems.
     * @param {PurchasesItemsCreateManyArgs} args - Arguments to create many PurchasesItems.
     * @example
     * // Create many PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasesItemsCreateManyArgs>(args?: SelectSubset<T, PurchasesItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasesItems and returns the data saved in the database.
     * @param {PurchasesItemsCreateManyAndReturnArgs} args - Arguments to create many PurchasesItems.
     * @example
     * // Create many PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasesItems and only return the `id`
     * const purchasesItemsWithIdOnly = await prisma.purchasesItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasesItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasesItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasesItems.
     * @param {PurchasesItemsDeleteArgs} args - Arguments to delete one PurchasesItems.
     * @example
     * // Delete one PurchasesItems
     * const PurchasesItems = await prisma.purchasesItems.delete({
     *   where: {
     *     // ... filter to delete one PurchasesItems
     *   }
     * })
     * 
     */
    delete<T extends PurchasesItemsDeleteArgs>(args: SelectSubset<T, PurchasesItemsDeleteArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasesItems.
     * @param {PurchasesItemsUpdateArgs} args - Arguments to update one PurchasesItems.
     * @example
     * // Update one PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasesItemsUpdateArgs>(args: SelectSubset<T, PurchasesItemsUpdateArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasesItems.
     * @param {PurchasesItemsDeleteManyArgs} args - Arguments to filter PurchasesItems to delete.
     * @example
     * // Delete a few PurchasesItems
     * const { count } = await prisma.purchasesItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasesItemsDeleteManyArgs>(args?: SelectSubset<T, PurchasesItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasesItemsUpdateManyArgs>(args: SelectSubset<T, PurchasesItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesItems and returns the data updated in the database.
     * @param {PurchasesItemsUpdateManyAndReturnArgs} args - Arguments to update many PurchasesItems.
     * @example
     * // Update many PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasesItems and only return the `id`
     * const purchasesItemsWithIdOnly = await prisma.purchasesItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasesItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasesItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasesItems.
     * @param {PurchasesItemsUpsertArgs} args - Arguments to update or create a PurchasesItems.
     * @example
     * // Update or create a PurchasesItems
     * const purchasesItems = await prisma.purchasesItems.upsert({
     *   create: {
     *     // ... data to create a PurchasesItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasesItems we want to update
     *   }
     * })
     */
    upsert<T extends PurchasesItemsUpsertArgs>(args: SelectSubset<T, PurchasesItemsUpsertArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsCountArgs} args - Arguments to filter PurchasesItems to count.
     * @example
     * // Count the number of PurchasesItems
     * const count = await prisma.purchasesItems.count({
     *   where: {
     *     // ... the filter for the PurchasesItems we want to count
     *   }
     * })
    **/
    count<T extends PurchasesItemsCountArgs>(
      args?: Subset<T, PurchasesItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesItemsAggregateArgs>(args: Subset<T, PurchasesItemsAggregateArgs>): Prisma.PrismaPromise<GetPurchasesItemsAggregateType<T>>

    /**
     * Group by PurchasesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesItemsGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasesItems model
   */
  readonly fields: PurchasesItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasesItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasesItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Purchases<T extends PurchasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesDefaultArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Products<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseItemSerials<T extends PurchasesItems$purchaseItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesItems$purchaseItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasesItems model
   */
  interface PurchasesItemsFieldRefs {
    readonly id: FieldRef<"PurchasesItems", 'Int'>
    readonly quantity: FieldRef<"PurchasesItems", 'Int'>
    readonly unitPrice: FieldRef<"PurchasesItems", 'Decimal'>
    readonly purchase_id: FieldRef<"PurchasesItems", 'Int'>
    readonly product_id: FieldRef<"PurchasesItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PurchasesItems findUnique
   */
  export type PurchasesItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesItems to fetch.
     */
    where: PurchasesItemsWhereUniqueInput
  }

  /**
   * PurchasesItems findUniqueOrThrow
   */
  export type PurchasesItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesItems to fetch.
     */
    where: PurchasesItemsWhereUniqueInput
  }

  /**
   * PurchasesItems findFirst
   */
  export type PurchasesItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesItems to fetch.
     */
    where?: PurchasesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesItems to fetch.
     */
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesItems.
     */
    cursor?: PurchasesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesItems.
     */
    distinct?: PurchasesItemsScalarFieldEnum | PurchasesItemsScalarFieldEnum[]
  }

  /**
   * PurchasesItems findFirstOrThrow
   */
  export type PurchasesItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesItems to fetch.
     */
    where?: PurchasesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesItems to fetch.
     */
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesItems.
     */
    cursor?: PurchasesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesItems.
     */
    distinct?: PurchasesItemsScalarFieldEnum | PurchasesItemsScalarFieldEnum[]
  }

  /**
   * PurchasesItems findMany
   */
  export type PurchasesItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesItems to fetch.
     */
    where?: PurchasesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesItems to fetch.
     */
    orderBy?: PurchasesItemsOrderByWithRelationInput | PurchasesItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasesItems.
     */
    cursor?: PurchasesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesItems.
     */
    skip?: number
    distinct?: PurchasesItemsScalarFieldEnum | PurchasesItemsScalarFieldEnum[]
  }

  /**
   * PurchasesItems create
   */
  export type PurchasesItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasesItems.
     */
    data: XOR<PurchasesItemsCreateInput, PurchasesItemsUncheckedCreateInput>
  }

  /**
   * PurchasesItems createMany
   */
  export type PurchasesItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasesItems.
     */
    data: PurchasesItemsCreateManyInput | PurchasesItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasesItems createManyAndReturn
   */
  export type PurchasesItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasesItems.
     */
    data: PurchasesItemsCreateManyInput | PurchasesItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesItems update
   */
  export type PurchasesItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasesItems.
     */
    data: XOR<PurchasesItemsUpdateInput, PurchasesItemsUncheckedUpdateInput>
    /**
     * Choose, which PurchasesItems to update.
     */
    where: PurchasesItemsWhereUniqueInput
  }

  /**
   * PurchasesItems updateMany
   */
  export type PurchasesItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasesItems.
     */
    data: XOR<PurchasesItemsUpdateManyMutationInput, PurchasesItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesItems to update
     */
    where?: PurchasesItemsWhereInput
    /**
     * Limit how many PurchasesItems to update.
     */
    limit?: number
  }

  /**
   * PurchasesItems updateManyAndReturn
   */
  export type PurchasesItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * The data used to update PurchasesItems.
     */
    data: XOR<PurchasesItemsUpdateManyMutationInput, PurchasesItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesItems to update
     */
    where?: PurchasesItemsWhereInput
    /**
     * Limit how many PurchasesItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesItems upsert
   */
  export type PurchasesItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasesItems to update in case it exists.
     */
    where: PurchasesItemsWhereUniqueInput
    /**
     * In case the PurchasesItems found by the `where` argument doesn't exist, create a new PurchasesItems with this data.
     */
    create: XOR<PurchasesItemsCreateInput, PurchasesItemsUncheckedCreateInput>
    /**
     * In case the PurchasesItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasesItemsUpdateInput, PurchasesItemsUncheckedUpdateInput>
  }

  /**
   * PurchasesItems delete
   */
  export type PurchasesItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
    /**
     * Filter which PurchasesItems to delete.
     */
    where: PurchasesItemsWhereUniqueInput
  }

  /**
   * PurchasesItems deleteMany
   */
  export type PurchasesItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesItems to delete
     */
    where?: PurchasesItemsWhereInput
    /**
     * Limit how many PurchasesItems to delete.
     */
    limit?: number
  }

  /**
   * PurchasesItems.purchaseItemSerials
   */
  export type PurchasesItems$purchaseItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    where?: PurchaseItemSerialsWhereInput
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    cursor?: PurchaseItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemSerialsScalarFieldEnum | PurchaseItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchasesItems without action
   */
  export type PurchasesItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesItems
     */
    select?: PurchasesItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesItems
     */
    omit?: PurchasesItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesItemsInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItemSerials
   */

  export type AggregatePurchaseItemSerials = {
    _count: PurchaseItemSerialsCountAggregateOutputType | null
    _avg: PurchaseItemSerialsAvgAggregateOutputType | null
    _sum: PurchaseItemSerialsSumAggregateOutputType | null
    _min: PurchaseItemSerialsMinAggregateOutputType | null
    _max: PurchaseItemSerialsMaxAggregateOutputType | null
  }

  export type PurchaseItemSerialsAvgAggregateOutputType = {
    id: number | null
    purchaseItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseItemSerialsSumAggregateOutputType = {
    id: number | null
    purchaseItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseItemSerialsMinAggregateOutputType = {
    id: number | null
    purchaseItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseItemSerialsMaxAggregateOutputType = {
    id: number | null
    purchaseItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseItemSerialsCountAggregateOutputType = {
    id: number
    purchaseItem_id: number
    serial_id: number
    _all: number
  }


  export type PurchaseItemSerialsAvgAggregateInputType = {
    id?: true
    purchaseItem_id?: true
    serial_id?: true
  }

  export type PurchaseItemSerialsSumAggregateInputType = {
    id?: true
    purchaseItem_id?: true
    serial_id?: true
  }

  export type PurchaseItemSerialsMinAggregateInputType = {
    id?: true
    purchaseItem_id?: true
    serial_id?: true
  }

  export type PurchaseItemSerialsMaxAggregateInputType = {
    id?: true
    purchaseItem_id?: true
    serial_id?: true
  }

  export type PurchaseItemSerialsCountAggregateInputType = {
    id?: true
    purchaseItem_id?: true
    serial_id?: true
    _all?: true
  }

  export type PurchaseItemSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItemSerials to aggregate.
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItemSerials to fetch.
     */
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItemSerials
    **/
    _count?: true | PurchaseItemSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemSerialsMaxAggregateInputType
  }

  export type GetPurchaseItemSerialsAggregateType<T extends PurchaseItemSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItemSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItemSerials[P]>
      : GetScalarType<T[P], AggregatePurchaseItemSerials[P]>
  }




  export type PurchaseItemSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemSerialsWhereInput
    orderBy?: PurchaseItemSerialsOrderByWithAggregationInput | PurchaseItemSerialsOrderByWithAggregationInput[]
    by: PurchaseItemSerialsScalarFieldEnum[] | PurchaseItemSerialsScalarFieldEnum
    having?: PurchaseItemSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemSerialsCountAggregateInputType | true
    _avg?: PurchaseItemSerialsAvgAggregateInputType
    _sum?: PurchaseItemSerialsSumAggregateInputType
    _min?: PurchaseItemSerialsMinAggregateInputType
    _max?: PurchaseItemSerialsMaxAggregateInputType
  }

  export type PurchaseItemSerialsGroupByOutputType = {
    id: number
    purchaseItem_id: number
    serial_id: number
    _count: PurchaseItemSerialsCountAggregateOutputType | null
    _avg: PurchaseItemSerialsAvgAggregateOutputType | null
    _sum: PurchaseItemSerialsSumAggregateOutputType | null
    _min: PurchaseItemSerialsMinAggregateOutputType | null
    _max: PurchaseItemSerialsMaxAggregateOutputType | null
  }

  type GetPurchaseItemSerialsGroupByPayload<T extends PurchaseItemSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemSerialsGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseItem_id?: boolean
    serial_id?: boolean
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItemSerials"]>

  export type PurchaseItemSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseItem_id?: boolean
    serial_id?: boolean
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItemSerials"]>

  export type PurchaseItemSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseItem_id?: boolean
    serial_id?: boolean
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItemSerials"]>

  export type PurchaseItemSerialsSelectScalar = {
    id?: boolean
    purchaseItem_id?: boolean
    serial_id?: boolean
  }

  export type PurchaseItemSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseItem_id" | "serial_id", ExtArgs["result"]["purchaseItemSerials"]>
  export type PurchaseItemSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type PurchaseItemSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type PurchaseItemSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesItems?: boolean | PurchasesItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }

  export type $PurchaseItemSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItemSerials"
    objects: {
      PurchasesItems: Prisma.$PurchasesItemsPayload<ExtArgs>
      ProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseItem_id: number
      serial_id: number
    }, ExtArgs["result"]["purchaseItemSerials"]>
    composites: {}
  }

  type PurchaseItemSerialsGetPayload<S extends boolean | null | undefined | PurchaseItemSerialsDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemSerialsPayload, S>

  type PurchaseItemSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemSerialsCountAggregateInputType | true
    }

  export interface PurchaseItemSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItemSerials'], meta: { name: 'PurchaseItemSerials' } }
    /**
     * Find zero or one PurchaseItemSerials that matches the filter.
     * @param {PurchaseItemSerialsFindUniqueArgs} args - Arguments to find a PurchaseItemSerials
     * @example
     * // Get one PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemSerialsFindUniqueArgs>(args: SelectSubset<T, PurchaseItemSerialsFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItemSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemSerialsFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItemSerials
     * @example
     * // Get one PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsFindFirstArgs} args - Arguments to find a PurchaseItemSerials
     * @example
     * // Get one PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemSerialsFindFirstArgs>(args?: SelectSubset<T, PurchaseItemSerialsFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItemSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsFindFirstOrThrowArgs} args - Arguments to find a PurchaseItemSerials
     * @example
     * // Get one PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findMany()
     * 
     * // Get first 10 PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemSerialsWithIdOnly = await prisma.purchaseItemSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemSerialsFindManyArgs>(args?: SelectSubset<T, PurchaseItemSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItemSerials.
     * @param {PurchaseItemSerialsCreateArgs} args - Arguments to create a PurchaseItemSerials.
     * @example
     * // Create one PurchaseItemSerials
     * const PurchaseItemSerials = await prisma.purchaseItemSerials.create({
     *   data: {
     *     // ... data to create a PurchaseItemSerials
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemSerialsCreateArgs>(args: SelectSubset<T, PurchaseItemSerialsCreateArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItemSerials.
     * @param {PurchaseItemSerialsCreateManyArgs} args - Arguments to create many PurchaseItemSerials.
     * @example
     * // Create many PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemSerialsCreateManyArgs>(args?: SelectSubset<T, PurchaseItemSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItemSerials and returns the data saved in the database.
     * @param {PurchaseItemSerialsCreateManyAndReturnArgs} args - Arguments to create many PurchaseItemSerials.
     * @example
     * // Create many PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItemSerials and only return the `id`
     * const purchaseItemSerialsWithIdOnly = await prisma.purchaseItemSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseItemSerials.
     * @param {PurchaseItemSerialsDeleteArgs} args - Arguments to delete one PurchaseItemSerials.
     * @example
     * // Delete one PurchaseItemSerials
     * const PurchaseItemSerials = await prisma.purchaseItemSerials.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItemSerials
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemSerialsDeleteArgs>(args: SelectSubset<T, PurchaseItemSerialsDeleteArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItemSerials.
     * @param {PurchaseItemSerialsUpdateArgs} args - Arguments to update one PurchaseItemSerials.
     * @example
     * // Update one PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemSerialsUpdateArgs>(args: SelectSubset<T, PurchaseItemSerialsUpdateArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItemSerials.
     * @param {PurchaseItemSerialsDeleteManyArgs} args - Arguments to filter PurchaseItemSerials to delete.
     * @example
     * // Delete a few PurchaseItemSerials
     * const { count } = await prisma.purchaseItemSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemSerialsDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemSerialsUpdateManyArgs>(args: SelectSubset<T, PurchaseItemSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItemSerials and returns the data updated in the database.
     * @param {PurchaseItemSerialsUpdateManyAndReturnArgs} args - Arguments to update many PurchaseItemSerials.
     * @example
     * // Update many PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseItemSerials and only return the `id`
     * const purchaseItemSerialsWithIdOnly = await prisma.purchaseItemSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseItemSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseItemSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseItemSerials.
     * @param {PurchaseItemSerialsUpsertArgs} args - Arguments to update or create a PurchaseItemSerials.
     * @example
     * // Update or create a PurchaseItemSerials
     * const purchaseItemSerials = await prisma.purchaseItemSerials.upsert({
     *   create: {
     *     // ... data to create a PurchaseItemSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItemSerials we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemSerialsUpsertArgs>(args: SelectSubset<T, PurchaseItemSerialsUpsertArgs<ExtArgs>>): Prisma__PurchaseItemSerialsClient<$Result.GetResult<Prisma.$PurchaseItemSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsCountArgs} args - Arguments to filter PurchaseItemSerials to count.
     * @example
     * // Count the number of PurchaseItemSerials
     * const count = await prisma.purchaseItemSerials.count({
     *   where: {
     *     // ... the filter for the PurchaseItemSerials we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemSerialsCountArgs>(
      args?: Subset<T, PurchaseItemSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemSerialsAggregateArgs>(args: Subset<T, PurchaseItemSerialsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemSerialsAggregateType<T>>

    /**
     * Group by PurchaseItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemSerialsGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItemSerials model
   */
  readonly fields: PurchaseItemSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItemSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesItems<T extends PurchasesItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesItemsDefaultArgs<ExtArgs>>): Prisma__PurchasesItemsClient<$Result.GetResult<Prisma.$PurchasesItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItemSerials model
   */
  interface PurchaseItemSerialsFieldRefs {
    readonly id: FieldRef<"PurchaseItemSerials", 'Int'>
    readonly purchaseItem_id: FieldRef<"PurchaseItemSerials", 'Int'>
    readonly serial_id: FieldRef<"PurchaseItemSerials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItemSerials findUnique
   */
  export type PurchaseItemSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItemSerials to fetch.
     */
    where: PurchaseItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseItemSerials findUniqueOrThrow
   */
  export type PurchaseItemSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItemSerials to fetch.
     */
    where: PurchaseItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseItemSerials findFirst
   */
  export type PurchaseItemSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItemSerials to fetch.
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItemSerials to fetch.
     */
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItemSerials.
     */
    cursor?: PurchaseItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItemSerials.
     */
    distinct?: PurchaseItemSerialsScalarFieldEnum | PurchaseItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseItemSerials findFirstOrThrow
   */
  export type PurchaseItemSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItemSerials to fetch.
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItemSerials to fetch.
     */
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItemSerials.
     */
    cursor?: PurchaseItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItemSerials.
     */
    distinct?: PurchaseItemSerialsScalarFieldEnum | PurchaseItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseItemSerials findMany
   */
  export type PurchaseItemSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItemSerials to fetch.
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItemSerials to fetch.
     */
    orderBy?: PurchaseItemSerialsOrderByWithRelationInput | PurchaseItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItemSerials.
     */
    cursor?: PurchaseItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItemSerials.
     */
    skip?: number
    distinct?: PurchaseItemSerialsScalarFieldEnum | PurchaseItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseItemSerials create
   */
  export type PurchaseItemSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItemSerials.
     */
    data: XOR<PurchaseItemSerialsCreateInput, PurchaseItemSerialsUncheckedCreateInput>
  }

  /**
   * PurchaseItemSerials createMany
   */
  export type PurchaseItemSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItemSerials.
     */
    data: PurchaseItemSerialsCreateManyInput | PurchaseItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItemSerials createManyAndReturn
   */
  export type PurchaseItemSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseItemSerials.
     */
    data: PurchaseItemSerialsCreateManyInput | PurchaseItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItemSerials update
   */
  export type PurchaseItemSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItemSerials.
     */
    data: XOR<PurchaseItemSerialsUpdateInput, PurchaseItemSerialsUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItemSerials to update.
     */
    where: PurchaseItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseItemSerials updateMany
   */
  export type PurchaseItemSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItemSerials.
     */
    data: XOR<PurchaseItemSerialsUpdateManyMutationInput, PurchaseItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItemSerials to update
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * Limit how many PurchaseItemSerials to update.
     */
    limit?: number
  }

  /**
   * PurchaseItemSerials updateManyAndReturn
   */
  export type PurchaseItemSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseItemSerials.
     */
    data: XOR<PurchaseItemSerialsUpdateManyMutationInput, PurchaseItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItemSerials to update
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * Limit how many PurchaseItemSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItemSerials upsert
   */
  export type PurchaseItemSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItemSerials to update in case it exists.
     */
    where: PurchaseItemSerialsWhereUniqueInput
    /**
     * In case the PurchaseItemSerials found by the `where` argument doesn't exist, create a new PurchaseItemSerials with this data.
     */
    create: XOR<PurchaseItemSerialsCreateInput, PurchaseItemSerialsUncheckedCreateInput>
    /**
     * In case the PurchaseItemSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemSerialsUpdateInput, PurchaseItemSerialsUncheckedUpdateInput>
  }

  /**
   * PurchaseItemSerials delete
   */
  export type PurchaseItemSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItemSerials to delete.
     */
    where: PurchaseItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseItemSerials deleteMany
   */
  export type PurchaseItemSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItemSerials to delete
     */
    where?: PurchaseItemSerialsWhereInput
    /**
     * Limit how many PurchaseItemSerials to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItemSerials without action
   */
  export type PurchaseItemSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItemSerials
     */
    select?: PurchaseItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItemSerials
     */
    omit?: PurchaseItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemSerialsInclude<ExtArgs> | null
  }


  /**
   * Model PurchasesReturn
   */

  export type AggregatePurchasesReturn = {
    _count: PurchasesReturnCountAggregateOutputType | null
    _avg: PurchasesReturnAvgAggregateOutputType | null
    _sum: PurchasesReturnSumAggregateOutputType | null
    _min: PurchasesReturnMinAggregateOutputType | null
    _max: PurchasesReturnMaxAggregateOutputType | null
  }

  export type PurchasesReturnAvgAggregateOutputType = {
    id: number | null
    totalPaid: Decimal | null
    purchase_id: number | null
    user_id: number | null
    supplier_id: number | null
  }

  export type PurchasesReturnSumAggregateOutputType = {
    id: number | null
    totalPaid: Decimal | null
    purchase_id: number | null
    user_id: number | null
    supplier_id: number | null
  }

  export type PurchasesReturnMinAggregateOutputType = {
    id: number | null
    returnNo: string | null
    totalPaid: Decimal | null
    note: string | null
    purchase_id: number | null
    user_id: number | null
    supplier_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesReturnMaxAggregateOutputType = {
    id: number | null
    returnNo: string | null
    totalPaid: Decimal | null
    note: string | null
    purchase_id: number | null
    user_id: number | null
    supplier_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchasesReturnCountAggregateOutputType = {
    id: number
    returnNo: number
    totalPaid: number
    note: number
    purchase_id: number
    user_id: number
    supplier_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchasesReturnAvgAggregateInputType = {
    id?: true
    totalPaid?: true
    purchase_id?: true
    user_id?: true
    supplier_id?: true
  }

  export type PurchasesReturnSumAggregateInputType = {
    id?: true
    totalPaid?: true
    purchase_id?: true
    user_id?: true
    supplier_id?: true
  }

  export type PurchasesReturnMinAggregateInputType = {
    id?: true
    returnNo?: true
    totalPaid?: true
    note?: true
    purchase_id?: true
    user_id?: true
    supplier_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesReturnMaxAggregateInputType = {
    id?: true
    returnNo?: true
    totalPaid?: true
    note?: true
    purchase_id?: true
    user_id?: true
    supplier_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchasesReturnCountAggregateInputType = {
    id?: true
    returnNo?: true
    totalPaid?: true
    note?: true
    purchase_id?: true
    user_id?: true
    supplier_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchasesReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesReturn to aggregate.
     */
    where?: PurchasesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturns to fetch.
     */
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasesReturns
    **/
    _count?: true | PurchasesReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesReturnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesReturnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesReturnMaxAggregateInputType
  }

  export type GetPurchasesReturnAggregateType<T extends PurchasesReturnAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesReturn[P]>
      : GetScalarType<T[P], AggregatePurchasesReturn[P]>
  }




  export type PurchasesReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnWhereInput
    orderBy?: PurchasesReturnOrderByWithAggregationInput | PurchasesReturnOrderByWithAggregationInput[]
    by: PurchasesReturnScalarFieldEnum[] | PurchasesReturnScalarFieldEnum
    having?: PurchasesReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesReturnCountAggregateInputType | true
    _avg?: PurchasesReturnAvgAggregateInputType
    _sum?: PurchasesReturnSumAggregateInputType
    _min?: PurchasesReturnMinAggregateInputType
    _max?: PurchasesReturnMaxAggregateInputType
  }

  export type PurchasesReturnGroupByOutputType = {
    id: number
    returnNo: string
    totalPaid: Decimal
    note: string
    purchase_id: number
    user_id: number
    supplier_id: number
    createdAt: Date
    updatedAt: Date
    _count: PurchasesReturnCountAggregateOutputType | null
    _avg: PurchasesReturnAvgAggregateOutputType | null
    _sum: PurchasesReturnSumAggregateOutputType | null
    _min: PurchasesReturnMinAggregateOutputType | null
    _max: PurchasesReturnMaxAggregateOutputType | null
  }

  type GetPurchasesReturnGroupByPayload<T extends PurchasesReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesReturnGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesReturnGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    totalPaid?: boolean
    note?: boolean
    purchase_id?: boolean
    user_id?: boolean
    supplier_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    PurchasesReturnItems?: boolean | PurchasesReturn$PurchasesReturnItemsArgs<ExtArgs>
    _count?: boolean | PurchasesReturnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturn"]>

  export type PurchasesReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    totalPaid?: boolean
    note?: boolean
    purchase_id?: boolean
    user_id?: boolean
    supplier_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturn"]>

  export type PurchasesReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNo?: boolean
    totalPaid?: boolean
    note?: boolean
    purchase_id?: boolean
    user_id?: boolean
    supplier_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturn"]>

  export type PurchasesReturnSelectScalar = {
    id?: boolean
    returnNo?: boolean
    totalPaid?: boolean
    note?: boolean
    purchase_id?: boolean
    user_id?: boolean
    supplier_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchasesReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnNo" | "totalPaid" | "note" | "purchase_id" | "user_id" | "supplier_id" | "createdAt" | "updatedAt", ExtArgs["result"]["purchasesReturn"]>
  export type PurchasesReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
    PurchasesReturnItems?: boolean | PurchasesReturn$PurchasesReturnItemsArgs<ExtArgs>
    _count?: boolean | PurchasesReturnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasesReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
  }
  export type PurchasesReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Purchases?: boolean | PurchasesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Suppliers?: boolean | SuppliersDefaultArgs<ExtArgs>
  }

  export type $PurchasesReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasesReturn"
    objects: {
      Purchases: Prisma.$PurchasesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      Suppliers: Prisma.$SuppliersPayload<ExtArgs>
      PurchasesReturnItems: Prisma.$PurchasesReturnItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      returnNo: string
      totalPaid: Prisma.Decimal
      note: string
      purchase_id: number
      user_id: number
      supplier_id: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchasesReturn"]>
    composites: {}
  }

  type PurchasesReturnGetPayload<S extends boolean | null | undefined | PurchasesReturnDefaultArgs> = $Result.GetResult<Prisma.$PurchasesReturnPayload, S>

  type PurchasesReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasesReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasesReturnCountAggregateInputType | true
    }

  export interface PurchasesReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasesReturn'], meta: { name: 'PurchasesReturn' } }
    /**
     * Find zero or one PurchasesReturn that matches the filter.
     * @param {PurchasesReturnFindUniqueArgs} args - Arguments to find a PurchasesReturn
     * @example
     * // Get one PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasesReturnFindUniqueArgs>(args: SelectSubset<T, PurchasesReturnFindUniqueArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasesReturn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasesReturnFindUniqueOrThrowArgs} args - Arguments to find a PurchasesReturn
     * @example
     * // Get one PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasesReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasesReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnFindFirstArgs} args - Arguments to find a PurchasesReturn
     * @example
     * // Get one PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasesReturnFindFirstArgs>(args?: SelectSubset<T, PurchasesReturnFindFirstArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnFindFirstOrThrowArgs} args - Arguments to find a PurchasesReturn
     * @example
     * // Get one PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasesReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasesReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasesReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasesReturns
     * const purchasesReturns = await prisma.purchasesReturn.findMany()
     * 
     * // Get first 10 PurchasesReturns
     * const purchasesReturns = await prisma.purchasesReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesReturnWithIdOnly = await prisma.purchasesReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasesReturnFindManyArgs>(args?: SelectSubset<T, PurchasesReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasesReturn.
     * @param {PurchasesReturnCreateArgs} args - Arguments to create a PurchasesReturn.
     * @example
     * // Create one PurchasesReturn
     * const PurchasesReturn = await prisma.purchasesReturn.create({
     *   data: {
     *     // ... data to create a PurchasesReturn
     *   }
     * })
     * 
     */
    create<T extends PurchasesReturnCreateArgs>(args: SelectSubset<T, PurchasesReturnCreateArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasesReturns.
     * @param {PurchasesReturnCreateManyArgs} args - Arguments to create many PurchasesReturns.
     * @example
     * // Create many PurchasesReturns
     * const purchasesReturn = await prisma.purchasesReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasesReturnCreateManyArgs>(args?: SelectSubset<T, PurchasesReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasesReturns and returns the data saved in the database.
     * @param {PurchasesReturnCreateManyAndReturnArgs} args - Arguments to create many PurchasesReturns.
     * @example
     * // Create many PurchasesReturns
     * const purchasesReturn = await prisma.purchasesReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasesReturns and only return the `id`
     * const purchasesReturnWithIdOnly = await prisma.purchasesReturn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasesReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasesReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasesReturn.
     * @param {PurchasesReturnDeleteArgs} args - Arguments to delete one PurchasesReturn.
     * @example
     * // Delete one PurchasesReturn
     * const PurchasesReturn = await prisma.purchasesReturn.delete({
     *   where: {
     *     // ... filter to delete one PurchasesReturn
     *   }
     * })
     * 
     */
    delete<T extends PurchasesReturnDeleteArgs>(args: SelectSubset<T, PurchasesReturnDeleteArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasesReturn.
     * @param {PurchasesReturnUpdateArgs} args - Arguments to update one PurchasesReturn.
     * @example
     * // Update one PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasesReturnUpdateArgs>(args: SelectSubset<T, PurchasesReturnUpdateArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasesReturns.
     * @param {PurchasesReturnDeleteManyArgs} args - Arguments to filter PurchasesReturns to delete.
     * @example
     * // Delete a few PurchasesReturns
     * const { count } = await prisma.purchasesReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasesReturnDeleteManyArgs>(args?: SelectSubset<T, PurchasesReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasesReturns
     * const purchasesReturn = await prisma.purchasesReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasesReturnUpdateManyArgs>(args: SelectSubset<T, PurchasesReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesReturns and returns the data updated in the database.
     * @param {PurchasesReturnUpdateManyAndReturnArgs} args - Arguments to update many PurchasesReturns.
     * @example
     * // Update many PurchasesReturns
     * const purchasesReturn = await prisma.purchasesReturn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasesReturns and only return the `id`
     * const purchasesReturnWithIdOnly = await prisma.purchasesReturn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasesReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasesReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasesReturn.
     * @param {PurchasesReturnUpsertArgs} args - Arguments to update or create a PurchasesReturn.
     * @example
     * // Update or create a PurchasesReturn
     * const purchasesReturn = await prisma.purchasesReturn.upsert({
     *   create: {
     *     // ... data to create a PurchasesReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasesReturn we want to update
     *   }
     * })
     */
    upsert<T extends PurchasesReturnUpsertArgs>(args: SelectSubset<T, PurchasesReturnUpsertArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasesReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnCountArgs} args - Arguments to filter PurchasesReturns to count.
     * @example
     * // Count the number of PurchasesReturns
     * const count = await prisma.purchasesReturn.count({
     *   where: {
     *     // ... the filter for the PurchasesReturns we want to count
     *   }
     * })
    **/
    count<T extends PurchasesReturnCountArgs>(
      args?: Subset<T, PurchasesReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasesReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesReturnAggregateArgs>(args: Subset<T, PurchasesReturnAggregateArgs>): Prisma.PrismaPromise<GetPurchasesReturnAggregateType<T>>

    /**
     * Group by PurchasesReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesReturnGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasesReturn model
   */
  readonly fields: PurchasesReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasesReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasesReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Purchases<T extends PurchasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesDefaultArgs<ExtArgs>>): Prisma__PurchasesClient<$Result.GetResult<Prisma.$PurchasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Suppliers<T extends SuppliersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuppliersDefaultArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PurchasesReturnItems<T extends PurchasesReturn$PurchasesReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesReturn$PurchasesReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasesReturn model
   */
  interface PurchasesReturnFieldRefs {
    readonly id: FieldRef<"PurchasesReturn", 'Int'>
    readonly returnNo: FieldRef<"PurchasesReturn", 'String'>
    readonly totalPaid: FieldRef<"PurchasesReturn", 'Decimal'>
    readonly note: FieldRef<"PurchasesReturn", 'String'>
    readonly purchase_id: FieldRef<"PurchasesReturn", 'Int'>
    readonly user_id: FieldRef<"PurchasesReturn", 'Int'>
    readonly supplier_id: FieldRef<"PurchasesReturn", 'Int'>
    readonly createdAt: FieldRef<"PurchasesReturn", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchasesReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasesReturn findUnique
   */
  export type PurchasesReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturn to fetch.
     */
    where: PurchasesReturnWhereUniqueInput
  }

  /**
   * PurchasesReturn findUniqueOrThrow
   */
  export type PurchasesReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturn to fetch.
     */
    where: PurchasesReturnWhereUniqueInput
  }

  /**
   * PurchasesReturn findFirst
   */
  export type PurchasesReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturn to fetch.
     */
    where?: PurchasesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturns to fetch.
     */
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesReturns.
     */
    cursor?: PurchasesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesReturns.
     */
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * PurchasesReturn findFirstOrThrow
   */
  export type PurchasesReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturn to fetch.
     */
    where?: PurchasesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturns to fetch.
     */
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesReturns.
     */
    cursor?: PurchasesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesReturns.
     */
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * PurchasesReturn findMany
   */
  export type PurchasesReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturns to fetch.
     */
    where?: PurchasesReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturns to fetch.
     */
    orderBy?: PurchasesReturnOrderByWithRelationInput | PurchasesReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasesReturns.
     */
    cursor?: PurchasesReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturns.
     */
    skip?: number
    distinct?: PurchasesReturnScalarFieldEnum | PurchasesReturnScalarFieldEnum[]
  }

  /**
   * PurchasesReturn create
   */
  export type PurchasesReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasesReturn.
     */
    data: XOR<PurchasesReturnCreateInput, PurchasesReturnUncheckedCreateInput>
  }

  /**
   * PurchasesReturn createMany
   */
  export type PurchasesReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasesReturns.
     */
    data: PurchasesReturnCreateManyInput | PurchasesReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasesReturn createManyAndReturn
   */
  export type PurchasesReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasesReturns.
     */
    data: PurchasesReturnCreateManyInput | PurchasesReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesReturn update
   */
  export type PurchasesReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasesReturn.
     */
    data: XOR<PurchasesReturnUpdateInput, PurchasesReturnUncheckedUpdateInput>
    /**
     * Choose, which PurchasesReturn to update.
     */
    where: PurchasesReturnWhereUniqueInput
  }

  /**
   * PurchasesReturn updateMany
   */
  export type PurchasesReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasesReturns.
     */
    data: XOR<PurchasesReturnUpdateManyMutationInput, PurchasesReturnUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesReturns to update
     */
    where?: PurchasesReturnWhereInput
    /**
     * Limit how many PurchasesReturns to update.
     */
    limit?: number
  }

  /**
   * PurchasesReturn updateManyAndReturn
   */
  export type PurchasesReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * The data used to update PurchasesReturns.
     */
    data: XOR<PurchasesReturnUpdateManyMutationInput, PurchasesReturnUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesReturns to update
     */
    where?: PurchasesReturnWhereInput
    /**
     * Limit how many PurchasesReturns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesReturn upsert
   */
  export type PurchasesReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasesReturn to update in case it exists.
     */
    where: PurchasesReturnWhereUniqueInput
    /**
     * In case the PurchasesReturn found by the `where` argument doesn't exist, create a new PurchasesReturn with this data.
     */
    create: XOR<PurchasesReturnCreateInput, PurchasesReturnUncheckedCreateInput>
    /**
     * In case the PurchasesReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasesReturnUpdateInput, PurchasesReturnUncheckedUpdateInput>
  }

  /**
   * PurchasesReturn delete
   */
  export type PurchasesReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
    /**
     * Filter which PurchasesReturn to delete.
     */
    where: PurchasesReturnWhereUniqueInput
  }

  /**
   * PurchasesReturn deleteMany
   */
  export type PurchasesReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesReturns to delete
     */
    where?: PurchasesReturnWhereInput
    /**
     * Limit how many PurchasesReturns to delete.
     */
    limit?: number
  }

  /**
   * PurchasesReturn.PurchasesReturnItems
   */
  export type PurchasesReturn$PurchasesReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    where?: PurchasesReturnItemsWhereInput
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    cursor?: PurchasesReturnItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasesReturnItemsScalarFieldEnum | PurchasesReturnItemsScalarFieldEnum[]
  }

  /**
   * PurchasesReturn without action
   */
  export type PurchasesReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturn
     */
    select?: PurchasesReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturn
     */
    omit?: PurchasesReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnInclude<ExtArgs> | null
  }


  /**
   * Model PurchasesReturnItems
   */

  export type AggregatePurchasesReturnItems = {
    _count: PurchasesReturnItemsCountAggregateOutputType | null
    _avg: PurchasesReturnItemsAvgAggregateOutputType | null
    _sum: PurchasesReturnItemsSumAggregateOutputType | null
    _min: PurchasesReturnItemsMinAggregateOutputType | null
    _max: PurchasesReturnItemsMaxAggregateOutputType | null
  }

  export type PurchasesReturnItemsAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    products_id: number | null
    purchaseReturn_id: number | null
  }

  export type PurchasesReturnItemsSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    products_id: number | null
    purchaseReturn_id: number | null
  }

  export type PurchasesReturnItemsMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    products_id: number | null
    purchaseReturn_id: number | null
  }

  export type PurchasesReturnItemsMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    unitPrice: Decimal | null
    products_id: number | null
    purchaseReturn_id: number | null
  }

  export type PurchasesReturnItemsCountAggregateOutputType = {
    id: number
    quantity: number
    unitPrice: number
    products_id: number
    purchaseReturn_id: number
    _all: number
  }


  export type PurchasesReturnItemsAvgAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    products_id?: true
    purchaseReturn_id?: true
  }

  export type PurchasesReturnItemsSumAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    products_id?: true
    purchaseReturn_id?: true
  }

  export type PurchasesReturnItemsMinAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    products_id?: true
    purchaseReturn_id?: true
  }

  export type PurchasesReturnItemsMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    products_id?: true
    purchaseReturn_id?: true
  }

  export type PurchasesReturnItemsCountAggregateInputType = {
    id?: true
    quantity?: true
    unitPrice?: true
    products_id?: true
    purchaseReturn_id?: true
    _all?: true
  }

  export type PurchasesReturnItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesReturnItems to aggregate.
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturnItems to fetch.
     */
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasesReturnItems
    **/
    _count?: true | PurchasesReturnItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasesReturnItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasesReturnItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasesReturnItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasesReturnItemsMaxAggregateInputType
  }

  export type GetPurchasesReturnItemsAggregateType<T extends PurchasesReturnItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasesReturnItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasesReturnItems[P]>
      : GetScalarType<T[P], AggregatePurchasesReturnItems[P]>
  }




  export type PurchasesReturnItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasesReturnItemsWhereInput
    orderBy?: PurchasesReturnItemsOrderByWithAggregationInput | PurchasesReturnItemsOrderByWithAggregationInput[]
    by: PurchasesReturnItemsScalarFieldEnum[] | PurchasesReturnItemsScalarFieldEnum
    having?: PurchasesReturnItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasesReturnItemsCountAggregateInputType | true
    _avg?: PurchasesReturnItemsAvgAggregateInputType
    _sum?: PurchasesReturnItemsSumAggregateInputType
    _min?: PurchasesReturnItemsMinAggregateInputType
    _max?: PurchasesReturnItemsMaxAggregateInputType
  }

  export type PurchasesReturnItemsGroupByOutputType = {
    id: number
    quantity: number
    unitPrice: Decimal
    products_id: number
    purchaseReturn_id: number
    _count: PurchasesReturnItemsCountAggregateOutputType | null
    _avg: PurchasesReturnItemsAvgAggregateOutputType | null
    _sum: PurchasesReturnItemsSumAggregateOutputType | null
    _min: PurchasesReturnItemsMinAggregateOutputType | null
    _max: PurchasesReturnItemsMaxAggregateOutputType | null
  }

  type GetPurchasesReturnItemsGroupByPayload<T extends PurchasesReturnItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasesReturnItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasesReturnItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasesReturnItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasesReturnItemsGroupByOutputType[P]>
        }
      >
    >


  export type PurchasesReturnItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    products_id?: boolean
    purchaseReturn_id?: boolean
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
    purchaseReturnItemSerials?: boolean | PurchasesReturnItems$purchaseReturnItemSerialsArgs<ExtArgs>
    _count?: boolean | PurchasesReturnItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturnItems"]>

  export type PurchasesReturnItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    products_id?: boolean
    purchaseReturn_id?: boolean
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturnItems"]>

  export type PurchasesReturnItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    products_id?: boolean
    purchaseReturn_id?: boolean
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasesReturnItems"]>

  export type PurchasesReturnItemsSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitPrice?: boolean
    products_id?: boolean
    purchaseReturn_id?: boolean
  }

  export type PurchasesReturnItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitPrice" | "products_id" | "purchaseReturn_id", ExtArgs["result"]["purchasesReturnItems"]>
  export type PurchasesReturnItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
    purchaseReturnItemSerials?: boolean | PurchasesReturnItems$purchaseReturnItemSerialsArgs<ExtArgs>
    _count?: boolean | PurchasesReturnItemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchasesReturnItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
  }
  export type PurchasesReturnItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | ProductsDefaultArgs<ExtArgs>
    PurchasesReturn?: boolean | PurchasesReturnDefaultArgs<ExtArgs>
  }

  export type $PurchasesReturnItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasesReturnItems"
    objects: {
      Products: Prisma.$ProductsPayload<ExtArgs>
      PurchasesReturn: Prisma.$PurchasesReturnPayload<ExtArgs>
      purchaseReturnItemSerials: Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      unitPrice: Prisma.Decimal
      products_id: number
      purchaseReturn_id: number
    }, ExtArgs["result"]["purchasesReturnItems"]>
    composites: {}
  }

  type PurchasesReturnItemsGetPayload<S extends boolean | null | undefined | PurchasesReturnItemsDefaultArgs> = $Result.GetResult<Prisma.$PurchasesReturnItemsPayload, S>

  type PurchasesReturnItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchasesReturnItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchasesReturnItemsCountAggregateInputType | true
    }

  export interface PurchasesReturnItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasesReturnItems'], meta: { name: 'PurchasesReturnItems' } }
    /**
     * Find zero or one PurchasesReturnItems that matches the filter.
     * @param {PurchasesReturnItemsFindUniqueArgs} args - Arguments to find a PurchasesReturnItems
     * @example
     * // Get one PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasesReturnItemsFindUniqueArgs>(args: SelectSubset<T, PurchasesReturnItemsFindUniqueArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchasesReturnItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchasesReturnItemsFindUniqueOrThrowArgs} args - Arguments to find a PurchasesReturnItems
     * @example
     * // Get one PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasesReturnItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasesReturnItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsFindFirstArgs} args - Arguments to find a PurchasesReturnItems
     * @example
     * // Get one PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasesReturnItemsFindFirstArgs>(args?: SelectSubset<T, PurchasesReturnItemsFindFirstArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchasesReturnItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsFindFirstOrThrowArgs} args - Arguments to find a PurchasesReturnItems
     * @example
     * // Get one PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasesReturnItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasesReturnItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchasesReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findMany()
     * 
     * // Get first 10 PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasesReturnItemsWithIdOnly = await prisma.purchasesReturnItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasesReturnItemsFindManyArgs>(args?: SelectSubset<T, PurchasesReturnItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchasesReturnItems.
     * @param {PurchasesReturnItemsCreateArgs} args - Arguments to create a PurchasesReturnItems.
     * @example
     * // Create one PurchasesReturnItems
     * const PurchasesReturnItems = await prisma.purchasesReturnItems.create({
     *   data: {
     *     // ... data to create a PurchasesReturnItems
     *   }
     * })
     * 
     */
    create<T extends PurchasesReturnItemsCreateArgs>(args: SelectSubset<T, PurchasesReturnItemsCreateArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchasesReturnItems.
     * @param {PurchasesReturnItemsCreateManyArgs} args - Arguments to create many PurchasesReturnItems.
     * @example
     * // Create many PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasesReturnItemsCreateManyArgs>(args?: SelectSubset<T, PurchasesReturnItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasesReturnItems and returns the data saved in the database.
     * @param {PurchasesReturnItemsCreateManyAndReturnArgs} args - Arguments to create many PurchasesReturnItems.
     * @example
     * // Create many PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasesReturnItems and only return the `id`
     * const purchasesReturnItemsWithIdOnly = await prisma.purchasesReturnItems.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasesReturnItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasesReturnItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchasesReturnItems.
     * @param {PurchasesReturnItemsDeleteArgs} args - Arguments to delete one PurchasesReturnItems.
     * @example
     * // Delete one PurchasesReturnItems
     * const PurchasesReturnItems = await prisma.purchasesReturnItems.delete({
     *   where: {
     *     // ... filter to delete one PurchasesReturnItems
     *   }
     * })
     * 
     */
    delete<T extends PurchasesReturnItemsDeleteArgs>(args: SelectSubset<T, PurchasesReturnItemsDeleteArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchasesReturnItems.
     * @param {PurchasesReturnItemsUpdateArgs} args - Arguments to update one PurchasesReturnItems.
     * @example
     * // Update one PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasesReturnItemsUpdateArgs>(args: SelectSubset<T, PurchasesReturnItemsUpdateArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchasesReturnItems.
     * @param {PurchasesReturnItemsDeleteManyArgs} args - Arguments to filter PurchasesReturnItems to delete.
     * @example
     * // Delete a few PurchasesReturnItems
     * const { count } = await prisma.purchasesReturnItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasesReturnItemsDeleteManyArgs>(args?: SelectSubset<T, PurchasesReturnItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasesReturnItemsUpdateManyArgs>(args: SelectSubset<T, PurchasesReturnItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasesReturnItems and returns the data updated in the database.
     * @param {PurchasesReturnItemsUpdateManyAndReturnArgs} args - Arguments to update many PurchasesReturnItems.
     * @example
     * // Update many PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchasesReturnItems and only return the `id`
     * const purchasesReturnItemsWithIdOnly = await prisma.purchasesReturnItems.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchasesReturnItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchasesReturnItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchasesReturnItems.
     * @param {PurchasesReturnItemsUpsertArgs} args - Arguments to update or create a PurchasesReturnItems.
     * @example
     * // Update or create a PurchasesReturnItems
     * const purchasesReturnItems = await prisma.purchasesReturnItems.upsert({
     *   create: {
     *     // ... data to create a PurchasesReturnItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasesReturnItems we want to update
     *   }
     * })
     */
    upsert<T extends PurchasesReturnItemsUpsertArgs>(args: SelectSubset<T, PurchasesReturnItemsUpsertArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchasesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsCountArgs} args - Arguments to filter PurchasesReturnItems to count.
     * @example
     * // Count the number of PurchasesReturnItems
     * const count = await prisma.purchasesReturnItems.count({
     *   where: {
     *     // ... the filter for the PurchasesReturnItems we want to count
     *   }
     * })
    **/
    count<T extends PurchasesReturnItemsCountArgs>(
      args?: Subset<T, PurchasesReturnItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasesReturnItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasesReturnItemsAggregateArgs>(args: Subset<T, PurchasesReturnItemsAggregateArgs>): Prisma.PrismaPromise<GetPurchasesReturnItemsAggregateType<T>>

    /**
     * Group by PurchasesReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasesReturnItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasesReturnItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasesReturnItemsGroupByArgs['orderBy'] }
        : { orderBy?: PurchasesReturnItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasesReturnItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasesReturnItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasesReturnItems model
   */
  readonly fields: PurchasesReturnItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasesReturnItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasesReturnItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Products<T extends ProductsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductsDefaultArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PurchasesReturn<T extends PurchasesReturnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesReturnDefaultArgs<ExtArgs>>): Prisma__PurchasesReturnClient<$Result.GetResult<Prisma.$PurchasesReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseReturnItemSerials<T extends PurchasesReturnItems$purchaseReturnItemSerialsArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesReturnItems$purchaseReturnItemSerialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasesReturnItems model
   */
  interface PurchasesReturnItemsFieldRefs {
    readonly id: FieldRef<"PurchasesReturnItems", 'Int'>
    readonly quantity: FieldRef<"PurchasesReturnItems", 'Int'>
    readonly unitPrice: FieldRef<"PurchasesReturnItems", 'Decimal'>
    readonly products_id: FieldRef<"PurchasesReturnItems", 'Int'>
    readonly purchaseReturn_id: FieldRef<"PurchasesReturnItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PurchasesReturnItems findUnique
   */
  export type PurchasesReturnItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturnItems to fetch.
     */
    where: PurchasesReturnItemsWhereUniqueInput
  }

  /**
   * PurchasesReturnItems findUniqueOrThrow
   */
  export type PurchasesReturnItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturnItems to fetch.
     */
    where: PurchasesReturnItemsWhereUniqueInput
  }

  /**
   * PurchasesReturnItems findFirst
   */
  export type PurchasesReturnItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturnItems to fetch.
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturnItems to fetch.
     */
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesReturnItems.
     */
    cursor?: PurchasesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesReturnItems.
     */
    distinct?: PurchasesReturnItemsScalarFieldEnum | PurchasesReturnItemsScalarFieldEnum[]
  }

  /**
   * PurchasesReturnItems findFirstOrThrow
   */
  export type PurchasesReturnItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturnItems to fetch.
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturnItems to fetch.
     */
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasesReturnItems.
     */
    cursor?: PurchasesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasesReturnItems.
     */
    distinct?: PurchasesReturnItemsScalarFieldEnum | PurchasesReturnItemsScalarFieldEnum[]
  }

  /**
   * PurchasesReturnItems findMany
   */
  export type PurchasesReturnItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter, which PurchasesReturnItems to fetch.
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasesReturnItems to fetch.
     */
    orderBy?: PurchasesReturnItemsOrderByWithRelationInput | PurchasesReturnItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasesReturnItems.
     */
    cursor?: PurchasesReturnItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasesReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasesReturnItems.
     */
    skip?: number
    distinct?: PurchasesReturnItemsScalarFieldEnum | PurchasesReturnItemsScalarFieldEnum[]
  }

  /**
   * PurchasesReturnItems create
   */
  export type PurchasesReturnItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasesReturnItems.
     */
    data: XOR<PurchasesReturnItemsCreateInput, PurchasesReturnItemsUncheckedCreateInput>
  }

  /**
   * PurchasesReturnItems createMany
   */
  export type PurchasesReturnItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasesReturnItems.
     */
    data: PurchasesReturnItemsCreateManyInput | PurchasesReturnItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasesReturnItems createManyAndReturn
   */
  export type PurchasesReturnItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * The data used to create many PurchasesReturnItems.
     */
    data: PurchasesReturnItemsCreateManyInput | PurchasesReturnItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesReturnItems update
   */
  export type PurchasesReturnItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasesReturnItems.
     */
    data: XOR<PurchasesReturnItemsUpdateInput, PurchasesReturnItemsUncheckedUpdateInput>
    /**
     * Choose, which PurchasesReturnItems to update.
     */
    where: PurchasesReturnItemsWhereUniqueInput
  }

  /**
   * PurchasesReturnItems updateMany
   */
  export type PurchasesReturnItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasesReturnItems.
     */
    data: XOR<PurchasesReturnItemsUpdateManyMutationInput, PurchasesReturnItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesReturnItems to update
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * Limit how many PurchasesReturnItems to update.
     */
    limit?: number
  }

  /**
   * PurchasesReturnItems updateManyAndReturn
   */
  export type PurchasesReturnItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * The data used to update PurchasesReturnItems.
     */
    data: XOR<PurchasesReturnItemsUpdateManyMutationInput, PurchasesReturnItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchasesReturnItems to update
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * Limit how many PurchasesReturnItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasesReturnItems upsert
   */
  export type PurchasesReturnItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasesReturnItems to update in case it exists.
     */
    where: PurchasesReturnItemsWhereUniqueInput
    /**
     * In case the PurchasesReturnItems found by the `where` argument doesn't exist, create a new PurchasesReturnItems with this data.
     */
    create: XOR<PurchasesReturnItemsCreateInput, PurchasesReturnItemsUncheckedCreateInput>
    /**
     * In case the PurchasesReturnItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasesReturnItemsUpdateInput, PurchasesReturnItemsUncheckedUpdateInput>
  }

  /**
   * PurchasesReturnItems delete
   */
  export type PurchasesReturnItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
    /**
     * Filter which PurchasesReturnItems to delete.
     */
    where: PurchasesReturnItemsWhereUniqueInput
  }

  /**
   * PurchasesReturnItems deleteMany
   */
  export type PurchasesReturnItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasesReturnItems to delete
     */
    where?: PurchasesReturnItemsWhereInput
    /**
     * Limit how many PurchasesReturnItems to delete.
     */
    limit?: number
  }

  /**
   * PurchasesReturnItems.purchaseReturnItemSerials
   */
  export type PurchasesReturnItems$purchaseReturnItemSerialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    where?: PurchaseReturnItemSerialsWhereInput
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemSerialsScalarFieldEnum | PurchaseReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchasesReturnItems without action
   */
  export type PurchasesReturnItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasesReturnItems
     */
    select?: PurchasesReturnItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchasesReturnItems
     */
    omit?: PurchasesReturnItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasesReturnItemsInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReturnItemSerials
   */

  export type AggregatePurchaseReturnItemSerials = {
    _count: PurchaseReturnItemSerialsCountAggregateOutputType | null
    _avg: PurchaseReturnItemSerialsAvgAggregateOutputType | null
    _sum: PurchaseReturnItemSerialsSumAggregateOutputType | null
    _min: PurchaseReturnItemSerialsMinAggregateOutputType | null
    _max: PurchaseReturnItemSerialsMaxAggregateOutputType | null
  }

  export type PurchaseReturnItemSerialsAvgAggregateOutputType = {
    id: number | null
    purchaseReturnItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseReturnItemSerialsSumAggregateOutputType = {
    id: number | null
    purchaseReturnItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseReturnItemSerialsMinAggregateOutputType = {
    id: number | null
    purchaseReturnItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseReturnItemSerialsMaxAggregateOutputType = {
    id: number | null
    purchaseReturnItem_id: number | null
    serial_id: number | null
  }

  export type PurchaseReturnItemSerialsCountAggregateOutputType = {
    id: number
    purchaseReturnItem_id: number
    serial_id: number
    _all: number
  }


  export type PurchaseReturnItemSerialsAvgAggregateInputType = {
    id?: true
    purchaseReturnItem_id?: true
    serial_id?: true
  }

  export type PurchaseReturnItemSerialsSumAggregateInputType = {
    id?: true
    purchaseReturnItem_id?: true
    serial_id?: true
  }

  export type PurchaseReturnItemSerialsMinAggregateInputType = {
    id?: true
    purchaseReturnItem_id?: true
    serial_id?: true
  }

  export type PurchaseReturnItemSerialsMaxAggregateInputType = {
    id?: true
    purchaseReturnItem_id?: true
    serial_id?: true
  }

  export type PurchaseReturnItemSerialsCountAggregateInputType = {
    id?: true
    purchaseReturnItem_id?: true
    serial_id?: true
    _all?: true
  }

  export type PurchaseReturnItemSerialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnItemSerials to aggregate.
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItemSerials to fetch.
     */
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReturnItemSerials
    **/
    _count?: true | PurchaseReturnItemSerialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReturnItemSerialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReturnItemSerialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReturnItemSerialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReturnItemSerialsMaxAggregateInputType
  }

  export type GetPurchaseReturnItemSerialsAggregateType<T extends PurchaseReturnItemSerialsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReturnItemSerials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReturnItemSerials[P]>
      : GetScalarType<T[P], AggregatePurchaseReturnItemSerials[P]>
  }




  export type PurchaseReturnItemSerialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemSerialsWhereInput
    orderBy?: PurchaseReturnItemSerialsOrderByWithAggregationInput | PurchaseReturnItemSerialsOrderByWithAggregationInput[]
    by: PurchaseReturnItemSerialsScalarFieldEnum[] | PurchaseReturnItemSerialsScalarFieldEnum
    having?: PurchaseReturnItemSerialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReturnItemSerialsCountAggregateInputType | true
    _avg?: PurchaseReturnItemSerialsAvgAggregateInputType
    _sum?: PurchaseReturnItemSerialsSumAggregateInputType
    _min?: PurchaseReturnItemSerialsMinAggregateInputType
    _max?: PurchaseReturnItemSerialsMaxAggregateInputType
  }

  export type PurchaseReturnItemSerialsGroupByOutputType = {
    id: number
    purchaseReturnItem_id: number
    serial_id: number
    _count: PurchaseReturnItemSerialsCountAggregateOutputType | null
    _avg: PurchaseReturnItemSerialsAvgAggregateOutputType | null
    _sum: PurchaseReturnItemSerialsSumAggregateOutputType | null
    _min: PurchaseReturnItemSerialsMinAggregateOutputType | null
    _max: PurchaseReturnItemSerialsMaxAggregateOutputType | null
  }

  type GetPurchaseReturnItemSerialsGroupByPayload<T extends PurchaseReturnItemSerialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReturnItemSerialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReturnItemSerialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReturnItemSerialsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReturnItemSerialsGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReturnItemSerialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseReturnItem_id?: boolean
    serial_id?: boolean
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItemSerials"]>

  export type PurchaseReturnItemSerialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseReturnItem_id?: boolean
    serial_id?: boolean
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItemSerials"]>

  export type PurchaseReturnItemSerialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseReturnItem_id?: boolean
    serial_id?: boolean
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItemSerials"]>

  export type PurchaseReturnItemSerialsSelectScalar = {
    id?: boolean
    purchaseReturnItem_id?: boolean
    serial_id?: boolean
  }

  export type PurchaseReturnItemSerialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseReturnItem_id" | "serial_id", ExtArgs["result"]["purchaseReturnItemSerials"]>
  export type PurchaseReturnItemSerialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnItemSerialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnItemSerialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchasesReturnItems?: boolean | PurchasesReturnItemsDefaultArgs<ExtArgs>
    ProductSerials?: boolean | ProductSerialsDefaultArgs<ExtArgs>
  }

  export type $PurchaseReturnItemSerialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReturnItemSerials"
    objects: {
      PurchasesReturnItems: Prisma.$PurchasesReturnItemsPayload<ExtArgs>
      ProductSerials: Prisma.$ProductSerialsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      purchaseReturnItem_id: number
      serial_id: number
    }, ExtArgs["result"]["purchaseReturnItemSerials"]>
    composites: {}
  }

  type PurchaseReturnItemSerialsGetPayload<S extends boolean | null | undefined | PurchaseReturnItemSerialsDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload, S>

  type PurchaseReturnItemSerialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReturnItemSerialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReturnItemSerialsCountAggregateInputType | true
    }

  export interface PurchaseReturnItemSerialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReturnItemSerials'], meta: { name: 'PurchaseReturnItemSerials' } }
    /**
     * Find zero or one PurchaseReturnItemSerials that matches the filter.
     * @param {PurchaseReturnItemSerialsFindUniqueArgs} args - Arguments to find a PurchaseReturnItemSerials
     * @example
     * // Get one PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReturnItemSerialsFindUniqueArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReturnItemSerials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReturnItemSerialsFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReturnItemSerials
     * @example
     * // Get one PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReturnItemSerialsFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsFindFirstArgs} args - Arguments to find a PurchaseReturnItemSerials
     * @example
     * // Get one PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReturnItemSerialsFindFirstArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsFindFirstArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnItemSerials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsFindFirstOrThrowArgs} args - Arguments to find a PurchaseReturnItemSerials
     * @example
     * // Get one PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReturnItemSerialsFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReturnItemSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findMany()
     * 
     * // Get first 10 PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReturnItemSerialsWithIdOnly = await prisma.purchaseReturnItemSerials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReturnItemSerialsFindManyArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsCreateArgs} args - Arguments to create a PurchaseReturnItemSerials.
     * @example
     * // Create one PurchaseReturnItemSerials
     * const PurchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.create({
     *   data: {
     *     // ... data to create a PurchaseReturnItemSerials
     *   }
     * })
     * 
     */
    create<T extends PurchaseReturnItemSerialsCreateArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsCreateArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsCreateManyArgs} args - Arguments to create many PurchaseReturnItemSerials.
     * @example
     * // Create many PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReturnItemSerialsCreateManyArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReturnItemSerials and returns the data saved in the database.
     * @param {PurchaseReturnItemSerialsCreateManyAndReturnArgs} args - Arguments to create many PurchaseReturnItemSerials.
     * @example
     * // Create many PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReturnItemSerials and only return the `id`
     * const purchaseReturnItemSerialsWithIdOnly = await prisma.purchaseReturnItemSerials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReturnItemSerialsCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsDeleteArgs} args - Arguments to delete one PurchaseReturnItemSerials.
     * @example
     * // Delete one PurchaseReturnItemSerials
     * const PurchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReturnItemSerials
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReturnItemSerialsDeleteArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsDeleteArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsUpdateArgs} args - Arguments to update one PurchaseReturnItemSerials.
     * @example
     * // Update one PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReturnItemSerialsUpdateArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsUpdateArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsDeleteManyArgs} args - Arguments to filter PurchaseReturnItemSerials to delete.
     * @example
     * // Delete a few PurchaseReturnItemSerials
     * const { count } = await prisma.purchaseReturnItemSerials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReturnItemSerialsDeleteManyArgs>(args?: SelectSubset<T, PurchaseReturnItemSerialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReturnItemSerialsUpdateManyArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnItemSerials and returns the data updated in the database.
     * @param {PurchaseReturnItemSerialsUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReturnItemSerials.
     * @example
     * // Update many PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReturnItemSerials and only return the `id`
     * const purchaseReturnItemSerialsWithIdOnly = await prisma.purchaseReturnItemSerials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReturnItemSerialsUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReturnItemSerials.
     * @param {PurchaseReturnItemSerialsUpsertArgs} args - Arguments to update or create a PurchaseReturnItemSerials.
     * @example
     * // Update or create a PurchaseReturnItemSerials
     * const purchaseReturnItemSerials = await prisma.purchaseReturnItemSerials.upsert({
     *   create: {
     *     // ... data to create a PurchaseReturnItemSerials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReturnItemSerials we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReturnItemSerialsUpsertArgs>(args: SelectSubset<T, PurchaseReturnItemSerialsUpsertArgs<ExtArgs>>): Prisma__PurchaseReturnItemSerialsClient<$Result.GetResult<Prisma.$PurchaseReturnItemSerialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsCountArgs} args - Arguments to filter PurchaseReturnItemSerials to count.
     * @example
     * // Count the number of PurchaseReturnItemSerials
     * const count = await prisma.purchaseReturnItemSerials.count({
     *   where: {
     *     // ... the filter for the PurchaseReturnItemSerials we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReturnItemSerialsCountArgs>(
      args?: Subset<T, PurchaseReturnItemSerialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReturnItemSerialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReturnItemSerialsAggregateArgs>(args: Subset<T, PurchaseReturnItemSerialsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReturnItemSerialsAggregateType<T>>

    /**
     * Group by PurchaseReturnItemSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemSerialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReturnItemSerialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReturnItemSerialsGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReturnItemSerialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReturnItemSerialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReturnItemSerialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReturnItemSerials model
   */
  readonly fields: PurchaseReturnItemSerialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReturnItemSerials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReturnItemSerialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PurchasesReturnItems<T extends PurchasesReturnItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchasesReturnItemsDefaultArgs<ExtArgs>>): Prisma__PurchasesReturnItemsClient<$Result.GetResult<Prisma.$PurchasesReturnItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSerials<T extends ProductSerialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductSerialsDefaultArgs<ExtArgs>>): Prisma__ProductSerialsClient<$Result.GetResult<Prisma.$ProductSerialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReturnItemSerials model
   */
  interface PurchaseReturnItemSerialsFieldRefs {
    readonly id: FieldRef<"PurchaseReturnItemSerials", 'Int'>
    readonly purchaseReturnItem_id: FieldRef<"PurchaseReturnItemSerials", 'Int'>
    readonly serial_id: FieldRef<"PurchaseReturnItemSerials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReturnItemSerials findUnique
   */
  export type PurchaseReturnItemSerialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItemSerials to fetch.
     */
    where: PurchaseReturnItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseReturnItemSerials findUniqueOrThrow
   */
  export type PurchaseReturnItemSerialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItemSerials to fetch.
     */
    where: PurchaseReturnItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseReturnItemSerials findFirst
   */
  export type PurchaseReturnItemSerialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItemSerials to fetch.
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItemSerials to fetch.
     */
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnItemSerials.
     */
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnItemSerials.
     */
    distinct?: PurchaseReturnItemSerialsScalarFieldEnum | PurchaseReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItemSerials findFirstOrThrow
   */
  export type PurchaseReturnItemSerialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItemSerials to fetch.
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItemSerials to fetch.
     */
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnItemSerials.
     */
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItemSerials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnItemSerials.
     */
    distinct?: PurchaseReturnItemSerialsScalarFieldEnum | PurchaseReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItemSerials findMany
   */
  export type PurchaseReturnItemSerialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItemSerials to fetch.
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItemSerials to fetch.
     */
    orderBy?: PurchaseReturnItemSerialsOrderByWithRelationInput | PurchaseReturnItemSerialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReturnItemSerials.
     */
    cursor?: PurchaseReturnItemSerialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItemSerials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItemSerials.
     */
    skip?: number
    distinct?: PurchaseReturnItemSerialsScalarFieldEnum | PurchaseReturnItemSerialsScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItemSerials create
   */
  export type PurchaseReturnItemSerialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReturnItemSerials.
     */
    data: XOR<PurchaseReturnItemSerialsCreateInput, PurchaseReturnItemSerialsUncheckedCreateInput>
  }

  /**
   * PurchaseReturnItemSerials createMany
   */
  export type PurchaseReturnItemSerialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReturnItemSerials.
     */
    data: PurchaseReturnItemSerialsCreateManyInput | PurchaseReturnItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseReturnItemSerials createManyAndReturn
   */
  export type PurchaseReturnItemSerialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReturnItemSerials.
     */
    data: PurchaseReturnItemSerialsCreateManyInput | PurchaseReturnItemSerialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnItemSerials update
   */
  export type PurchaseReturnItemSerialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReturnItemSerials.
     */
    data: XOR<PurchaseReturnItemSerialsUpdateInput, PurchaseReturnItemSerialsUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReturnItemSerials to update.
     */
    where: PurchaseReturnItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseReturnItemSerials updateMany
   */
  export type PurchaseReturnItemSerialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReturnItemSerials.
     */
    data: XOR<PurchaseReturnItemSerialsUpdateManyMutationInput, PurchaseReturnItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnItemSerials to update
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * Limit how many PurchaseReturnItemSerials to update.
     */
    limit?: number
  }

  /**
   * PurchaseReturnItemSerials updateManyAndReturn
   */
  export type PurchaseReturnItemSerialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReturnItemSerials.
     */
    data: XOR<PurchaseReturnItemSerialsUpdateManyMutationInput, PurchaseReturnItemSerialsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnItemSerials to update
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * Limit how many PurchaseReturnItemSerials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnItemSerials upsert
   */
  export type PurchaseReturnItemSerialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReturnItemSerials to update in case it exists.
     */
    where: PurchaseReturnItemSerialsWhereUniqueInput
    /**
     * In case the PurchaseReturnItemSerials found by the `where` argument doesn't exist, create a new PurchaseReturnItemSerials with this data.
     */
    create: XOR<PurchaseReturnItemSerialsCreateInput, PurchaseReturnItemSerialsUncheckedCreateInput>
    /**
     * In case the PurchaseReturnItemSerials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReturnItemSerialsUpdateInput, PurchaseReturnItemSerialsUncheckedUpdateInput>
  }

  /**
   * PurchaseReturnItemSerials delete
   */
  export type PurchaseReturnItemSerialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReturnItemSerials to delete.
     */
    where: PurchaseReturnItemSerialsWhereUniqueInput
  }

  /**
   * PurchaseReturnItemSerials deleteMany
   */
  export type PurchaseReturnItemSerialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnItemSerials to delete
     */
    where?: PurchaseReturnItemSerialsWhereInput
    /**
     * Limit how many PurchaseReturnItemSerials to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReturnItemSerials without action
   */
  export type PurchaseReturnItemSerialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItemSerials
     */
    select?: PurchaseReturnItemSerialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItemSerials
     */
    omit?: PurchaseReturnItemSerialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemSerialsInclude<ExtArgs> | null
  }


  /**
   * Model Services
   */

  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    id: number | null
    serviceCost: Decimal | null
    customer_id: number | null
    user_id: number | null
  }

  export type ServicesSumAggregateOutputType = {
    id: number | null
    serviceCost: Decimal | null
    customer_id: number | null
    user_id: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: number | null
    serviceNo: string | null
    serviceProductName: string | null
    serviceDescription: string | null
    serviceCost: Decimal | null
    serviceStatus: string | null
    customer_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: number | null
    serviceNo: string | null
    serviceProductName: string | null
    serviceDescription: string | null
    serviceCost: Decimal | null
    serviceStatus: string | null
    customer_id: number | null
    user_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    serviceNo: number
    serviceProductName: number
    serviceDescription: number
    serviceCost: number
    serviceStatus: number
    customer_id: number
    user_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    id?: true
    serviceCost?: true
    customer_id?: true
    user_id?: true
  }

  export type ServicesSumAggregateInputType = {
    id?: true
    serviceCost?: true
    customer_id?: true
    user_id?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    serviceNo?: true
    serviceProductName?: true
    serviceDescription?: true
    serviceCost?: true
    serviceStatus?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    serviceNo?: true
    serviceProductName?: true
    serviceDescription?: true
    serviceCost?: true
    serviceStatus?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    serviceNo?: true
    serviceProductName?: true
    serviceDescription?: true
    serviceCost?: true
    serviceStatus?: true
    customer_id?: true
    user_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to aggregate.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhereInput
    orderBy?: ServicesOrderByWithAggregationInput | ServicesOrderByWithAggregationInput[]
    by: ServicesScalarFieldEnum[] | ServicesScalarFieldEnum
    having?: ServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }

  export type ServicesGroupByOutputType = {
    id: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal
    serviceStatus: string
    customer_id: number | null
    user_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type ServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNo?: boolean
    serviceProductName?: boolean
    serviceDescription?: boolean
    serviceCost?: boolean
    serviceStatus?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNo?: boolean
    serviceProductName?: boolean
    serviceDescription?: boolean
    serviceCost?: boolean
    serviceStatus?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceNo?: boolean
    serviceProductName?: boolean
    serviceDescription?: boolean
    serviceCost?: boolean
    serviceStatus?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type ServicesSelectScalar = {
    id?: boolean
    serviceNo?: boolean
    serviceProductName?: boolean
    serviceDescription?: boolean
    serviceCost?: boolean
    serviceStatus?: boolean
    customer_id?: boolean
    user_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceNo" | "serviceProductName" | "serviceDescription" | "serviceCost" | "serviceStatus" | "customer_id" | "user_id" | "createdAt" | "updatedAt", ExtArgs["result"]["services"]>
  export type ServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }
  export type ServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }
  export type ServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Services$CustomersArgs<ExtArgs>
    Users?: boolean | Services$UsersArgs<ExtArgs>
  }

  export type $ServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Services"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceNo: string
      serviceProductName: string
      serviceDescription: string
      serviceCost: Prisma.Decimal
      serviceStatus: string
      customer_id: number | null
      user_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["services"]>
    composites: {}
  }

  type ServicesGetPayload<S extends boolean | null | undefined | ServicesDefaultArgs> = $Result.GetResult<Prisma.$ServicesPayload, S>

  type ServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface ServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Services'], meta: { name: 'Services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {ServicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesFindUniqueArgs>(args: SelectSubset<T, ServicesFindUniqueArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Services that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesFindFirstArgs>(args?: SelectSubset<T, ServicesFindFirstArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesFindManyArgs>(args?: SelectSubset<T, ServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Services.
     * @param {ServicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
     */
    create<T extends ServicesCreateArgs>(args: SelectSubset<T, ServicesCreateArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServicesCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesCreateManyArgs>(args?: SelectSubset<T, ServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServicesCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Services.
     * @param {ServicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
     */
    delete<T extends ServicesDeleteArgs>(args: SelectSubset<T, ServicesDeleteArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Services.
     * @param {ServicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesUpdateArgs>(args: SelectSubset<T, ServicesUpdateArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesDeleteManyArgs>(args?: SelectSubset<T, ServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesUpdateManyArgs>(args: SelectSubset<T, ServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServicesUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Services.
     * @param {ServicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
     */
    upsert<T extends ServicesUpsertArgs>(args: SelectSubset<T, ServicesUpsertArgs<ExtArgs>>): Prisma__ServicesClient<$Result.GetResult<Prisma.$ServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServicesCountArgs>(
      args?: Subset<T, ServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Services model
   */
  readonly fields: ServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends Services$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Services$CustomersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends Services$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Services$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Services model
   */
  interface ServicesFieldRefs {
    readonly id: FieldRef<"Services", 'Int'>
    readonly serviceNo: FieldRef<"Services", 'String'>
    readonly serviceProductName: FieldRef<"Services", 'String'>
    readonly serviceDescription: FieldRef<"Services", 'String'>
    readonly serviceCost: FieldRef<"Services", 'Decimal'>
    readonly serviceStatus: FieldRef<"Services", 'String'>
    readonly customer_id: FieldRef<"Services", 'Int'>
    readonly user_id: FieldRef<"Services", 'Int'>
    readonly createdAt: FieldRef<"Services", 'DateTime'>
    readonly updatedAt: FieldRef<"Services", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Services findUnique
   */
  export type ServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services findUniqueOrThrow
   */
  export type ServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services findFirst
   */
  export type ServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services findFirstOrThrow
   */
  export type ServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services findMany
   */
  export type ServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServicesOrderByWithRelationInput | ServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * Services create
   */
  export type ServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a Services.
     */
    data: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
  }

  /**
   * Services createMany
   */
  export type ServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServicesCreateManyInput | ServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Services createManyAndReturn
   */
  export type ServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServicesCreateManyInput | ServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Services update
   */
  export type ServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a Services.
     */
    data: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
    /**
     * Choose, which Services to update.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services updateMany
   */
  export type ServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Services updateManyAndReturn
   */
  export type ServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Services upsert
   */
  export type ServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the Services to update in case it exists.
     */
    where: ServicesWhereUniqueInput
    /**
     * In case the Services found by the `where` argument doesn't exist, create a new Services with this data.
     */
    create: XOR<ServicesCreateInput, ServicesUncheckedCreateInput>
    /**
     * In case the Services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesUpdateInput, ServicesUncheckedUpdateInput>
  }

  /**
   * Services delete
   */
  export type ServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
    /**
     * Filter which Services to delete.
     */
    where: ServicesWhereUniqueInput
  }

  /**
   * Services deleteMany
   */
  export type ServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServicesWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Services.Customers
   */
  export type Services$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customers
     */
    omit?: CustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }

  /**
   * Services.Users
   */
  export type Services$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Services without action
   */
  export type ServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Services
     */
    select?: ServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Services
     */
    omit?: ServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const RolePermissionsScalarFieldEnum: {
    id: 'id',
    role_id: 'role_id',
    permission_id: 'permission_id',
    can_view: 'can_view',
    can_create: 'can_create',
    can_edit: 'can_edit',
    can_delete: 'can_delete'
  };

  export type RolePermissionsScalarFieldEnum = (typeof RolePermissionsScalarFieldEnum)[keyof typeof RolePermissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    email: 'email',
    password: 'password',
    status: 'status',
    role_id: 'role_id',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    permissionOverrides: 'permissionOverrides'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    custId: 'custId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const SuppliersScalarFieldEnum: {
    id: 'id',
    suppId: 'suppId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address'
  };

  export type SuppliersScalarFieldEnum = (typeof SuppliersScalarFieldEnum)[keyof typeof SuppliersScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    productCode: 'productCode',
    name: 'name',
    specification: 'specification',
    description: 'description',
    quantity: 'quantity',
    purchasePrice: 'purchasePrice',
    wholesalePrice: 'wholesalePrice',
    retailPrice: 'retailPrice',
    useIndividualSerials: 'useIndividualSerials',
    productType: 'productType',
    status: 'status',
    category_id: 'category_id',
    supplier_id: 'supplier_id',
    created_by: 'created_by',
    updated_by: 'updated_by',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const ProductSerialsScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    product_id: 'product_id',
    status: 'status',
    warranty: 'warranty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductSerialsScalarFieldEnum = (typeof ProductSerialsScalarFieldEnum)[keyof typeof ProductSerialsScalarFieldEnum]


  export const ExpensesScalarFieldEnum: {
    id: 'id',
    expenseNo: 'expenseNo',
    title: 'title',
    amount: 'amount',
    date: 'date',
    description: 'description',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpensesScalarFieldEnum = (typeof ExpensesScalarFieldEnum)[keyof typeof ExpensesScalarFieldEnum]


  export const SalesScalarFieldEnum: {
    id: 'id',
    saleNo: 'saleNo',
    totalAmount: 'totalAmount',
    totalPaid: 'totalPaid',
    totaldiscount: 'totaldiscount',
    dueDate: 'dueDate',
    status: 'status',
    customer_id: 'customer_id',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesScalarFieldEnum = (typeof SalesScalarFieldEnum)[keyof typeof SalesScalarFieldEnum]


  export const SalesItemsScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount',
    sales_id: 'sales_id',
    product_id: 'product_id'
  };

  export type SalesItemsScalarFieldEnum = (typeof SalesItemsScalarFieldEnum)[keyof typeof SalesItemsScalarFieldEnum]


  export const SalesItemSerialsScalarFieldEnum: {
    id: 'id',
    salesItem_id: 'salesItem_id',
    serial_id: 'serial_id'
  };

  export type SalesItemSerialsScalarFieldEnum = (typeof SalesItemSerialsScalarFieldEnum)[keyof typeof SalesItemSerialsScalarFieldEnum]


  export const SalesReturnScalarFieldEnum: {
    id: 'id',
    returnNo: 'returnNo',
    total_payback: 'total_payback',
    note: 'note',
    sales_id: 'sales_id',
    user_id: 'user_id',
    customer_id: 'customer_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesReturnScalarFieldEnum = (typeof SalesReturnScalarFieldEnum)[keyof typeof SalesReturnScalarFieldEnum]


  export const SalesReturnItemsScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    product_id: 'product_id',
    salesReturn_id: 'salesReturn_id',
    productSerialsId: 'productSerialsId'
  };

  export type SalesReturnItemsScalarFieldEnum = (typeof SalesReturnItemsScalarFieldEnum)[keyof typeof SalesReturnItemsScalarFieldEnum]


  export const SalesReturnItemSerialsScalarFieldEnum: {
    id: 'id',
    salesReturnItem_id: 'salesReturnItem_id',
    serial_id: 'serial_id'
  };

  export type SalesReturnItemSerialsScalarFieldEnum = (typeof SalesReturnItemSerialsScalarFieldEnum)[keyof typeof SalesReturnItemSerialsScalarFieldEnum]


  export const ExchangesScalarFieldEnum: {
    id: 'id',
    exchangeNo: 'exchangeNo',
    totalPaid: 'totalPaid',
    totalPayback: 'totalPayback',
    note: 'note',
    sales_id: 'sales_id',
    user_id: 'user_id',
    customer_id: 'customer_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExchangesScalarFieldEnum = (typeof ExchangesScalarFieldEnum)[keyof typeof ExchangesScalarFieldEnum]


  export const ExchangesItemsScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    note: 'note',
    oldProduct_id: 'oldProduct_id',
    newProduct_id: 'newProduct_id',
    exchangeId: 'exchangeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExchangesItemsScalarFieldEnum = (typeof ExchangesItemsScalarFieldEnum)[keyof typeof ExchangesItemsScalarFieldEnum]


  export const ExchangeItemSerialsScalarFieldEnum: {
    id: 'id',
    exchangeItem_id: 'exchangeItem_id',
    serial_id_old: 'serial_id_old',
    serial_id_new: 'serial_id_new'
  };

  export type ExchangeItemSerialsScalarFieldEnum = (typeof ExchangeItemSerialsScalarFieldEnum)[keyof typeof ExchangeItemSerialsScalarFieldEnum]


  export const PurchasesScalarFieldEnum: {
    id: 'id',
    purchaseNo: 'purchaseNo',
    totalAmount: 'totalAmount',
    totalPaid: 'totalPaid',
    dueDate: 'dueDate',
    note: 'note',
    supplier_id: 'supplier_id',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasesScalarFieldEnum = (typeof PurchasesScalarFieldEnum)[keyof typeof PurchasesScalarFieldEnum]


  export const PurchasesItemsScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    purchase_id: 'purchase_id',
    product_id: 'product_id'
  };

  export type PurchasesItemsScalarFieldEnum = (typeof PurchasesItemsScalarFieldEnum)[keyof typeof PurchasesItemsScalarFieldEnum]


  export const PurchaseItemSerialsScalarFieldEnum: {
    id: 'id',
    purchaseItem_id: 'purchaseItem_id',
    serial_id: 'serial_id'
  };

  export type PurchaseItemSerialsScalarFieldEnum = (typeof PurchaseItemSerialsScalarFieldEnum)[keyof typeof PurchaseItemSerialsScalarFieldEnum]


  export const PurchasesReturnScalarFieldEnum: {
    id: 'id',
    returnNo: 'returnNo',
    totalPaid: 'totalPaid',
    note: 'note',
    purchase_id: 'purchase_id',
    user_id: 'user_id',
    supplier_id: 'supplier_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchasesReturnScalarFieldEnum = (typeof PurchasesReturnScalarFieldEnum)[keyof typeof PurchasesReturnScalarFieldEnum]


  export const PurchasesReturnItemsScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    products_id: 'products_id',
    purchaseReturn_id: 'purchaseReturn_id'
  };

  export type PurchasesReturnItemsScalarFieldEnum = (typeof PurchasesReturnItemsScalarFieldEnum)[keyof typeof PurchasesReturnItemsScalarFieldEnum]


  export const PurchaseReturnItemSerialsScalarFieldEnum: {
    id: 'id',
    purchaseReturnItem_id: 'purchaseReturnItem_id',
    serial_id: 'serial_id'
  };

  export type PurchaseReturnItemSerialsScalarFieldEnum = (typeof PurchaseReturnItemSerialsScalarFieldEnum)[keyof typeof PurchaseReturnItemSerialsScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    serviceNo: 'serviceNo',
    serviceProductName: 'serviceProductName',
    serviceDescription: 'serviceDescription',
    serviceCost: 'serviceCost',
    serviceStatus: 'serviceStatus',
    customer_id: 'customer_id',
    user_id: 'user_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'SerialStatus'
   */
  export type EnumSerialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SerialStatus'>
    


  /**
   * Reference to a field of type 'SerialStatus[]'
   */
  export type ListEnumSerialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SerialStatus[]'>
    


  /**
   * Reference to a field of type 'Warranty'
   */
  export type EnumWarrantyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Warranty'>
    


  /**
   * Reference to a field of type 'Warranty[]'
   */
  export type ListEnumWarrantyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Warranty[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PermissionsWhereInput = {
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    id?: IntFilter<"Permissions"> | number
    name?: StringFilter<"Permissions"> | string
    description?: StringNullableFilter<"Permissions"> | string | null
    rolePermissions?: RolePermissionsListRelationFilter
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rolePermissions?: RolePermissionsOrderByRelationAggregateInput
  }

  export type PermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    description?: StringNullableFilter<"Permissions"> | string | null
    rolePermissions?: RolePermissionsListRelationFilter
  }, "id" | "name">

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _avg?: PermissionsAvgOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
    _sum?: PermissionsSumOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    OR?: PermissionsScalarWhereWithAggregatesInput[]
    NOT?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permissions"> | number
    name?: StringWithAggregatesFilter<"Permissions"> | string
    description?: StringNullableWithAggregatesFilter<"Permissions"> | string | null
  }

  export type RolePermissionsWhereInput = {
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    id?: IntFilter<"RolePermissions"> | number
    role_id?: IntFilter<"RolePermissions"> | number
    permission_id?: IntFilter<"RolePermissions"> | number
    can_view?: BoolFilter<"RolePermissions"> | boolean
    can_create?: BoolFilter<"RolePermissions"> | boolean
    can_edit?: BoolFilter<"RolePermissions"> | boolean
    can_delete?: BoolFilter<"RolePermissions"> | boolean
    Roles?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    Permissions?: XOR<PermissionsScalarRelationFilter, PermissionsWhereInput>
  }

  export type RolePermissionsOrderByWithRelationInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
    can_view?: SortOrder
    can_create?: SortOrder
    can_edit?: SortOrder
    can_delete?: SortOrder
    Roles?: RolesOrderByWithRelationInput
    Permissions?: PermissionsOrderByWithRelationInput
  }

  export type RolePermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    role_id_permission_id?: RolePermissionsRole_idPermission_idCompoundUniqueInput
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    role_id?: IntFilter<"RolePermissions"> | number
    permission_id?: IntFilter<"RolePermissions"> | number
    can_view?: BoolFilter<"RolePermissions"> | boolean
    can_create?: BoolFilter<"RolePermissions"> | boolean
    can_edit?: BoolFilter<"RolePermissions"> | boolean
    can_delete?: BoolFilter<"RolePermissions"> | boolean
    Roles?: XOR<RolesScalarRelationFilter, RolesWhereInput>
    Permissions?: XOR<PermissionsScalarRelationFilter, PermissionsWhereInput>
  }, "id" | "role_id_permission_id">

  export type RolePermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
    can_view?: SortOrder
    can_create?: SortOrder
    can_edit?: SortOrder
    can_delete?: SortOrder
    _count?: RolePermissionsCountOrderByAggregateInput
    _avg?: RolePermissionsAvgOrderByAggregateInput
    _max?: RolePermissionsMaxOrderByAggregateInput
    _min?: RolePermissionsMinOrderByAggregateInput
    _sum?: RolePermissionsSumOrderByAggregateInput
  }

  export type RolePermissionsScalarWhereWithAggregatesInput = {
    AND?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    OR?: RolePermissionsScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermissions"> | number
    role_id?: IntWithAggregatesFilter<"RolePermissions"> | number
    permission_id?: IntWithAggregatesFilter<"RolePermissions"> | number
    can_view?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    can_create?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    can_edit?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    can_delete?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    name?: StringFilter<"Roles"> | string
    Users?: UsersListRelationFilter
    rolePermissions?: RolePermissionsListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Users?: UsersOrderByRelationAggregateInput
    rolePermissions?: RolePermissionsOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    Users?: UsersListRelationFilter
    rolePermissions?: RolePermissionsListRelationFilter
  }, "id" | "name">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    name?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    user?: UsersOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    userId?: IntWithAggregatesFilter<"Session"> | number
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    userId?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    role_id?: IntFilter<"Users"> | number
    phone?: StringNullableFilter<"Users"> | string | null
    address?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    permissionOverrides?: JsonNullableFilter<"Users">
    Roles?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
    Session?: SessionListRelationFilter
    Sales?: SalesListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
    Purchases?: PurchasesListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
    Services?: ServicesListRelationFilter
    createdProducts?: ProductsListRelationFilter
    updatedProducts?: ProductsListRelationFilter
    expenses?: ExpensesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissionOverrides?: SortOrderInput | SortOrder
    Roles?: RolesOrderByWithRelationInput
    Session?: SessionOrderByRelationAggregateInput
    Sales?: SalesOrderByRelationAggregateInput
    SalesReturn?: SalesReturnOrderByRelationAggregateInput
    Exchanges?: ExchangesOrderByRelationAggregateInput
    Purchases?: PurchasesOrderByRelationAggregateInput
    PurchasesReturn?: PurchasesReturnOrderByRelationAggregateInput
    Services?: ServicesOrderByRelationAggregateInput
    createdProducts?: ProductsOrderByRelationAggregateInput
    updatedProducts?: ProductsOrderByRelationAggregateInput
    expenses?: ExpensesOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    role_id?: IntFilter<"Users"> | number
    phone?: StringNullableFilter<"Users"> | string | null
    address?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    permissionOverrides?: JsonNullableFilter<"Users">
    Roles?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
    Session?: SessionListRelationFilter
    Sales?: SalesListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
    Purchases?: PurchasesListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
    Services?: ServicesListRelationFilter
    createdProducts?: ProductsListRelationFilter
    updatedProducts?: ProductsListRelationFilter
    expenses?: ExpensesListRelationFilter
  }, "id" | "userId" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissionOverrides?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    userId?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    status?: EnumStatusWithAggregatesFilter<"Users"> | $Enums.Status
    role_id?: IntWithAggregatesFilter<"Users"> | number
    phone?: StringNullableWithAggregatesFilter<"Users"> | string | null
    address?: StringNullableWithAggregatesFilter<"Users"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    permissionOverrides?: JsonNullableWithAggregatesFilter<"Users">
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: IntFilter<"Customers"> | number
    custId?: StringFilter<"Customers"> | string
    name?: StringFilter<"Customers"> | string
    email?: StringNullableFilter<"Customers"> | string | null
    phone?: StringFilter<"Customers"> | string
    address?: StringNullableFilter<"Customers"> | string | null
    Sales?: SalesListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
    Services?: ServicesListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    custId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    Sales?: SalesOrderByRelationAggregateInput
    SalesReturn?: SalesReturnOrderByRelationAggregateInput
    Exchanges?: ExchangesOrderByRelationAggregateInput
    Services?: ServicesOrderByRelationAggregateInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    custId?: string
    email?: string
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    name?: StringFilter<"Customers"> | string
    phone?: StringFilter<"Customers"> | string
    address?: StringNullableFilter<"Customers"> | string | null
    Sales?: SalesListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
    Services?: ServicesListRelationFilter
  }, "id" | "custId" | "email">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    custId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customers"> | number
    custId?: StringWithAggregatesFilter<"Customers"> | string
    name?: StringWithAggregatesFilter<"Customers"> | string
    email?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    phone?: StringWithAggregatesFilter<"Customers"> | string
    address?: StringNullableWithAggregatesFilter<"Customers"> | string | null
  }

  export type SuppliersWhereInput = {
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    id?: IntFilter<"Suppliers"> | number
    suppId?: StringFilter<"Suppliers"> | string
    name?: StringFilter<"Suppliers"> | string
    email?: StringNullableFilter<"Suppliers"> | string | null
    phone?: StringFilter<"Suppliers"> | string
    address?: StringNullableFilter<"Suppliers"> | string | null
    Purchases?: PurchasesListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
    products?: ProductsListRelationFilter
  }

  export type SuppliersOrderByWithRelationInput = {
    id?: SortOrder
    suppId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    Purchases?: PurchasesOrderByRelationAggregateInput
    PurchasesReturn?: PurchasesReturnOrderByRelationAggregateInput
    products?: ProductsOrderByRelationAggregateInput
  }

  export type SuppliersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    suppId?: string
    email?: string
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    name?: StringFilter<"Suppliers"> | string
    phone?: StringFilter<"Suppliers"> | string
    address?: StringNullableFilter<"Suppliers"> | string | null
    Purchases?: PurchasesListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
    products?: ProductsListRelationFilter
  }, "id" | "suppId" | "email">

  export type SuppliersOrderByWithAggregationInput = {
    id?: SortOrder
    suppId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    _count?: SuppliersCountOrderByAggregateInput
    _avg?: SuppliersAvgOrderByAggregateInput
    _max?: SuppliersMaxOrderByAggregateInput
    _min?: SuppliersMinOrderByAggregateInput
    _sum?: SuppliersSumOrderByAggregateInput
  }

  export type SuppliersScalarWhereWithAggregatesInput = {
    AND?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    OR?: SuppliersScalarWhereWithAggregatesInput[]
    NOT?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Suppliers"> | number
    suppId?: StringWithAggregatesFilter<"Suppliers"> | string
    name?: StringWithAggregatesFilter<"Suppliers"> | string
    email?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
    phone?: StringWithAggregatesFilter<"Suppliers"> | string
    address?: StringNullableWithAggregatesFilter<"Suppliers"> | string | null
  }

  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: IntFilter<"Categories"> | number
    name?: StringFilter<"Categories"> | string
    Products?: ProductsListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Products?: ProductsOrderByRelationAggregateInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    Products?: ProductsListRelationFilter
  }, "id" | "name">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _avg?: CategoriesAvgOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
    _sum?: CategoriesSumOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categories"> | number
    name?: StringWithAggregatesFilter<"Categories"> | string
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    id?: IntFilter<"Products"> | number
    productCode?: StringFilter<"Products"> | string
    name?: StringFilter<"Products"> | string
    specification?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    quantity?: IntFilter<"Products"> | number
    purchasePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFilter<"Products"> | boolean
    productType?: EnumProductTypeFilter<"Products"> | $Enums.ProductType
    status?: EnumProductStatusFilter<"Products"> | $Enums.ProductStatus
    category_id?: IntFilter<"Products"> | number
    supplier_id?: IntNullableFilter<"Products"> | number | null
    created_by?: IntNullableFilter<"Products"> | number | null
    updated_by?: IntNullableFilter<"Products"> | number | null
    createdAt?: DateTimeFilter<"Products"> | Date | string
    updatedAt?: DateTimeFilter<"Products"> | Date | string
    Categories?: XOR<CategoriesNullableScalarRelationFilter, CategoriesWhereInput> | null
    supplier?: XOR<SuppliersNullableScalarRelationFilter, SuppliersWhereInput> | null
    creator?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    updater?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    SalesItems?: SalesItemsListRelationFilter
    SalesReturnItems?: SalesReturnItemsListRelationFilter
    exchangeItemsOld?: ExchangesItemsListRelationFilter
    exchangeItemsNew?: ExchangesItemsListRelationFilter
    PurchasesItems?: PurchasesItemsListRelationFilter
    PurchasesReturnItems?: PurchasesReturnItemsListRelationFilter
    productSerials?: ProductSerialsListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    specification?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    useIndividualSerials?: SortOrder
    productType?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Categories?: CategoriesOrderByWithRelationInput
    supplier?: SuppliersOrderByWithRelationInput
    creator?: UsersOrderByWithRelationInput
    updater?: UsersOrderByWithRelationInput
    SalesItems?: SalesItemsOrderByRelationAggregateInput
    SalesReturnItems?: SalesReturnItemsOrderByRelationAggregateInput
    exchangeItemsOld?: ExchangesItemsOrderByRelationAggregateInput
    exchangeItemsNew?: ExchangesItemsOrderByRelationAggregateInput
    PurchasesItems?: PurchasesItemsOrderByRelationAggregateInput
    PurchasesReturnItems?: PurchasesReturnItemsOrderByRelationAggregateInput
    productSerials?: ProductSerialsOrderByRelationAggregateInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productCode?: string
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    name?: StringFilter<"Products"> | string
    specification?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    quantity?: IntFilter<"Products"> | number
    purchasePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFilter<"Products"> | boolean
    productType?: EnumProductTypeFilter<"Products"> | $Enums.ProductType
    status?: EnumProductStatusFilter<"Products"> | $Enums.ProductStatus
    category_id?: IntFilter<"Products"> | number
    supplier_id?: IntNullableFilter<"Products"> | number | null
    created_by?: IntNullableFilter<"Products"> | number | null
    updated_by?: IntNullableFilter<"Products"> | number | null
    createdAt?: DateTimeFilter<"Products"> | Date | string
    updatedAt?: DateTimeFilter<"Products"> | Date | string
    Categories?: XOR<CategoriesNullableScalarRelationFilter, CategoriesWhereInput> | null
    supplier?: XOR<SuppliersNullableScalarRelationFilter, SuppliersWhereInput> | null
    creator?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    updater?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    SalesItems?: SalesItemsListRelationFilter
    SalesReturnItems?: SalesReturnItemsListRelationFilter
    exchangeItemsOld?: ExchangesItemsListRelationFilter
    exchangeItemsNew?: ExchangesItemsListRelationFilter
    PurchasesItems?: PurchasesItemsListRelationFilter
    PurchasesReturnItems?: PurchasesReturnItemsListRelationFilter
    productSerials?: ProductSerialsListRelationFilter
  }, "id" | "productCode">

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    specification?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    useIndividualSerials?: SortOrder
    productType?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _avg?: ProductsAvgOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
    _sum?: ProductsSumOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Products"> | number
    productCode?: StringWithAggregatesFilter<"Products"> | string
    name?: StringWithAggregatesFilter<"Products"> | string
    specification?: StringNullableWithAggregatesFilter<"Products"> | string | null
    description?: StringNullableWithAggregatesFilter<"Products"> | string | null
    quantity?: IntWithAggregatesFilter<"Products"> | number
    purchasePrice?: DecimalWithAggregatesFilter<"Products"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalWithAggregatesFilter<"Products"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalWithAggregatesFilter<"Products"> | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolWithAggregatesFilter<"Products"> | boolean
    productType?: EnumProductTypeWithAggregatesFilter<"Products"> | $Enums.ProductType
    status?: EnumProductStatusWithAggregatesFilter<"Products"> | $Enums.ProductStatus
    category_id?: IntWithAggregatesFilter<"Products"> | number
    supplier_id?: IntNullableWithAggregatesFilter<"Products"> | number | null
    created_by?: IntNullableWithAggregatesFilter<"Products"> | number | null
    updated_by?: IntNullableWithAggregatesFilter<"Products"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Products"> | Date | string
  }

  export type ProductSerialsWhereInput = {
    AND?: ProductSerialsWhereInput | ProductSerialsWhereInput[]
    OR?: ProductSerialsWhereInput[]
    NOT?: ProductSerialsWhereInput | ProductSerialsWhereInput[]
    id?: IntFilter<"ProductSerials"> | number
    serial?: StringFilter<"ProductSerials"> | string
    product_id?: IntFilter<"ProductSerials"> | number
    status?: EnumSerialStatusFilter<"ProductSerials"> | $Enums.SerialStatus
    warranty?: EnumWarrantyFilter<"ProductSerials"> | $Enums.Warranty
    createdAt?: DateTimeFilter<"ProductSerials"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSerials"> | Date | string
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    SalesItemSerials?: SalesItemSerialsListRelationFilter
    salesReturnItemSerials?: SalesReturnItemSerialsListRelationFilter
    purchaseItemSerials?: PurchaseItemSerialsListRelationFilter
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsListRelationFilter
    salesReturnItems?: SalesReturnItemsListRelationFilter
    exchangeItemSerialsOld?: ExchangeItemSerialsListRelationFilter
    exchangeItemSerialsNew?: ExchangeItemSerialsListRelationFilter
  }

  export type ProductSerialsOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    product_id?: SortOrder
    status?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Products?: ProductsOrderByWithRelationInput
    SalesItemSerials?: SalesItemSerialsOrderByRelationAggregateInput
    salesReturnItemSerials?: SalesReturnItemSerialsOrderByRelationAggregateInput
    purchaseItemSerials?: PurchaseItemSerialsOrderByRelationAggregateInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsOrderByRelationAggregateInput
    salesReturnItems?: SalesReturnItemsOrderByRelationAggregateInput
    exchangeItemSerialsOld?: ExchangeItemSerialsOrderByRelationAggregateInput
    exchangeItemSerialsNew?: ExchangeItemSerialsOrderByRelationAggregateInput
  }

  export type ProductSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serial?: string
    AND?: ProductSerialsWhereInput | ProductSerialsWhereInput[]
    OR?: ProductSerialsWhereInput[]
    NOT?: ProductSerialsWhereInput | ProductSerialsWhereInput[]
    product_id?: IntFilter<"ProductSerials"> | number
    status?: EnumSerialStatusFilter<"ProductSerials"> | $Enums.SerialStatus
    warranty?: EnumWarrantyFilter<"ProductSerials"> | $Enums.Warranty
    createdAt?: DateTimeFilter<"ProductSerials"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSerials"> | Date | string
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    SalesItemSerials?: SalesItemSerialsListRelationFilter
    salesReturnItemSerials?: SalesReturnItemSerialsListRelationFilter
    purchaseItemSerials?: PurchaseItemSerialsListRelationFilter
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsListRelationFilter
    salesReturnItems?: SalesReturnItemsListRelationFilter
    exchangeItemSerialsOld?: ExchangeItemSerialsListRelationFilter
    exchangeItemSerialsNew?: ExchangeItemSerialsListRelationFilter
  }, "id" | "serial">

  export type ProductSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    product_id?: SortOrder
    status?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductSerialsCountOrderByAggregateInput
    _avg?: ProductSerialsAvgOrderByAggregateInput
    _max?: ProductSerialsMaxOrderByAggregateInput
    _min?: ProductSerialsMinOrderByAggregateInput
    _sum?: ProductSerialsSumOrderByAggregateInput
  }

  export type ProductSerialsScalarWhereWithAggregatesInput = {
    AND?: ProductSerialsScalarWhereWithAggregatesInput | ProductSerialsScalarWhereWithAggregatesInput[]
    OR?: ProductSerialsScalarWhereWithAggregatesInput[]
    NOT?: ProductSerialsScalarWhereWithAggregatesInput | ProductSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductSerials"> | number
    serial?: StringWithAggregatesFilter<"ProductSerials"> | string
    product_id?: IntWithAggregatesFilter<"ProductSerials"> | number
    status?: EnumSerialStatusWithAggregatesFilter<"ProductSerials"> | $Enums.SerialStatus
    warranty?: EnumWarrantyWithAggregatesFilter<"ProductSerials"> | $Enums.Warranty
    createdAt?: DateTimeWithAggregatesFilter<"ProductSerials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductSerials"> | Date | string
  }

  export type ExpensesWhereInput = {
    AND?: ExpensesWhereInput | ExpensesWhereInput[]
    OR?: ExpensesWhereInput[]
    NOT?: ExpensesWhereInput | ExpensesWhereInput[]
    id?: IntFilter<"Expenses"> | number
    expenseNo?: StringFilter<"Expenses"> | string
    title?: StringFilter<"Expenses"> | string
    amount?: DecimalFilter<"Expenses"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expenses"> | Date | string
    description?: StringNullableFilter<"Expenses"> | string | null
    user_id?: IntFilter<"Expenses"> | number
    createdAt?: DateTimeFilter<"Expenses"> | Date | string
    updatedAt?: DateTimeFilter<"Expenses"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ExpensesOrderByWithRelationInput = {
    id?: SortOrder
    expenseNo?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type ExpensesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    expenseNo?: string
    AND?: ExpensesWhereInput | ExpensesWhereInput[]
    OR?: ExpensesWhereInput[]
    NOT?: ExpensesWhereInput | ExpensesWhereInput[]
    title?: StringFilter<"Expenses"> | string
    amount?: DecimalFilter<"Expenses"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expenses"> | Date | string
    description?: StringNullableFilter<"Expenses"> | string | null
    user_id?: IntFilter<"Expenses"> | number
    createdAt?: DateTimeFilter<"Expenses"> | Date | string
    updatedAt?: DateTimeFilter<"Expenses"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "expenseNo">

  export type ExpensesOrderByWithAggregationInput = {
    id?: SortOrder
    expenseNo?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpensesCountOrderByAggregateInput
    _avg?: ExpensesAvgOrderByAggregateInput
    _max?: ExpensesMaxOrderByAggregateInput
    _min?: ExpensesMinOrderByAggregateInput
    _sum?: ExpensesSumOrderByAggregateInput
  }

  export type ExpensesScalarWhereWithAggregatesInput = {
    AND?: ExpensesScalarWhereWithAggregatesInput | ExpensesScalarWhereWithAggregatesInput[]
    OR?: ExpensesScalarWhereWithAggregatesInput[]
    NOT?: ExpensesScalarWhereWithAggregatesInput | ExpensesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expenses"> | number
    expenseNo?: StringWithAggregatesFilter<"Expenses"> | string
    title?: StringWithAggregatesFilter<"Expenses"> | string
    amount?: DecimalWithAggregatesFilter<"Expenses"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"Expenses"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Expenses"> | string | null
    user_id?: IntWithAggregatesFilter<"Expenses"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Expenses"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expenses"> | Date | string
  }

  export type SalesWhereInput = {
    AND?: SalesWhereInput | SalesWhereInput[]
    OR?: SalesWhereInput[]
    NOT?: SalesWhereInput | SalesWhereInput[]
    id?: IntFilter<"Sales"> | number
    saleNo?: StringFilter<"Sales"> | string
    totalAmount?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totaldiscount?: DecimalNullableFilter<"Sales"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeNullableFilter<"Sales"> | Date | string | null
    status?: StringFilter<"Sales"> | string
    customer_id?: IntNullableFilter<"Sales"> | number | null
    user_id?: IntFilter<"Sales"> | number
    createdAt?: DateTimeFilter<"Sales"> | Date | string
    updatedAt?: DateTimeFilter<"Sales"> | Date | string
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    SalesItems?: SalesItemsListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
  }

  export type SalesOrderByWithRelationInput = {
    id?: SortOrder
    saleNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Customers?: CustomersOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    SalesItems?: SalesItemsOrderByRelationAggregateInput
    SalesReturn?: SalesReturnOrderByRelationAggregateInput
    Exchanges?: ExchangesOrderByRelationAggregateInput
  }

  export type SalesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    saleNo?: string
    AND?: SalesWhereInput | SalesWhereInput[]
    OR?: SalesWhereInput[]
    NOT?: SalesWhereInput | SalesWhereInput[]
    totalAmount?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totaldiscount?: DecimalNullableFilter<"Sales"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeNullableFilter<"Sales"> | Date | string | null
    status?: StringFilter<"Sales"> | string
    customer_id?: IntNullableFilter<"Sales"> | number | null
    user_id?: IntFilter<"Sales"> | number
    createdAt?: DateTimeFilter<"Sales"> | Date | string
    updatedAt?: DateTimeFilter<"Sales"> | Date | string
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    SalesItems?: SalesItemsListRelationFilter
    SalesReturn?: SalesReturnListRelationFilter
    Exchanges?: ExchangesListRelationFilter
  }, "id" | "saleNo">

  export type SalesOrderByWithAggregationInput = {
    id?: SortOrder
    saleNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesCountOrderByAggregateInput
    _avg?: SalesAvgOrderByAggregateInput
    _max?: SalesMaxOrderByAggregateInput
    _min?: SalesMinOrderByAggregateInput
    _sum?: SalesSumOrderByAggregateInput
  }

  export type SalesScalarWhereWithAggregatesInput = {
    AND?: SalesScalarWhereWithAggregatesInput | SalesScalarWhereWithAggregatesInput[]
    OR?: SalesScalarWhereWithAggregatesInput[]
    NOT?: SalesScalarWhereWithAggregatesInput | SalesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sales"> | number
    saleNo?: StringWithAggregatesFilter<"Sales"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalWithAggregatesFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totaldiscount?: DecimalNullableWithAggregatesFilter<"Sales"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Sales"> | Date | string | null
    status?: StringWithAggregatesFilter<"Sales"> | string
    customer_id?: IntNullableWithAggregatesFilter<"Sales"> | number | null
    user_id?: IntWithAggregatesFilter<"Sales"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sales"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sales"> | Date | string
  }

  export type SalesItemsWhereInput = {
    AND?: SalesItemsWhereInput | SalesItemsWhereInput[]
    OR?: SalesItemsWhereInput[]
    NOT?: SalesItemsWhereInput | SalesItemsWhereInput[]
    id?: IntFilter<"SalesItems"> | number
    quantity?: IntFilter<"SalesItems"> | number
    unitPrice?: DecimalFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFilter<"SalesItems"> | number
    product_id?: IntFilter<"SalesItems"> | number
    Sales?: XOR<SalesNullableScalarRelationFilter, SalesWhereInput> | null
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    salesItemSerials?: SalesItemSerialsListRelationFilter
  }

  export type SalesItemsOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrderInput | SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
    Sales?: SalesOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
    salesItemSerials?: SalesItemSerialsOrderByRelationAggregateInput
  }

  export type SalesItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesItemsWhereInput | SalesItemsWhereInput[]
    OR?: SalesItemsWhereInput[]
    NOT?: SalesItemsWhereInput | SalesItemsWhereInput[]
    quantity?: IntFilter<"SalesItems"> | number
    unitPrice?: DecimalFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFilter<"SalesItems"> | number
    product_id?: IntFilter<"SalesItems"> | number
    Sales?: XOR<SalesNullableScalarRelationFilter, SalesWhereInput> | null
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    salesItemSerials?: SalesItemSerialsListRelationFilter
  }, "id">

  export type SalesItemsOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrderInput | SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
    _count?: SalesItemsCountOrderByAggregateInput
    _avg?: SalesItemsAvgOrderByAggregateInput
    _max?: SalesItemsMaxOrderByAggregateInput
    _min?: SalesItemsMinOrderByAggregateInput
    _sum?: SalesItemsSumOrderByAggregateInput
  }

  export type SalesItemsScalarWhereWithAggregatesInput = {
    AND?: SalesItemsScalarWhereWithAggregatesInput | SalesItemsScalarWhereWithAggregatesInput[]
    OR?: SalesItemsScalarWhereWithAggregatesInput[]
    NOT?: SalesItemsScalarWhereWithAggregatesInput | SalesItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesItems"> | number
    quantity?: IntWithAggregatesFilter<"SalesItems"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableWithAggregatesFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntWithAggregatesFilter<"SalesItems"> | number
    product_id?: IntWithAggregatesFilter<"SalesItems"> | number
  }

  export type SalesItemSerialsWhereInput = {
    AND?: SalesItemSerialsWhereInput | SalesItemSerialsWhereInput[]
    OR?: SalesItemSerialsWhereInput[]
    NOT?: SalesItemSerialsWhereInput | SalesItemSerialsWhereInput[]
    id?: IntFilter<"SalesItemSerials"> | number
    salesItem_id?: IntFilter<"SalesItemSerials"> | number
    serial_id?: IntFilter<"SalesItemSerials"> | number
    SalesItems?: XOR<SalesItemsScalarRelationFilter, SalesItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }

  export type SalesItemSerialsOrderByWithRelationInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
    SalesItems?: SalesItemsOrderByWithRelationInput
    ProductSerials?: ProductSerialsOrderByWithRelationInput
  }

  export type SalesItemSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesItemSerialsWhereInput | SalesItemSerialsWhereInput[]
    OR?: SalesItemSerialsWhereInput[]
    NOT?: SalesItemSerialsWhereInput | SalesItemSerialsWhereInput[]
    salesItem_id?: IntFilter<"SalesItemSerials"> | number
    serial_id?: IntFilter<"SalesItemSerials"> | number
    SalesItems?: XOR<SalesItemsScalarRelationFilter, SalesItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }, "id">

  export type SalesItemSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
    _count?: SalesItemSerialsCountOrderByAggregateInput
    _avg?: SalesItemSerialsAvgOrderByAggregateInput
    _max?: SalesItemSerialsMaxOrderByAggregateInput
    _min?: SalesItemSerialsMinOrderByAggregateInput
    _sum?: SalesItemSerialsSumOrderByAggregateInput
  }

  export type SalesItemSerialsScalarWhereWithAggregatesInput = {
    AND?: SalesItemSerialsScalarWhereWithAggregatesInput | SalesItemSerialsScalarWhereWithAggregatesInput[]
    OR?: SalesItemSerialsScalarWhereWithAggregatesInput[]
    NOT?: SalesItemSerialsScalarWhereWithAggregatesInput | SalesItemSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesItemSerials"> | number
    salesItem_id?: IntWithAggregatesFilter<"SalesItemSerials"> | number
    serial_id?: IntWithAggregatesFilter<"SalesItemSerials"> | number
  }

  export type SalesReturnWhereInput = {
    AND?: SalesReturnWhereInput | SalesReturnWhereInput[]
    OR?: SalesReturnWhereInput[]
    NOT?: SalesReturnWhereInput | SalesReturnWhereInput[]
    id?: IntFilter<"SalesReturn"> | number
    returnNo?: StringFilter<"SalesReturn"> | string
    total_payback?: DecimalFilter<"SalesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"SalesReturn"> | string
    sales_id?: IntFilter<"SalesReturn"> | number
    user_id?: IntFilter<"SalesReturn"> | number
    customer_id?: IntFilter<"SalesReturn"> | number
    createdAt?: DateTimeFilter<"SalesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturn"> | Date | string
    Sales?: XOR<SalesScalarRelationFilter, SalesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    SalesReturnItems?: SalesReturnItemsListRelationFilter
  }

  export type SalesReturnOrderByWithRelationInput = {
    id?: SortOrder
    returnNo?: SortOrder
    total_payback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Sales?: SalesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    Customers?: CustomersOrderByWithRelationInput
    SalesReturnItems?: SalesReturnItemsOrderByRelationAggregateInput
  }

  export type SalesReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    returnNo?: string
    AND?: SalesReturnWhereInput | SalesReturnWhereInput[]
    OR?: SalesReturnWhereInput[]
    NOT?: SalesReturnWhereInput | SalesReturnWhereInput[]
    total_payback?: DecimalFilter<"SalesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"SalesReturn"> | string
    sales_id?: IntFilter<"SalesReturn"> | number
    user_id?: IntFilter<"SalesReturn"> | number
    customer_id?: IntFilter<"SalesReturn"> | number
    createdAt?: DateTimeFilter<"SalesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturn"> | Date | string
    Sales?: XOR<SalesScalarRelationFilter, SalesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Customers?: XOR<CustomersScalarRelationFilter, CustomersWhereInput>
    SalesReturnItems?: SalesReturnItemsListRelationFilter
  }, "id" | "returnNo">

  export type SalesReturnOrderByWithAggregationInput = {
    id?: SortOrder
    returnNo?: SortOrder
    total_payback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesReturnCountOrderByAggregateInput
    _avg?: SalesReturnAvgOrderByAggregateInput
    _max?: SalesReturnMaxOrderByAggregateInput
    _min?: SalesReturnMinOrderByAggregateInput
    _sum?: SalesReturnSumOrderByAggregateInput
  }

  export type SalesReturnScalarWhereWithAggregatesInput = {
    AND?: SalesReturnScalarWhereWithAggregatesInput | SalesReturnScalarWhereWithAggregatesInput[]
    OR?: SalesReturnScalarWhereWithAggregatesInput[]
    NOT?: SalesReturnScalarWhereWithAggregatesInput | SalesReturnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesReturn"> | number
    returnNo?: StringWithAggregatesFilter<"SalesReturn"> | string
    total_payback?: DecimalWithAggregatesFilter<"SalesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringWithAggregatesFilter<"SalesReturn"> | string
    sales_id?: IntWithAggregatesFilter<"SalesReturn"> | number
    user_id?: IntWithAggregatesFilter<"SalesReturn"> | number
    customer_id?: IntWithAggregatesFilter<"SalesReturn"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SalesReturn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesReturn"> | Date | string
  }

  export type SalesReturnItemsWhereInput = {
    AND?: SalesReturnItemsWhereInput | SalesReturnItemsWhereInput[]
    OR?: SalesReturnItemsWhereInput[]
    NOT?: SalesReturnItemsWhereInput | SalesReturnItemsWhereInput[]
    id?: IntFilter<"SalesReturnItems"> | number
    quantity?: IntFilter<"SalesReturnItems"> | number
    unitPrice?: DecimalFilter<"SalesReturnItems"> | Decimal | DecimalJsLike | number | string
    product_id?: IntFilter<"SalesReturnItems"> | number
    salesReturn_id?: IntFilter<"SalesReturnItems"> | number
    productSerialsId?: IntNullableFilter<"SalesReturnItems"> | number | null
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    SalesReturn?: XOR<SalesReturnNullableScalarRelationFilter, SalesReturnWhereInput> | null
    productSerials?: XOR<ProductSerialsNullableScalarRelationFilter, ProductSerialsWhereInput> | null
    salesReturnItemSerials?: SalesReturnItemSerialsListRelationFilter
  }

  export type SalesReturnItemsOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrderInput | SortOrder
    Products?: ProductsOrderByWithRelationInput
    SalesReturn?: SalesReturnOrderByWithRelationInput
    productSerials?: ProductSerialsOrderByWithRelationInput
    salesReturnItemSerials?: SalesReturnItemSerialsOrderByRelationAggregateInput
  }

  export type SalesReturnItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesReturnItemsWhereInput | SalesReturnItemsWhereInput[]
    OR?: SalesReturnItemsWhereInput[]
    NOT?: SalesReturnItemsWhereInput | SalesReturnItemsWhereInput[]
    quantity?: IntFilter<"SalesReturnItems"> | number
    unitPrice?: DecimalFilter<"SalesReturnItems"> | Decimal | DecimalJsLike | number | string
    product_id?: IntFilter<"SalesReturnItems"> | number
    salesReturn_id?: IntFilter<"SalesReturnItems"> | number
    productSerialsId?: IntNullableFilter<"SalesReturnItems"> | number | null
    Products?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    SalesReturn?: XOR<SalesReturnNullableScalarRelationFilter, SalesReturnWhereInput> | null
    productSerials?: XOR<ProductSerialsNullableScalarRelationFilter, ProductSerialsWhereInput> | null
    salesReturnItemSerials?: SalesReturnItemSerialsListRelationFilter
  }, "id">

  export type SalesReturnItemsOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrderInput | SortOrder
    _count?: SalesReturnItemsCountOrderByAggregateInput
    _avg?: SalesReturnItemsAvgOrderByAggregateInput
    _max?: SalesReturnItemsMaxOrderByAggregateInput
    _min?: SalesReturnItemsMinOrderByAggregateInput
    _sum?: SalesReturnItemsSumOrderByAggregateInput
  }

  export type SalesReturnItemsScalarWhereWithAggregatesInput = {
    AND?: SalesReturnItemsScalarWhereWithAggregatesInput | SalesReturnItemsScalarWhereWithAggregatesInput[]
    OR?: SalesReturnItemsScalarWhereWithAggregatesInput[]
    NOT?: SalesReturnItemsScalarWhereWithAggregatesInput | SalesReturnItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesReturnItems"> | number
    quantity?: IntWithAggregatesFilter<"SalesReturnItems"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SalesReturnItems"> | Decimal | DecimalJsLike | number | string
    product_id?: IntWithAggregatesFilter<"SalesReturnItems"> | number
    salesReturn_id?: IntWithAggregatesFilter<"SalesReturnItems"> | number
    productSerialsId?: IntNullableWithAggregatesFilter<"SalesReturnItems"> | number | null
  }

  export type SalesReturnItemSerialsWhereInput = {
    AND?: SalesReturnItemSerialsWhereInput | SalesReturnItemSerialsWhereInput[]
    OR?: SalesReturnItemSerialsWhereInput[]
    NOT?: SalesReturnItemSerialsWhereInput | SalesReturnItemSerialsWhereInput[]
    id?: IntFilter<"SalesReturnItemSerials"> | number
    salesReturnItem_id?: IntFilter<"SalesReturnItemSerials"> | number
    serial_id?: IntFilter<"SalesReturnItemSerials"> | number
    SalesReturnItems?: XOR<SalesReturnItemsScalarRelationFilter, SalesReturnItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }

  export type SalesReturnItemSerialsOrderByWithRelationInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
    SalesReturnItems?: SalesReturnItemsOrderByWithRelationInput
    ProductSerials?: ProductSerialsOrderByWithRelationInput
  }

  export type SalesReturnItemSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesReturnItemSerialsWhereInput | SalesReturnItemSerialsWhereInput[]
    OR?: SalesReturnItemSerialsWhereInput[]
    NOT?: SalesReturnItemSerialsWhereInput | SalesReturnItemSerialsWhereInput[]
    salesReturnItem_id?: IntFilter<"SalesReturnItemSerials"> | number
    serial_id?: IntFilter<"SalesReturnItemSerials"> | number
    SalesReturnItems?: XOR<SalesReturnItemsScalarRelationFilter, SalesReturnItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }, "id">

  export type SalesReturnItemSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
    _count?: SalesReturnItemSerialsCountOrderByAggregateInput
    _avg?: SalesReturnItemSerialsAvgOrderByAggregateInput
    _max?: SalesReturnItemSerialsMaxOrderByAggregateInput
    _min?: SalesReturnItemSerialsMinOrderByAggregateInput
    _sum?: SalesReturnItemSerialsSumOrderByAggregateInput
  }

  export type SalesReturnItemSerialsScalarWhereWithAggregatesInput = {
    AND?: SalesReturnItemSerialsScalarWhereWithAggregatesInput | SalesReturnItemSerialsScalarWhereWithAggregatesInput[]
    OR?: SalesReturnItemSerialsScalarWhereWithAggregatesInput[]
    NOT?: SalesReturnItemSerialsScalarWhereWithAggregatesInput | SalesReturnItemSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesReturnItemSerials"> | number
    salesReturnItem_id?: IntWithAggregatesFilter<"SalesReturnItemSerials"> | number
    serial_id?: IntWithAggregatesFilter<"SalesReturnItemSerials"> | number
  }

  export type ExchangesWhereInput = {
    AND?: ExchangesWhereInput | ExchangesWhereInput[]
    OR?: ExchangesWhereInput[]
    NOT?: ExchangesWhereInput | ExchangesWhereInput[]
    id?: IntFilter<"Exchanges"> | number
    exchangeNo?: StringFilter<"Exchanges"> | string
    totalPaid?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"Exchanges"> | string
    sales_id?: IntFilter<"Exchanges"> | number
    user_id?: IntFilter<"Exchanges"> | number
    customer_id?: IntFilter<"Exchanges"> | number
    createdAt?: DateTimeFilter<"Exchanges"> | Date | string
    updatedAt?: DateTimeFilter<"Exchanges"> | Date | string
    Sales?: XOR<SalesNullableScalarRelationFilter, SalesWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    ExchangeItems?: ExchangesItemsListRelationFilter
  }

  export type ExchangesOrderByWithRelationInput = {
    id?: SortOrder
    exchangeNo?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Sales?: SalesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    Customers?: CustomersOrderByWithRelationInput
    ExchangeItems?: ExchangesItemsOrderByRelationAggregateInput
  }

  export type ExchangesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    exchangeNo?: string
    AND?: ExchangesWhereInput | ExchangesWhereInput[]
    OR?: ExchangesWhereInput[]
    NOT?: ExchangesWhereInput | ExchangesWhereInput[]
    totalPaid?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"Exchanges"> | string
    sales_id?: IntFilter<"Exchanges"> | number
    user_id?: IntFilter<"Exchanges"> | number
    customer_id?: IntFilter<"Exchanges"> | number
    createdAt?: DateTimeFilter<"Exchanges"> | Date | string
    updatedAt?: DateTimeFilter<"Exchanges"> | Date | string
    Sales?: XOR<SalesNullableScalarRelationFilter, SalesWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    ExchangeItems?: ExchangesItemsListRelationFilter
  }, "id" | "exchangeNo">

  export type ExchangesOrderByWithAggregationInput = {
    id?: SortOrder
    exchangeNo?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExchangesCountOrderByAggregateInput
    _avg?: ExchangesAvgOrderByAggregateInput
    _max?: ExchangesMaxOrderByAggregateInput
    _min?: ExchangesMinOrderByAggregateInput
    _sum?: ExchangesSumOrderByAggregateInput
  }

  export type ExchangesScalarWhereWithAggregatesInput = {
    AND?: ExchangesScalarWhereWithAggregatesInput | ExchangesScalarWhereWithAggregatesInput[]
    OR?: ExchangesScalarWhereWithAggregatesInput[]
    NOT?: ExchangesScalarWhereWithAggregatesInput | ExchangesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exchanges"> | number
    exchangeNo?: StringWithAggregatesFilter<"Exchanges"> | string
    totalPaid?: DecimalWithAggregatesFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalWithAggregatesFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    note?: StringWithAggregatesFilter<"Exchanges"> | string
    sales_id?: IntWithAggregatesFilter<"Exchanges"> | number
    user_id?: IntWithAggregatesFilter<"Exchanges"> | number
    customer_id?: IntWithAggregatesFilter<"Exchanges"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Exchanges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exchanges"> | Date | string
  }

  export type ExchangesItemsWhereInput = {
    AND?: ExchangesItemsWhereInput | ExchangesItemsWhereInput[]
    OR?: ExchangesItemsWhereInput[]
    NOT?: ExchangesItemsWhereInput | ExchangesItemsWhereInput[]
    id?: IntFilter<"ExchangesItems"> | number
    quantity?: IntFilter<"ExchangesItems"> | number
    unitPrice?: DecimalFilter<"ExchangesItems"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"ExchangesItems"> | string
    oldProduct_id?: IntFilter<"ExchangesItems"> | number
    newProduct_id?: IntFilter<"ExchangesItems"> | number
    exchangeId?: IntNullableFilter<"ExchangesItems"> | number | null
    createdAt?: DateTimeFilter<"ExchangesItems"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangesItems"> | Date | string
    oldProduct?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    newProduct?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    Exchanges?: XOR<ExchangesNullableScalarRelationFilter, ExchangesWhereInput> | null
    exchangeItemSerials?: ExchangeItemSerialsListRelationFilter
  }

  export type ExchangesItemsOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    note?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oldProduct?: ProductsOrderByWithRelationInput
    newProduct?: ProductsOrderByWithRelationInput
    Exchanges?: ExchangesOrderByWithRelationInput
    exchangeItemSerials?: ExchangeItemSerialsOrderByRelationAggregateInput
  }

  export type ExchangesItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExchangesItemsWhereInput | ExchangesItemsWhereInput[]
    OR?: ExchangesItemsWhereInput[]
    NOT?: ExchangesItemsWhereInput | ExchangesItemsWhereInput[]
    quantity?: IntFilter<"ExchangesItems"> | number
    unitPrice?: DecimalFilter<"ExchangesItems"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"ExchangesItems"> | string
    oldProduct_id?: IntFilter<"ExchangesItems"> | number
    newProduct_id?: IntFilter<"ExchangesItems"> | number
    exchangeId?: IntNullableFilter<"ExchangesItems"> | number | null
    createdAt?: DateTimeFilter<"ExchangesItems"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangesItems"> | Date | string
    oldProduct?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    newProduct?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
    Exchanges?: XOR<ExchangesNullableScalarRelationFilter, ExchangesWhereInput> | null
    exchangeItemSerials?: ExchangeItemSerialsListRelationFilter
  }, "id">

  export type ExchangesItemsOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    note?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExchangesItemsCountOrderByAggregateInput
    _avg?: ExchangesItemsAvgOrderByAggregateInput
    _max?: ExchangesItemsMaxOrderByAggregateInput
    _min?: ExchangesItemsMinOrderByAggregateInput
    _sum?: ExchangesItemsSumOrderByAggregateInput
  }

  export type ExchangesItemsScalarWhereWithAggregatesInput = {
    AND?: ExchangesItemsScalarWhereWithAggregatesInput | ExchangesItemsScalarWhereWithAggregatesInput[]
    OR?: ExchangesItemsScalarWhereWithAggregatesInput[]
    NOT?: ExchangesItemsScalarWhereWithAggregatesInput | ExchangesItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExchangesItems"> | number
    quantity?: IntWithAggregatesFilter<"ExchangesItems"> | number
    unitPrice?: DecimalWithAggregatesFilter<"ExchangesItems"> | Decimal | DecimalJsLike | number | string
    note?: StringWithAggregatesFilter<"ExchangesItems"> | string
    oldProduct_id?: IntWithAggregatesFilter<"ExchangesItems"> | number
    newProduct_id?: IntWithAggregatesFilter<"ExchangesItems"> | number
    exchangeId?: IntNullableWithAggregatesFilter<"ExchangesItems"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ExchangesItems"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExchangesItems"> | Date | string
  }

  export type ExchangeItemSerialsWhereInput = {
    AND?: ExchangeItemSerialsWhereInput | ExchangeItemSerialsWhereInput[]
    OR?: ExchangeItemSerialsWhereInput[]
    NOT?: ExchangeItemSerialsWhereInput | ExchangeItemSerialsWhereInput[]
    id?: IntFilter<"ExchangeItemSerials"> | number
    exchangeItem_id?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_old?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_new?: IntFilter<"ExchangeItemSerials"> | number
    ExchangesItems?: XOR<ExchangesItemsScalarRelationFilter, ExchangesItemsWhereInput>
    OldProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
    NewProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }

  export type ExchangeItemSerialsOrderByWithRelationInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
    ExchangesItems?: ExchangesItemsOrderByWithRelationInput
    OldProductSerials?: ProductSerialsOrderByWithRelationInput
    NewProductSerials?: ProductSerialsOrderByWithRelationInput
  }

  export type ExchangeItemSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExchangeItemSerialsWhereInput | ExchangeItemSerialsWhereInput[]
    OR?: ExchangeItemSerialsWhereInput[]
    NOT?: ExchangeItemSerialsWhereInput | ExchangeItemSerialsWhereInput[]
    exchangeItem_id?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_old?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_new?: IntFilter<"ExchangeItemSerials"> | number
    ExchangesItems?: XOR<ExchangesItemsScalarRelationFilter, ExchangesItemsWhereInput>
    OldProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
    NewProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }, "id">

  export type ExchangeItemSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
    _count?: ExchangeItemSerialsCountOrderByAggregateInput
    _avg?: ExchangeItemSerialsAvgOrderByAggregateInput
    _max?: ExchangeItemSerialsMaxOrderByAggregateInput
    _min?: ExchangeItemSerialsMinOrderByAggregateInput
    _sum?: ExchangeItemSerialsSumOrderByAggregateInput
  }

  export type ExchangeItemSerialsScalarWhereWithAggregatesInput = {
    AND?: ExchangeItemSerialsScalarWhereWithAggregatesInput | ExchangeItemSerialsScalarWhereWithAggregatesInput[]
    OR?: ExchangeItemSerialsScalarWhereWithAggregatesInput[]
    NOT?: ExchangeItemSerialsScalarWhereWithAggregatesInput | ExchangeItemSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExchangeItemSerials"> | number
    exchangeItem_id?: IntWithAggregatesFilter<"ExchangeItemSerials"> | number
    serial_id_old?: IntWithAggregatesFilter<"ExchangeItemSerials"> | number
    serial_id_new?: IntWithAggregatesFilter<"ExchangeItemSerials"> | number
  }

  export type PurchasesWhereInput = {
    AND?: PurchasesWhereInput | PurchasesWhereInput[]
    OR?: PurchasesWhereInput[]
    NOT?: PurchasesWhereInput | PurchasesWhereInput[]
    id?: IntFilter<"Purchases"> | number
    purchaseNo?: StringFilter<"Purchases"> | string
    totalAmount?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Purchases"> | Date | string
    note?: StringNullableFilter<"Purchases"> | string | null
    supplier_id?: IntFilter<"Purchases"> | number
    user_id?: IntFilter<"Purchases"> | number
    createdAt?: DateTimeFilter<"Purchases"> | Date | string
    updatedAt?: DateTimeFilter<"Purchases"> | Date | string
    Suppliers?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    PurchasesItems?: PurchasesItemsListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
  }

  export type PurchasesOrderByWithRelationInput = {
    id?: SortOrder
    purchaseNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    dueDate?: SortOrder
    note?: SortOrderInput | SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Suppliers?: SuppliersOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    PurchasesItems?: PurchasesItemsOrderByRelationAggregateInput
    PurchasesReturn?: PurchasesReturnOrderByRelationAggregateInput
  }

  export type PurchasesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    purchaseNo?: string
    AND?: PurchasesWhereInput | PurchasesWhereInput[]
    OR?: PurchasesWhereInput[]
    NOT?: PurchasesWhereInput | PurchasesWhereInput[]
    totalAmount?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Purchases"> | Date | string
    note?: StringNullableFilter<"Purchases"> | string | null
    supplier_id?: IntFilter<"Purchases"> | number
    user_id?: IntFilter<"Purchases"> | number
    createdAt?: DateTimeFilter<"Purchases"> | Date | string
    updatedAt?: DateTimeFilter<"Purchases"> | Date | string
    Suppliers?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    PurchasesItems?: PurchasesItemsListRelationFilter
    PurchasesReturn?: PurchasesReturnListRelationFilter
  }, "id" | "purchaseNo">

  export type PurchasesOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    dueDate?: SortOrder
    note?: SortOrderInput | SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchasesCountOrderByAggregateInput
    _avg?: PurchasesAvgOrderByAggregateInput
    _max?: PurchasesMaxOrderByAggregateInput
    _min?: PurchasesMinOrderByAggregateInput
    _sum?: PurchasesSumOrderByAggregateInput
  }

  export type PurchasesScalarWhereWithAggregatesInput = {
    AND?: PurchasesScalarWhereWithAggregatesInput | PurchasesScalarWhereWithAggregatesInput[]
    OR?: PurchasesScalarWhereWithAggregatesInput[]
    NOT?: PurchasesScalarWhereWithAggregatesInput | PurchasesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Purchases"> | number
    purchaseNo?: StringWithAggregatesFilter<"Purchases"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalWithAggregatesFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeWithAggregatesFilter<"Purchases"> | Date | string
    note?: StringNullableWithAggregatesFilter<"Purchases"> | string | null
    supplier_id?: IntWithAggregatesFilter<"Purchases"> | number
    user_id?: IntWithAggregatesFilter<"Purchases"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Purchases"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchases"> | Date | string
  }

  export type PurchasesItemsWhereInput = {
    AND?: PurchasesItemsWhereInput | PurchasesItemsWhereInput[]
    OR?: PurchasesItemsWhereInput[]
    NOT?: PurchasesItemsWhereInput | PurchasesItemsWhereInput[]
    id?: IntFilter<"PurchasesItems"> | number
    quantity?: IntFilter<"PurchasesItems"> | number
    unitPrice?: DecimalFilter<"PurchasesItems"> | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFilter<"PurchasesItems"> | number
    product_id?: IntFilter<"PurchasesItems"> | number
    Purchases?: XOR<PurchasesScalarRelationFilter, PurchasesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    purchaseItemSerials?: PurchaseItemSerialsListRelationFilter
  }

  export type PurchasesItemsOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
    Purchases?: PurchasesOrderByWithRelationInput
    Products?: ProductsOrderByWithRelationInput
    purchaseItemSerials?: PurchaseItemSerialsOrderByRelationAggregateInput
  }

  export type PurchasesItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchasesItemsWhereInput | PurchasesItemsWhereInput[]
    OR?: PurchasesItemsWhereInput[]
    NOT?: PurchasesItemsWhereInput | PurchasesItemsWhereInput[]
    quantity?: IntFilter<"PurchasesItems"> | number
    unitPrice?: DecimalFilter<"PurchasesItems"> | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFilter<"PurchasesItems"> | number
    product_id?: IntFilter<"PurchasesItems"> | number
    Purchases?: XOR<PurchasesScalarRelationFilter, PurchasesWhereInput>
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    purchaseItemSerials?: PurchaseItemSerialsListRelationFilter
  }, "id">

  export type PurchasesItemsOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
    _count?: PurchasesItemsCountOrderByAggregateInput
    _avg?: PurchasesItemsAvgOrderByAggregateInput
    _max?: PurchasesItemsMaxOrderByAggregateInput
    _min?: PurchasesItemsMinOrderByAggregateInput
    _sum?: PurchasesItemsSumOrderByAggregateInput
  }

  export type PurchasesItemsScalarWhereWithAggregatesInput = {
    AND?: PurchasesItemsScalarWhereWithAggregatesInput | PurchasesItemsScalarWhereWithAggregatesInput[]
    OR?: PurchasesItemsScalarWhereWithAggregatesInput[]
    NOT?: PurchasesItemsScalarWhereWithAggregatesInput | PurchasesItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasesItems"> | number
    quantity?: IntWithAggregatesFilter<"PurchasesItems"> | number
    unitPrice?: DecimalWithAggregatesFilter<"PurchasesItems"> | Decimal | DecimalJsLike | number | string
    purchase_id?: IntWithAggregatesFilter<"PurchasesItems"> | number
    product_id?: IntWithAggregatesFilter<"PurchasesItems"> | number
  }

  export type PurchaseItemSerialsWhereInput = {
    AND?: PurchaseItemSerialsWhereInput | PurchaseItemSerialsWhereInput[]
    OR?: PurchaseItemSerialsWhereInput[]
    NOT?: PurchaseItemSerialsWhereInput | PurchaseItemSerialsWhereInput[]
    id?: IntFilter<"PurchaseItemSerials"> | number
    purchaseItem_id?: IntFilter<"PurchaseItemSerials"> | number
    serial_id?: IntFilter<"PurchaseItemSerials"> | number
    PurchasesItems?: XOR<PurchasesItemsScalarRelationFilter, PurchasesItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }

  export type PurchaseItemSerialsOrderByWithRelationInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
    PurchasesItems?: PurchasesItemsOrderByWithRelationInput
    ProductSerials?: ProductSerialsOrderByWithRelationInput
  }

  export type PurchaseItemSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseItemSerialsWhereInput | PurchaseItemSerialsWhereInput[]
    OR?: PurchaseItemSerialsWhereInput[]
    NOT?: PurchaseItemSerialsWhereInput | PurchaseItemSerialsWhereInput[]
    purchaseItem_id?: IntFilter<"PurchaseItemSerials"> | number
    serial_id?: IntFilter<"PurchaseItemSerials"> | number
    PurchasesItems?: XOR<PurchasesItemsScalarRelationFilter, PurchasesItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }, "id">

  export type PurchaseItemSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
    _count?: PurchaseItemSerialsCountOrderByAggregateInput
    _avg?: PurchaseItemSerialsAvgOrderByAggregateInput
    _max?: PurchaseItemSerialsMaxOrderByAggregateInput
    _min?: PurchaseItemSerialsMinOrderByAggregateInput
    _sum?: PurchaseItemSerialsSumOrderByAggregateInput
  }

  export type PurchaseItemSerialsScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemSerialsScalarWhereWithAggregatesInput | PurchaseItemSerialsScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemSerialsScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemSerialsScalarWhereWithAggregatesInput | PurchaseItemSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseItemSerials"> | number
    purchaseItem_id?: IntWithAggregatesFilter<"PurchaseItemSerials"> | number
    serial_id?: IntWithAggregatesFilter<"PurchaseItemSerials"> | number
  }

  export type PurchasesReturnWhereInput = {
    AND?: PurchasesReturnWhereInput | PurchasesReturnWhereInput[]
    OR?: PurchasesReturnWhereInput[]
    NOT?: PurchasesReturnWhereInput | PurchasesReturnWhereInput[]
    id?: IntFilter<"PurchasesReturn"> | number
    returnNo?: StringFilter<"PurchasesReturn"> | string
    totalPaid?: DecimalFilter<"PurchasesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"PurchasesReturn"> | string
    purchase_id?: IntFilter<"PurchasesReturn"> | number
    user_id?: IntFilter<"PurchasesReturn"> | number
    supplier_id?: IntFilter<"PurchasesReturn"> | number
    createdAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
    Purchases?: XOR<PurchasesScalarRelationFilter, PurchasesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Suppliers?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    PurchasesReturnItems?: PurchasesReturnItemsListRelationFilter
  }

  export type PurchasesReturnOrderByWithRelationInput = {
    id?: SortOrder
    returnNo?: SortOrder
    totalPaid?: SortOrder
    note?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Purchases?: PurchasesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    Suppliers?: SuppliersOrderByWithRelationInput
    PurchasesReturnItems?: PurchasesReturnItemsOrderByRelationAggregateInput
  }

  export type PurchasesReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    returnNo?: string
    AND?: PurchasesReturnWhereInput | PurchasesReturnWhereInput[]
    OR?: PurchasesReturnWhereInput[]
    NOT?: PurchasesReturnWhereInput | PurchasesReturnWhereInput[]
    totalPaid?: DecimalFilter<"PurchasesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"PurchasesReturn"> | string
    purchase_id?: IntFilter<"PurchasesReturn"> | number
    user_id?: IntFilter<"PurchasesReturn"> | number
    supplier_id?: IntFilter<"PurchasesReturn"> | number
    createdAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
    Purchases?: XOR<PurchasesScalarRelationFilter, PurchasesWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Suppliers?: XOR<SuppliersScalarRelationFilter, SuppliersWhereInput>
    PurchasesReturnItems?: PurchasesReturnItemsListRelationFilter
  }, "id" | "returnNo">

  export type PurchasesReturnOrderByWithAggregationInput = {
    id?: SortOrder
    returnNo?: SortOrder
    totalPaid?: SortOrder
    note?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchasesReturnCountOrderByAggregateInput
    _avg?: PurchasesReturnAvgOrderByAggregateInput
    _max?: PurchasesReturnMaxOrderByAggregateInput
    _min?: PurchasesReturnMinOrderByAggregateInput
    _sum?: PurchasesReturnSumOrderByAggregateInput
  }

  export type PurchasesReturnScalarWhereWithAggregatesInput = {
    AND?: PurchasesReturnScalarWhereWithAggregatesInput | PurchasesReturnScalarWhereWithAggregatesInput[]
    OR?: PurchasesReturnScalarWhereWithAggregatesInput[]
    NOT?: PurchasesReturnScalarWhereWithAggregatesInput | PurchasesReturnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasesReturn"> | number
    returnNo?: StringWithAggregatesFilter<"PurchasesReturn"> | string
    totalPaid?: DecimalWithAggregatesFilter<"PurchasesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringWithAggregatesFilter<"PurchasesReturn"> | string
    purchase_id?: IntWithAggregatesFilter<"PurchasesReturn"> | number
    user_id?: IntWithAggregatesFilter<"PurchasesReturn"> | number
    supplier_id?: IntWithAggregatesFilter<"PurchasesReturn"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchasesReturn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchasesReturn"> | Date | string
  }

  export type PurchasesReturnItemsWhereInput = {
    AND?: PurchasesReturnItemsWhereInput | PurchasesReturnItemsWhereInput[]
    OR?: PurchasesReturnItemsWhereInput[]
    NOT?: PurchasesReturnItemsWhereInput | PurchasesReturnItemsWhereInput[]
    id?: IntFilter<"PurchasesReturnItems"> | number
    quantity?: IntFilter<"PurchasesReturnItems"> | number
    unitPrice?: DecimalFilter<"PurchasesReturnItems"> | Decimal | DecimalJsLike | number | string
    products_id?: IntFilter<"PurchasesReturnItems"> | number
    purchaseReturn_id?: IntFilter<"PurchasesReturnItems"> | number
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    PurchasesReturn?: XOR<PurchasesReturnScalarRelationFilter, PurchasesReturnWhereInput>
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsListRelationFilter
  }

  export type PurchasesReturnItemsOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
    Products?: ProductsOrderByWithRelationInput
    PurchasesReturn?: PurchasesReturnOrderByWithRelationInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsOrderByRelationAggregateInput
  }

  export type PurchasesReturnItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchasesReturnItemsWhereInput | PurchasesReturnItemsWhereInput[]
    OR?: PurchasesReturnItemsWhereInput[]
    NOT?: PurchasesReturnItemsWhereInput | PurchasesReturnItemsWhereInput[]
    quantity?: IntFilter<"PurchasesReturnItems"> | number
    unitPrice?: DecimalFilter<"PurchasesReturnItems"> | Decimal | DecimalJsLike | number | string
    products_id?: IntFilter<"PurchasesReturnItems"> | number
    purchaseReturn_id?: IntFilter<"PurchasesReturnItems"> | number
    Products?: XOR<ProductsScalarRelationFilter, ProductsWhereInput>
    PurchasesReturn?: XOR<PurchasesReturnScalarRelationFilter, PurchasesReturnWhereInput>
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsListRelationFilter
  }, "id">

  export type PurchasesReturnItemsOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
    _count?: PurchasesReturnItemsCountOrderByAggregateInput
    _avg?: PurchasesReturnItemsAvgOrderByAggregateInput
    _max?: PurchasesReturnItemsMaxOrderByAggregateInput
    _min?: PurchasesReturnItemsMinOrderByAggregateInput
    _sum?: PurchasesReturnItemsSumOrderByAggregateInput
  }

  export type PurchasesReturnItemsScalarWhereWithAggregatesInput = {
    AND?: PurchasesReturnItemsScalarWhereWithAggregatesInput | PurchasesReturnItemsScalarWhereWithAggregatesInput[]
    OR?: PurchasesReturnItemsScalarWhereWithAggregatesInput[]
    NOT?: PurchasesReturnItemsScalarWhereWithAggregatesInput | PurchasesReturnItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchasesReturnItems"> | number
    quantity?: IntWithAggregatesFilter<"PurchasesReturnItems"> | number
    unitPrice?: DecimalWithAggregatesFilter<"PurchasesReturnItems"> | Decimal | DecimalJsLike | number | string
    products_id?: IntWithAggregatesFilter<"PurchasesReturnItems"> | number
    purchaseReturn_id?: IntWithAggregatesFilter<"PurchasesReturnItems"> | number
  }

  export type PurchaseReturnItemSerialsWhereInput = {
    AND?: PurchaseReturnItemSerialsWhereInput | PurchaseReturnItemSerialsWhereInput[]
    OR?: PurchaseReturnItemSerialsWhereInput[]
    NOT?: PurchaseReturnItemSerialsWhereInput | PurchaseReturnItemSerialsWhereInput[]
    id?: IntFilter<"PurchaseReturnItemSerials"> | number
    purchaseReturnItem_id?: IntFilter<"PurchaseReturnItemSerials"> | number
    serial_id?: IntFilter<"PurchaseReturnItemSerials"> | number
    PurchasesReturnItems?: XOR<PurchasesReturnItemsScalarRelationFilter, PurchasesReturnItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }

  export type PurchaseReturnItemSerialsOrderByWithRelationInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
    PurchasesReturnItems?: PurchasesReturnItemsOrderByWithRelationInput
    ProductSerials?: ProductSerialsOrderByWithRelationInput
  }

  export type PurchaseReturnItemSerialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseReturnItemSerialsWhereInput | PurchaseReturnItemSerialsWhereInput[]
    OR?: PurchaseReturnItemSerialsWhereInput[]
    NOT?: PurchaseReturnItemSerialsWhereInput | PurchaseReturnItemSerialsWhereInput[]
    purchaseReturnItem_id?: IntFilter<"PurchaseReturnItemSerials"> | number
    serial_id?: IntFilter<"PurchaseReturnItemSerials"> | number
    PurchasesReturnItems?: XOR<PurchasesReturnItemsScalarRelationFilter, PurchasesReturnItemsWhereInput>
    ProductSerials?: XOR<ProductSerialsScalarRelationFilter, ProductSerialsWhereInput>
  }, "id">

  export type PurchaseReturnItemSerialsOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
    _count?: PurchaseReturnItemSerialsCountOrderByAggregateInput
    _avg?: PurchaseReturnItemSerialsAvgOrderByAggregateInput
    _max?: PurchaseReturnItemSerialsMaxOrderByAggregateInput
    _min?: PurchaseReturnItemSerialsMinOrderByAggregateInput
    _sum?: PurchaseReturnItemSerialsSumOrderByAggregateInput
  }

  export type PurchaseReturnItemSerialsScalarWhereWithAggregatesInput = {
    AND?: PurchaseReturnItemSerialsScalarWhereWithAggregatesInput | PurchaseReturnItemSerialsScalarWhereWithAggregatesInput[]
    OR?: PurchaseReturnItemSerialsScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReturnItemSerialsScalarWhereWithAggregatesInput | PurchaseReturnItemSerialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseReturnItemSerials"> | number
    purchaseReturnItem_id?: IntWithAggregatesFilter<"PurchaseReturnItemSerials"> | number
    serial_id?: IntWithAggregatesFilter<"PurchaseReturnItemSerials"> | number
  }

  export type ServicesWhereInput = {
    AND?: ServicesWhereInput | ServicesWhereInput[]
    OR?: ServicesWhereInput[]
    NOT?: ServicesWhereInput | ServicesWhereInput[]
    id?: IntFilter<"Services"> | number
    serviceNo?: StringFilter<"Services"> | string
    serviceProductName?: StringFilter<"Services"> | string
    serviceDescription?: StringFilter<"Services"> | string
    serviceCost?: DecimalFilter<"Services"> | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFilter<"Services"> | string
    customer_id?: IntNullableFilter<"Services"> | number | null
    user_id?: IntNullableFilter<"Services"> | number | null
    createdAt?: DateTimeFilter<"Services"> | Date | string
    updatedAt?: DateTimeFilter<"Services"> | Date | string
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }

  export type ServicesOrderByWithRelationInput = {
    id?: SortOrder
    serviceNo?: SortOrder
    serviceProductName?: SortOrder
    serviceDescription?: SortOrder
    serviceCost?: SortOrder
    serviceStatus?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Customers?: CustomersOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceNo?: string
    AND?: ServicesWhereInput | ServicesWhereInput[]
    OR?: ServicesWhereInput[]
    NOT?: ServicesWhereInput | ServicesWhereInput[]
    serviceProductName?: StringFilter<"Services"> | string
    serviceDescription?: StringFilter<"Services"> | string
    serviceCost?: DecimalFilter<"Services"> | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFilter<"Services"> | string
    customer_id?: IntNullableFilter<"Services"> | number | null
    user_id?: IntNullableFilter<"Services"> | number | null
    createdAt?: DateTimeFilter<"Services"> | Date | string
    updatedAt?: DateTimeFilter<"Services"> | Date | string
    Customers?: XOR<CustomersNullableScalarRelationFilter, CustomersWhereInput> | null
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
  }, "id" | "serviceNo">

  export type ServicesOrderByWithAggregationInput = {
    id?: SortOrder
    serviceNo?: SortOrder
    serviceProductName?: SortOrder
    serviceDescription?: SortOrder
    serviceCost?: SortOrder
    serviceStatus?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicesCountOrderByAggregateInput
    _avg?: ServicesAvgOrderByAggregateInput
    _max?: ServicesMaxOrderByAggregateInput
    _min?: ServicesMinOrderByAggregateInput
    _sum?: ServicesSumOrderByAggregateInput
  }

  export type ServicesScalarWhereWithAggregatesInput = {
    AND?: ServicesScalarWhereWithAggregatesInput | ServicesScalarWhereWithAggregatesInput[]
    OR?: ServicesScalarWhereWithAggregatesInput[]
    NOT?: ServicesScalarWhereWithAggregatesInput | ServicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Services"> | number
    serviceNo?: StringWithAggregatesFilter<"Services"> | string
    serviceProductName?: StringWithAggregatesFilter<"Services"> | string
    serviceDescription?: StringWithAggregatesFilter<"Services"> | string
    serviceCost?: DecimalWithAggregatesFilter<"Services"> | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringWithAggregatesFilter<"Services"> | string
    customer_id?: IntNullableWithAggregatesFilter<"Services"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"Services"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Services"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Services"> | Date | string
  }

  export type PermissionsCreateInput = {
    name: string
    description?: string | null
    rolePermissions?: RolePermissionsCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    rolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type PermissionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionsCreateInput = {
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Roles: RolesCreateNestedOneWithoutRolePermissionsInput
    Permissions: PermissionsCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateInput = {
    id?: number
    role_id: number
    permission_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsUpdateInput = {
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
    Roles?: RolesUpdateOneRequiredWithoutRolePermissionsNestedInput
    Permissions?: PermissionsUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionsCreateManyInput = {
    id?: number
    role_id: number
    permission_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsUpdateManyMutationInput = {
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolesCreateInput = {
    name: string
    Users?: UsersCreateNestedManyWithoutRolesInput
    rolePermissions?: RolePermissionsCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    name: string
    Users?: UsersUncheckedCreateNestedManyWithoutRolesInput
    rolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateManyWithoutRolesNestedInput
    rolePermissions?: RolePermissionsUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Users?: UsersUncheckedUpdateManyWithoutRolesNestedInput
    rolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    name: string
  }

  export type RolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    token: string
    expiresAt: Date | string
    user: UsersCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type SessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsersUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomersCreateInput = {
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesCreateNestedManyWithoutCustomersInput
    Services?: ServicesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesUncheckedCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutCustomersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUncheckedUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
  }

  export type CustomersUpdateManyMutationInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuppliersCreateInput = {
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesCreateNestedManyWithoutSuppliersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutSuppliersInput
    products?: ProductsCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUncheckedCreateInput = {
    id?: number
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutSuppliersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutSuppliersInput
    products?: ProductsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUpdateInput = {
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUpdateManyWithoutSuppliersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUncheckedUpdateManyWithoutSuppliersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersCreateManyInput = {
    id?: number
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
  }

  export type SuppliersUpdateManyMutationInput = {
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuppliersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriesCreateInput = {
    name: string
    Products?: ProductsCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: number
    name: string
    Products?: ProductsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Products?: ProductsUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Products?: ProductsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesCreateManyInput = {
    id?: number
    name: string
  }

  export type CategoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductsCreateInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsCreateManyInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsUpdateManyMutationInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSerialsCreateInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsCreateManyInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSerialsUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesCreateInput = {
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutExpensesInput
  }

  export type ExpensesUncheckedCreateInput = {
    id?: number
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpensesUpdateInput = {
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpensesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesCreateManyInput = {
    id?: number
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpensesUpdateManyMutationInput = {
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesCreateInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutSalesInput
    Users?: UsersCreateNestedOneWithoutSalesInput
    SalesItems?: SalesItemsCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesUpdateInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutSalesNestedInput
    Users?: UsersUpdateOneWithoutSalesNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type SalesCreateManyInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesUpdateManyMutationInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    Sales?: SalesCreateNestedOneWithoutSalesItemsInput
    Products?: ProductsCreateNestedOneWithoutSalesItemsInput
    salesItemSerials?: SalesItemSerialsCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    sales_id: number
    product_id: number
    salesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Sales?: SalesUpdateOneWithoutSalesItemsNestedInput
    Products?: ProductsUpdateOneWithoutSalesItemsNestedInput
    salesItemSerials?: SalesItemSerialsUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    salesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsCreateManyInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    sales_id: number
    product_id: number
  }

  export type SalesItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SalesItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesItemSerialsCreateInput = {
    SalesItems: SalesItemsCreateNestedOneWithoutSalesItemSerialsInput
    ProductSerials: ProductSerialsCreateNestedOneWithoutSalesItemSerialsInput
  }

  export type SalesItemSerialsUncheckedCreateInput = {
    id?: number
    salesItem_id: number
    serial_id: number
  }

  export type SalesItemSerialsUpdateInput = {
    SalesItems?: SalesItemsUpdateOneRequiredWithoutSalesItemSerialsNestedInput
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutSalesItemSerialsNestedInput
  }

  export type SalesItemSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesItemSerialsCreateManyInput = {
    id?: number
    salesItem_id: number
    serial_id: number
  }

  export type SalesItemSerialsUpdateManyMutationInput = {

  }

  export type SalesItemSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnCreateInput = {
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales: SalesCreateNestedOneWithoutSalesReturnInput
    Users: UsersCreateNestedOneWithoutSalesReturnInput
    Customers: CustomersCreateNestedOneWithoutSalesReturnInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnUncheckedCreateInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnUpdateInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneRequiredWithoutSalesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutSalesReturnNestedInput
    Customers?: CustomersUpdateOneRequiredWithoutSalesReturnNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnCreateManyInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnUpdateManyMutationInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnItemsCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products?: ProductsCreateNestedOneWithoutSalesReturnItemsInput
    SalesReturn?: SalesReturnCreateNestedOneWithoutSalesReturnItemsInput
    productSerials?: ProductSerialsCreateNestedOneWithoutSalesReturnItemsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUncheckedCreateInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    salesReturn_id: number
    productSerialsId?: number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneWithoutSalesReturnItemsNestedInput
    SalesReturn?: SalesReturnUpdateOneWithoutSalesReturnItemsNestedInput
    productSerials?: ProductSerialsUpdateOneWithoutSalesReturnItemsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsCreateManyInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    salesReturn_id: number
    productSerialsId?: number | null
  }

  export type SalesReturnItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesReturnItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalesReturnItemSerialsCreateInput = {
    SalesReturnItems: SalesReturnItemsCreateNestedOneWithoutSalesReturnItemSerialsInput
    ProductSerials: ProductSerialsCreateNestedOneWithoutSalesReturnItemSerialsInput
  }

  export type SalesReturnItemSerialsUncheckedCreateInput = {
    id?: number
    salesReturnItem_id: number
    serial_id: number
  }

  export type SalesReturnItemSerialsUpdateInput = {
    SalesReturnItems?: SalesReturnItemsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput
  }

  export type SalesReturnItemSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesReturnItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemSerialsCreateManyInput = {
    id?: number
    salesReturnItem_id: number
    serial_id: number
  }

  export type SalesReturnItemSerialsUpdateManyMutationInput = {

  }

  export type SalesReturnItemSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesReturnItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangesCreateInput = {
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales?: SalesCreateNestedOneWithoutExchangesInput
    Users?: UsersCreateNestedOneWithoutExchangesInput
    Customers?: CustomersCreateNestedOneWithoutExchangesInput
    ExchangeItems?: ExchangesItemsCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesUncheckedCreateInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ExchangeItems?: ExchangesItemsUncheckedCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesUpdateInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneWithoutExchangesNestedInput
    Users?: UsersUpdateOneWithoutExchangesNestedInput
    Customers?: CustomersUpdateOneWithoutExchangesNestedInput
    ExchangeItems?: ExchangesItemsUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExchangeItems?: ExchangesItemsUncheckedUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesCreateManyInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesUpdateManyMutationInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesItemsCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oldProduct?: ProductsCreateNestedOneWithoutExchangeItemsOldInput
    newProduct?: ProductsCreateNestedOneWithoutExchangeItemsNewInput
    Exchanges?: ExchangesCreateNestedOneWithoutExchangeItemsInput
    exchangeItemSerials?: ExchangeItemSerialsCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsUncheckedCreateInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    newProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oldProduct?: ProductsUpdateOneWithoutExchangeItemsOldNestedInput
    newProduct?: ProductsUpdateOneWithoutExchangeItemsNewNestedInput
    Exchanges?: ExchangesUpdateOneWithoutExchangeItemsNestedInput
    exchangeItemSerials?: ExchangeItemSerialsUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    newProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsCreateManyInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    newProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    newProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeItemSerialsCreateInput = {
    ExchangesItems: ExchangesItemsCreateNestedOneWithoutExchangeItemSerialsInput
    OldProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsOldInput
    NewProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsNewInput
  }

  export type ExchangeItemSerialsUncheckedCreateInput = {
    id?: number
    exchangeItem_id: number
    serial_id_old: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsUpdateInput = {
    ExchangesItems?: ExchangesItemsUpdateOneRequiredWithoutExchangeItemSerialsNestedInput
    OldProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsOldNestedInput
    NewProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsNewNestedInput
  }

  export type ExchangeItemSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsCreateManyInput = {
    id?: number
    exchangeItem_id: number
    serial_id_old: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsUpdateManyMutationInput = {

  }

  export type ExchangeItemSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesCreateInput = {
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesInput
    Users: UsersCreateNestedOneWithoutPurchasesInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUncheckedCreateInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUpdateInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesCreateManyInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesUpdateManyMutationInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesItemsCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesItemsInput
    Products: ProductsCreateNestedOneWithoutPurchasesItemsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsUncheckedCreateInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchase_id: number
    product_id: number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesItemsNestedInput
    Products?: ProductsUpdateOneRequiredWithoutPurchasesItemsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsCreateManyInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchase_id: number
    product_id: number
  }

  export type PurchasesItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseItemSerialsCreateInput = {
    PurchasesItems: PurchasesItemsCreateNestedOneWithoutPurchaseItemSerialsInput
    ProductSerials: ProductSerialsCreateNestedOneWithoutPurchaseItemSerialsInput
  }

  export type PurchaseItemSerialsUncheckedCreateInput = {
    id?: number
    purchaseItem_id: number
    serial_id: number
  }

  export type PurchaseItemSerialsUpdateInput = {
    PurchasesItems?: PurchasesItemsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput
  }

  export type PurchaseItemSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseItemSerialsCreateManyInput = {
    id?: number
    purchaseItem_id: number
    serial_id: number
  }

  export type PurchaseItemSerialsUpdateManyMutationInput = {

  }

  export type PurchaseItemSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesReturnCreateInput = {
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesReturnInput
    Users: UsersCreateNestedOneWithoutPurchasesReturnInput
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesReturnInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUncheckedCreateInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    user_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUpdateInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnCreateManyInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    user_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesReturnUpdateManyMutationInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesReturnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesReturnItemsCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products: ProductsCreateNestedOneWithoutPurchasesReturnItemsInput
    PurchasesReturn: PurchasesReturnCreateNestedOneWithoutPurchasesReturnItemsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsUncheckedCreateInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    products_id: number
    purchaseReturn_id: number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
    PurchasesReturn?: PurchasesReturnUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    products_id?: IntFieldUpdateOperationsInput | number
    purchaseReturn_id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsCreateManyInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    products_id: number
    purchaseReturn_id: number
  }

  export type PurchasesReturnItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasesReturnItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    products_id?: IntFieldUpdateOperationsInput | number
    purchaseReturn_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsCreateInput = {
    PurchasesReturnItems: PurchasesReturnItemsCreateNestedOneWithoutPurchaseReturnItemSerialsInput
    ProductSerials: ProductSerialsCreateNestedOneWithoutPurchaseReturnItemSerialsInput
  }

  export type PurchaseReturnItemSerialsUncheckedCreateInput = {
    id?: number
    purchaseReturnItem_id: number
    serial_id: number
  }

  export type PurchaseReturnItemSerialsUpdateInput = {
    PurchasesReturnItems?: PurchasesReturnItemsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsCreateManyInput = {
    id?: number
    purchaseReturnItem_id: number
    serial_id: number
  }

  export type PurchaseReturnItemSerialsUpdateManyMutationInput = {

  }

  export type PurchaseReturnItemSerialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItem_id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type ServicesCreateInput = {
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutServicesInput
    Users?: UsersCreateNestedOneWithoutServicesInput
  }

  export type ServicesUncheckedCreateInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    customer_id?: number | null
    user_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesUpdateInput = {
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutServicesNestedInput
    Users?: UsersUpdateOneWithoutServicesNestedInput
  }

  export type ServicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesCreateManyInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    customer_id?: number | null
    user_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesUpdateManyMutationInput = {
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RolePermissionsListRelationFilter = {
    every?: RolePermissionsWhereInput
    some?: RolePermissionsWhereInput
    none?: RolePermissionsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolePermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PermissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PermissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RolesScalarRelationFilter = {
    is?: RolesWhereInput
    isNot?: RolesWhereInput
  }

  export type PermissionsScalarRelationFilter = {
    is?: PermissionsWhereInput
    isNot?: PermissionsWhereInput
  }

  export type RolePermissionsRole_idPermission_idCompoundUniqueInput = {
    role_id: number
    permission_id: number
  }

  export type RolePermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
    can_view?: SortOrder
    can_create?: SortOrder
    can_edit?: SortOrder
    can_delete?: SortOrder
  }

  export type RolePermissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RolePermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
    can_view?: SortOrder
    can_create?: SortOrder
    can_edit?: SortOrder
    can_delete?: SortOrder
  }

  export type RolePermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
    can_view?: SortOrder
    can_create?: SortOrder
    can_edit?: SortOrder
    can_delete?: SortOrder
  }

  export type RolePermissionsSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RolesNullableScalarRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SalesListRelationFilter = {
    every?: SalesWhereInput
    some?: SalesWhereInput
    none?: SalesWhereInput
  }

  export type SalesReturnListRelationFilter = {
    every?: SalesReturnWhereInput
    some?: SalesReturnWhereInput
    none?: SalesReturnWhereInput
  }

  export type ExchangesListRelationFilter = {
    every?: ExchangesWhereInput
    some?: ExchangesWhereInput
    none?: ExchangesWhereInput
  }

  export type PurchasesListRelationFilter = {
    every?: PurchasesWhereInput
    some?: PurchasesWhereInput
    none?: PurchasesWhereInput
  }

  export type PurchasesReturnListRelationFilter = {
    every?: PurchasesReturnWhereInput
    some?: PurchasesReturnWhereInput
    none?: PurchasesReturnWhereInput
  }

  export type ServicesListRelationFilter = {
    every?: ServicesWhereInput
    some?: ServicesWhereInput
    none?: ServicesWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: ProductsWhereInput
    some?: ProductsWhereInput
    none?: ProductsWhereInput
  }

  export type ExpensesListRelationFilter = {
    every?: ExpensesWhereInput
    some?: ExpensesWhereInput
    none?: ExpensesWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpensesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissionOverrides?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    custId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    custId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    custId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuppliersCountOrderByAggregateInput = {
    id?: SortOrder
    suppId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type SuppliersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SuppliersMaxOrderByAggregateInput = {
    id?: SortOrder
    suppId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type SuppliersMinOrderByAggregateInput = {
    id?: SortOrder
    suppId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type SuppliersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: CategoriesWhereInput | null
    isNot?: CategoriesWhereInput | null
  }

  export type SuppliersNullableScalarRelationFilter = {
    is?: SuppliersWhereInput | null
    isNot?: SuppliersWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type SalesItemsListRelationFilter = {
    every?: SalesItemsWhereInput
    some?: SalesItemsWhereInput
    none?: SalesItemsWhereInput
  }

  export type SalesReturnItemsListRelationFilter = {
    every?: SalesReturnItemsWhereInput
    some?: SalesReturnItemsWhereInput
    none?: SalesReturnItemsWhereInput
  }

  export type ExchangesItemsListRelationFilter = {
    every?: ExchangesItemsWhereInput
    some?: ExchangesItemsWhereInput
    none?: ExchangesItemsWhereInput
  }

  export type PurchasesItemsListRelationFilter = {
    every?: PurchasesItemsWhereInput
    some?: PurchasesItemsWhereInput
    none?: PurchasesItemsWhereInput
  }

  export type PurchasesReturnItemsListRelationFilter = {
    every?: PurchasesReturnItemsWhereInput
    some?: PurchasesReturnItemsWhereInput
    none?: PurchasesReturnItemsWhereInput
  }

  export type ProductSerialsListRelationFilter = {
    every?: ProductSerialsWhereInput
    some?: ProductSerialsWhereInput
    none?: ProductSerialsWhereInput
  }

  export type SalesItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReturnItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangesItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasesReturnItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    specification?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    useIndividualSerials?: SortOrder
    productType?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    specification?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    useIndividualSerials?: SortOrder
    productType?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    productCode?: SortOrder
    name?: SortOrder
    specification?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    useIndividualSerials?: SortOrder
    productType?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    category_id?: SortOrder
    supplier_id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSerialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SerialStatus | EnumSerialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSerialStatusFilter<$PrismaModel> | $Enums.SerialStatus
  }

  export type EnumWarrantyFilter<$PrismaModel = never> = {
    equals?: $Enums.Warranty | EnumWarrantyFieldRefInput<$PrismaModel>
    in?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    not?: NestedEnumWarrantyFilter<$PrismaModel> | $Enums.Warranty
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type SalesItemSerialsListRelationFilter = {
    every?: SalesItemSerialsWhereInput
    some?: SalesItemSerialsWhereInput
    none?: SalesItemSerialsWhereInput
  }

  export type SalesReturnItemSerialsListRelationFilter = {
    every?: SalesReturnItemSerialsWhereInput
    some?: SalesReturnItemSerialsWhereInput
    none?: SalesReturnItemSerialsWhereInput
  }

  export type PurchaseItemSerialsListRelationFilter = {
    every?: PurchaseItemSerialsWhereInput
    some?: PurchaseItemSerialsWhereInput
    none?: PurchaseItemSerialsWhereInput
  }

  export type PurchaseReturnItemSerialsListRelationFilter = {
    every?: PurchaseReturnItemSerialsWhereInput
    some?: PurchaseReturnItemSerialsWhereInput
    none?: PurchaseReturnItemSerialsWhereInput
  }

  export type ExchangeItemSerialsListRelationFilter = {
    every?: ExchangeItemSerialsWhereInput
    some?: ExchangeItemSerialsWhereInput
    none?: ExchangeItemSerialsWhereInput
  }

  export type SalesItemSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReturnItemSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseItemSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReturnItemSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangeItemSerialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    product_id?: SortOrder
    status?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
  }

  export type ProductSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    product_id?: SortOrder
    status?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    product_id?: SortOrder
    status?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
  }

  export type EnumSerialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SerialStatus | EnumSerialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSerialStatusWithAggregatesFilter<$PrismaModel> | $Enums.SerialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSerialStatusFilter<$PrismaModel>
    _max?: NestedEnumSerialStatusFilter<$PrismaModel>
  }

  export type EnumWarrantyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Warranty | EnumWarrantyFieldRefInput<$PrismaModel>
    in?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    not?: NestedEnumWarrantyWithAggregatesFilter<$PrismaModel> | $Enums.Warranty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWarrantyFilter<$PrismaModel>
    _max?: NestedEnumWarrantyFilter<$PrismaModel>
  }

  export type ExpensesCountOrderByAggregateInput = {
    id?: SortOrder
    expenseNo?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpensesAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
  }

  export type ExpensesMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseNo?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpensesMinOrderByAggregateInput = {
    id?: SortOrder
    expenseNo?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpensesSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    user_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomersNullableScalarRelationFilter = {
    is?: CustomersWhereInput | null
    isNot?: CustomersWhereInput | null
  }

  export type SalesCountOrderByAggregateInput = {
    id?: SortOrder
    saleNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
  }

  export type SalesMaxOrderByAggregateInput = {
    id?: SortOrder
    saleNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesMinOrderByAggregateInput = {
    id?: SortOrder
    saleNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    totaldiscount?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SalesNullableScalarRelationFilter = {
    is?: SalesWhereInput | null
    isNot?: SalesWhereInput | null
  }

  export type SalesItemsCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
  }

  export type SalesItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
  }

  export type SalesItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
  }

  export type SalesItemsMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
  }

  export type SalesItemsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    sales_id?: SortOrder
    product_id?: SortOrder
  }

  export type SalesItemsScalarRelationFilter = {
    is?: SalesItemsWhereInput
    isNot?: SalesItemsWhereInput
  }

  export type ProductSerialsScalarRelationFilter = {
    is?: ProductSerialsWhereInput
    isNot?: ProductSerialsWhereInput
  }

  export type SalesItemSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesItemSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesItemSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesItemSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesItemSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    salesItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesScalarRelationFilter = {
    is?: SalesWhereInput
    isNot?: SalesWhereInput
  }

  export type CustomersScalarRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type SalesReturnCountOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    total_payback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnAvgOrderByAggregateInput = {
    id?: SortOrder
    total_payback?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type SalesReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    total_payback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnMinOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    total_payback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnSumOrderByAggregateInput = {
    id?: SortOrder
    total_payback?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type SalesReturnNullableScalarRelationFilter = {
    is?: SalesReturnWhereInput | null
    isNot?: SalesReturnWhereInput | null
  }

  export type ProductSerialsNullableScalarRelationFilter = {
    is?: ProductSerialsWhereInput | null
    isNot?: ProductSerialsWhereInput | null
  }

  export type SalesReturnItemsCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrder
  }

  export type SalesReturnItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrder
  }

  export type SalesReturnItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrder
  }

  export type SalesReturnItemsMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrder
  }

  export type SalesReturnItemsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    product_id?: SortOrder
    salesReturn_id?: SortOrder
    productSerialsId?: SortOrder
  }

  export type SalesReturnItemsScalarRelationFilter = {
    is?: SalesReturnItemsWhereInput
    isNot?: SalesReturnItemsWhereInput
  }

  export type SalesReturnItemSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesReturnItemSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesReturnItemSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesReturnItemSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type SalesReturnItemSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    salesReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type ExchangesCountOrderByAggregateInput = {
    id?: SortOrder
    exchangeNo?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesAvgOrderByAggregateInput = {
    id?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type ExchangesMaxOrderByAggregateInput = {
    id?: SortOrder
    exchangeNo?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesMinOrderByAggregateInput = {
    id?: SortOrder
    exchangeNo?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    note?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesSumOrderByAggregateInput = {
    id?: SortOrder
    totalPaid?: SortOrder
    totalPayback?: SortOrder
    sales_id?: SortOrder
    user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type ExchangesNullableScalarRelationFilter = {
    is?: ExchangesWhereInput | null
    isNot?: ExchangesWhereInput | null
  }

  export type ExchangesItemsCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    note?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrder
  }

  export type ExchangesItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    note?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesItemsMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    note?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExchangesItemsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    oldProduct_id?: SortOrder
    newProduct_id?: SortOrder
    exchangeId?: SortOrder
  }

  export type ExchangesItemsScalarRelationFilter = {
    is?: ExchangesItemsWhereInput
    isNot?: ExchangesItemsWhereInput
  }

  export type ExchangeItemSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
  }

  export type ExchangeItemSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
  }

  export type ExchangeItemSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
  }

  export type ExchangeItemSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
  }

  export type ExchangeItemSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    exchangeItem_id?: SortOrder
    serial_id_old?: SortOrder
    serial_id_new?: SortOrder
  }

  export type SuppliersScalarRelationFilter = {
    is?: SuppliersWhereInput
    isNot?: SuppliersWhereInput
  }

  export type PurchasesCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    dueDate?: SortOrder
    note?: SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
  }

  export type PurchasesMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    dueDate?: SortOrder
    note?: SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseNo?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    dueDate?: SortOrder
    note?: SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    totalPaid?: SortOrder
    supplier_id?: SortOrder
    user_id?: SortOrder
  }

  export type PurchasesScalarRelationFilter = {
    is?: PurchasesWhereInput
    isNot?: PurchasesWhereInput
  }

  export type ProductsScalarRelationFilter = {
    is?: ProductsWhereInput
    isNot?: ProductsWhereInput
  }

  export type PurchasesItemsCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
  }

  export type PurchasesItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
  }

  export type PurchasesItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
  }

  export type PurchasesItemsMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
  }

  export type PurchasesItemsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    purchase_id?: SortOrder
    product_id?: SortOrder
  }

  export type PurchasesItemsScalarRelationFilter = {
    is?: PurchasesItemsWhereInput
    isNot?: PurchasesItemsWhereInput
  }

  export type PurchaseItemSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseItemSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseItemSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseItemSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseItemSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchasesReturnCountOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    totalPaid?: SortOrder
    note?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesReturnAvgOrderByAggregateInput = {
    id?: SortOrder
    totalPaid?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type PurchasesReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    totalPaid?: SortOrder
    note?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesReturnMinOrderByAggregateInput = {
    id?: SortOrder
    returnNo?: SortOrder
    totalPaid?: SortOrder
    note?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchasesReturnSumOrderByAggregateInput = {
    id?: SortOrder
    totalPaid?: SortOrder
    purchase_id?: SortOrder
    user_id?: SortOrder
    supplier_id?: SortOrder
  }

  export type PurchasesReturnScalarRelationFilter = {
    is?: PurchasesReturnWhereInput
    isNot?: PurchasesReturnWhereInput
  }

  export type PurchasesReturnItemsCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
  }

  export type PurchasesReturnItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
  }

  export type PurchasesReturnItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
  }

  export type PurchasesReturnItemsMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
  }

  export type PurchasesReturnItemsSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    products_id?: SortOrder
    purchaseReturn_id?: SortOrder
  }

  export type PurchasesReturnItemsScalarRelationFilter = {
    is?: PurchasesReturnItemsWhereInput
    isNot?: PurchasesReturnItemsWhereInput
  }

  export type PurchaseReturnItemSerialsCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseReturnItemSerialsAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseReturnItemSerialsMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseReturnItemSerialsMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type PurchaseReturnItemSerialsSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseReturnItem_id?: SortOrder
    serial_id?: SortOrder
  }

  export type ServicesCountOrderByAggregateInput = {
    id?: SortOrder
    serviceNo?: SortOrder
    serviceProductName?: SortOrder
    serviceDescription?: SortOrder
    serviceCost?: SortOrder
    serviceStatus?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceCost?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
  }

  export type ServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceNo?: SortOrder
    serviceProductName?: SortOrder
    serviceDescription?: SortOrder
    serviceCost?: SortOrder
    serviceStatus?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesMinOrderByAggregateInput = {
    id?: SortOrder
    serviceNo?: SortOrder
    serviceProductName?: SortOrder
    serviceDescription?: SortOrder
    serviceCost?: SortOrder
    serviceStatus?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesSumOrderByAggregateInput = {
    id?: SortOrder
    serviceCost?: SortOrder
    customer_id?: SortOrder
    user_id?: SortOrder
  }

  export type RolePermissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput> | RolePermissionsCreateWithoutPermissionsInput[] | RolePermissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionsInput | RolePermissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: RolePermissionsCreateManyPermissionsInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type RolePermissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput> | RolePermissionsCreateWithoutPermissionsInput[] | RolePermissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionsInput | RolePermissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: RolePermissionsCreateManyPermissionsInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RolePermissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput> | RolePermissionsCreateWithoutPermissionsInput[] | RolePermissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionsInput | RolePermissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutPermissionsInput | RolePermissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: RolePermissionsCreateManyPermissionsInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutPermissionsInput | RolePermissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutPermissionsInput | RolePermissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePermissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput> | RolePermissionsCreateWithoutPermissionsInput[] | RolePermissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionsInput | RolePermissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutPermissionsInput | RolePermissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: RolePermissionsCreateManyPermissionsInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutPermissionsInput | RolePermissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutPermissionsInput | RolePermissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type RolesCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RolesCreateWithoutRolePermissionsInput, RolesUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RolesCreateOrConnectWithoutRolePermissionsInput
    connect?: RolesWhereUniqueInput
  }

  export type PermissionsCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionsCreateWithoutRolePermissionsInput, PermissionsUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RolesUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RolesCreateWithoutRolePermissionsInput, RolesUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RolesCreateOrConnectWithoutRolePermissionsInput
    upsert?: RolesUpsertWithoutRolePermissionsInput
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutRolePermissionsInput, RolesUpdateWithoutRolePermissionsInput>, RolesUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionsUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionsCreateWithoutRolePermissionsInput, PermissionsUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionsUpsertWithoutRolePermissionsInput
    connect?: PermissionsWhereUniqueInput
    update?: XOR<XOR<PermissionsUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionsUpdateWithoutRolePermissionsInput>, PermissionsUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UsersCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type RolePermissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput> | RolePermissionsCreateWithoutRolesInput[] | RolePermissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRolesInput | RolePermissionsCreateOrConnectWithoutRolesInput[]
    createMany?: RolePermissionsCreateManyRolesInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type RolePermissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput> | RolePermissionsCreateWithoutRolesInput[] | RolePermissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRolesInput | RolePermissionsCreateOrConnectWithoutRolesInput[]
    createMany?: RolePermissionsCreateManyRolesInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRolesInput | UsersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRolesInput | UsersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRolesInput | UsersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type RolePermissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput> | RolePermissionsCreateWithoutRolesInput[] | RolePermissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRolesInput | RolePermissionsCreateOrConnectWithoutRolesInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutRolesInput | RolePermissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: RolePermissionsCreateManyRolesInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutRolesInput | RolePermissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutRolesInput | RolePermissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRolesInput | UsersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRolesInput | UsersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRolesInput | UsersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type RolePermissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput> | RolePermissionsCreateWithoutRolesInput[] | RolePermissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRolesInput | RolePermissionsCreateOrConnectWithoutRolesInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutRolesInput | RolePermissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: RolePermissionsCreateManyRolesInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutRolesInput | RolePermissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutRolesInput | RolePermissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutSessionInput = {
    create?: XOR<UsersCreateWithoutSessionInput, UsersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSessionInput
    connect?: UsersWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UsersCreateWithoutSessionInput, UsersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSessionInput
    upsert?: UsersUpsertWithoutSessionInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSessionInput, UsersUpdateWithoutSessionInput>, UsersUncheckedUpdateWithoutSessionInput>
  }

  export type RolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    connect?: RolesWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SalesCreateNestedManyWithoutUsersInput = {
    create?: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput> | SalesCreateWithoutUsersInput[] | SalesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutUsersInput | SalesCreateOrConnectWithoutUsersInput[]
    createMany?: SalesCreateManyUsersInputEnvelope
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
  }

  export type SalesReturnCreateNestedManyWithoutUsersInput = {
    create?: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput> | SalesReturnCreateWithoutUsersInput[] | SalesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutUsersInput | SalesReturnCreateOrConnectWithoutUsersInput[]
    createMany?: SalesReturnCreateManyUsersInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput> | ExchangesCreateWithoutUsersInput[] | ExchangesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutUsersInput | ExchangesCreateOrConnectWithoutUsersInput[]
    createMany?: ExchangesCreateManyUsersInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type PurchasesCreateNestedManyWithoutUsersInput = {
    create?: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput> | PurchasesCreateWithoutUsersInput[] | PurchasesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutUsersInput | PurchasesCreateOrConnectWithoutUsersInput[]
    createMany?: PurchasesCreateManyUsersInputEnvelope
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
  }

  export type PurchasesReturnCreateNestedManyWithoutUsersInput = {
    create?: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput> | PurchasesReturnCreateWithoutUsersInput[] | PurchasesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutUsersInput | PurchasesReturnCreateOrConnectWithoutUsersInput[]
    createMany?: PurchasesReturnCreateManyUsersInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type ServicesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput> | ServicesCreateWithoutUsersInput[] | ServicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutUsersInput | ServicesCreateOrConnectWithoutUsersInput[]
    createMany?: ServicesCreateManyUsersInputEnvelope
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
  }

  export type ProductsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput> | ProductsCreateWithoutCreatorInput[] | ProductsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCreatorInput | ProductsCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductsCreateManyCreatorInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput> | ProductsCreateWithoutUpdaterInput[] | ProductsUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutUpdaterInput | ProductsCreateOrConnectWithoutUpdaterInput[]
    createMany?: ProductsCreateManyUpdaterInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ExpensesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput> | ExpensesCreateWithoutUsersInput[] | ExpensesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpensesCreateOrConnectWithoutUsersInput | ExpensesCreateOrConnectWithoutUsersInput[]
    createMany?: ExpensesCreateManyUsersInputEnvelope
    connect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SalesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput> | SalesCreateWithoutUsersInput[] | SalesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutUsersInput | SalesCreateOrConnectWithoutUsersInput[]
    createMany?: SalesCreateManyUsersInputEnvelope
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
  }

  export type SalesReturnUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput> | SalesReturnCreateWithoutUsersInput[] | SalesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutUsersInput | SalesReturnCreateOrConnectWithoutUsersInput[]
    createMany?: SalesReturnCreateManyUsersInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput> | ExchangesCreateWithoutUsersInput[] | ExchangesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutUsersInput | ExchangesCreateOrConnectWithoutUsersInput[]
    createMany?: ExchangesCreateManyUsersInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type PurchasesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput> | PurchasesCreateWithoutUsersInput[] | PurchasesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutUsersInput | PurchasesCreateOrConnectWithoutUsersInput[]
    createMany?: PurchasesCreateManyUsersInputEnvelope
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
  }

  export type PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput> | PurchasesReturnCreateWithoutUsersInput[] | PurchasesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutUsersInput | PurchasesReturnCreateOrConnectWithoutUsersInput[]
    createMany?: PurchasesReturnCreateManyUsersInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type ServicesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput> | ServicesCreateWithoutUsersInput[] | ServicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutUsersInput | ServicesCreateOrConnectWithoutUsersInput[]
    createMany?: ServicesCreateManyUsersInputEnvelope
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput> | ProductsCreateWithoutCreatorInput[] | ProductsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCreatorInput | ProductsCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductsCreateManyCreatorInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput> | ProductsCreateWithoutUpdaterInput[] | ProductsUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutUpdaterInput | ProductsCreateOrConnectWithoutUpdaterInput[]
    createMany?: ProductsCreateManyUpdaterInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ExpensesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput> | ExpensesCreateWithoutUsersInput[] | ExpensesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpensesCreateOrConnectWithoutUsersInput | ExpensesCreateOrConnectWithoutUsersInput[]
    createMany?: ExpensesCreateManyUsersInputEnvelope
    connect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type RolesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    upsert?: RolesUpsertWithoutUsersInput
    disconnect?: RolesWhereInput | boolean
    delete?: RolesWhereInput | boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUsersInput, RolesUpdateWithoutUsersInput>, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SalesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput> | SalesCreateWithoutUsersInput[] | SalesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutUsersInput | SalesCreateOrConnectWithoutUsersInput[]
    upsert?: SalesUpsertWithWhereUniqueWithoutUsersInput | SalesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SalesCreateManyUsersInputEnvelope
    set?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    disconnect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    delete?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    update?: SalesUpdateWithWhereUniqueWithoutUsersInput | SalesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SalesUpdateManyWithWhereWithoutUsersInput | SalesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SalesScalarWhereInput | SalesScalarWhereInput[]
  }

  export type SalesReturnUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput> | SalesReturnCreateWithoutUsersInput[] | SalesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutUsersInput | SalesReturnCreateOrConnectWithoutUsersInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutUsersInput | SalesReturnUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SalesReturnCreateManyUsersInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutUsersInput | SalesReturnUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutUsersInput | SalesReturnUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput> | ExchangesCreateWithoutUsersInput[] | ExchangesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutUsersInput | ExchangesCreateOrConnectWithoutUsersInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutUsersInput | ExchangesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExchangesCreateManyUsersInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutUsersInput | ExchangesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutUsersInput | ExchangesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type PurchasesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput> | PurchasesCreateWithoutUsersInput[] | PurchasesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutUsersInput | PurchasesCreateOrConnectWithoutUsersInput[]
    upsert?: PurchasesUpsertWithWhereUniqueWithoutUsersInput | PurchasesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PurchasesCreateManyUsersInputEnvelope
    set?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    disconnect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    delete?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    update?: PurchasesUpdateWithWhereUniqueWithoutUsersInput | PurchasesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PurchasesUpdateManyWithWhereWithoutUsersInput | PurchasesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
  }

  export type PurchasesReturnUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput> | PurchasesReturnCreateWithoutUsersInput[] | PurchasesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutUsersInput | PurchasesReturnCreateOrConnectWithoutUsersInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutUsersInput | PurchasesReturnUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PurchasesReturnCreateManyUsersInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutUsersInput | PurchasesReturnUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutUsersInput | PurchasesReturnUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type ServicesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput> | ServicesCreateWithoutUsersInput[] | ServicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutUsersInput | ServicesCreateOrConnectWithoutUsersInput[]
    upsert?: ServicesUpsertWithWhereUniqueWithoutUsersInput | ServicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ServicesCreateManyUsersInputEnvelope
    set?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    disconnect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    delete?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    update?: ServicesUpdateWithWhereUniqueWithoutUsersInput | ServicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ServicesUpdateManyWithWhereWithoutUsersInput | ServicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
  }

  export type ProductsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput> | ProductsCreateWithoutCreatorInput[] | ProductsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCreatorInput | ProductsCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCreatorInput | ProductsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductsCreateManyCreatorInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCreatorInput | ProductsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCreatorInput | ProductsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput> | ProductsCreateWithoutUpdaterInput[] | ProductsUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutUpdaterInput | ProductsCreateOrConnectWithoutUpdaterInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutUpdaterInput | ProductsUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: ProductsCreateManyUpdaterInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutUpdaterInput | ProductsUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutUpdaterInput | ProductsUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ExpensesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput> | ExpensesCreateWithoutUsersInput[] | ExpensesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpensesCreateOrConnectWithoutUsersInput | ExpensesCreateOrConnectWithoutUsersInput[]
    upsert?: ExpensesUpsertWithWhereUniqueWithoutUsersInput | ExpensesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExpensesCreateManyUsersInputEnvelope
    set?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    disconnect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    delete?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    connect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    update?: ExpensesUpdateWithWhereUniqueWithoutUsersInput | ExpensesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExpensesUpdateManyWithWhereWithoutUsersInput | ExpensesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExpensesScalarWhereInput | ExpensesScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SalesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput> | SalesCreateWithoutUsersInput[] | SalesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutUsersInput | SalesCreateOrConnectWithoutUsersInput[]
    upsert?: SalesUpsertWithWhereUniqueWithoutUsersInput | SalesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SalesCreateManyUsersInputEnvelope
    set?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    disconnect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    delete?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    update?: SalesUpdateWithWhereUniqueWithoutUsersInput | SalesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SalesUpdateManyWithWhereWithoutUsersInput | SalesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SalesScalarWhereInput | SalesScalarWhereInput[]
  }

  export type SalesReturnUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput> | SalesReturnCreateWithoutUsersInput[] | SalesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutUsersInput | SalesReturnCreateOrConnectWithoutUsersInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutUsersInput | SalesReturnUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SalesReturnCreateManyUsersInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutUsersInput | SalesReturnUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutUsersInput | SalesReturnUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput> | ExchangesCreateWithoutUsersInput[] | ExchangesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutUsersInput | ExchangesCreateOrConnectWithoutUsersInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutUsersInput | ExchangesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExchangesCreateManyUsersInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutUsersInput | ExchangesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutUsersInput | ExchangesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type PurchasesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput> | PurchasesCreateWithoutUsersInput[] | PurchasesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutUsersInput | PurchasesCreateOrConnectWithoutUsersInput[]
    upsert?: PurchasesUpsertWithWhereUniqueWithoutUsersInput | PurchasesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PurchasesCreateManyUsersInputEnvelope
    set?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    disconnect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    delete?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    update?: PurchasesUpdateWithWhereUniqueWithoutUsersInput | PurchasesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PurchasesUpdateManyWithWhereWithoutUsersInput | PurchasesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput> | PurchasesReturnCreateWithoutUsersInput[] | PurchasesReturnUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutUsersInput | PurchasesReturnCreateOrConnectWithoutUsersInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutUsersInput | PurchasesReturnUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PurchasesReturnCreateManyUsersInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutUsersInput | PurchasesReturnUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutUsersInput | PurchasesReturnUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type ServicesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput> | ServicesCreateWithoutUsersInput[] | ServicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutUsersInput | ServicesCreateOrConnectWithoutUsersInput[]
    upsert?: ServicesUpsertWithWhereUniqueWithoutUsersInput | ServicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ServicesCreateManyUsersInputEnvelope
    set?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    disconnect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    delete?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    update?: ServicesUpdateWithWhereUniqueWithoutUsersInput | ServicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ServicesUpdateManyWithWhereWithoutUsersInput | ServicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput> | ProductsCreateWithoutCreatorInput[] | ProductsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCreatorInput | ProductsCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCreatorInput | ProductsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductsCreateManyCreatorInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCreatorInput | ProductsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCreatorInput | ProductsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput> | ProductsCreateWithoutUpdaterInput[] | ProductsUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutUpdaterInput | ProductsCreateOrConnectWithoutUpdaterInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutUpdaterInput | ProductsUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: ProductsCreateManyUpdaterInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutUpdaterInput | ProductsUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutUpdaterInput | ProductsUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ExpensesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput> | ExpensesCreateWithoutUsersInput[] | ExpensesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ExpensesCreateOrConnectWithoutUsersInput | ExpensesCreateOrConnectWithoutUsersInput[]
    upsert?: ExpensesUpsertWithWhereUniqueWithoutUsersInput | ExpensesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ExpensesCreateManyUsersInputEnvelope
    set?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    disconnect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    delete?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    connect?: ExpensesWhereUniqueInput | ExpensesWhereUniqueInput[]
    update?: ExpensesUpdateWithWhereUniqueWithoutUsersInput | ExpensesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ExpensesUpdateManyWithWhereWithoutUsersInput | ExpensesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ExpensesScalarWhereInput | ExpensesScalarWhereInput[]
  }

  export type SalesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput> | SalesCreateWithoutCustomersInput[] | SalesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutCustomersInput | SalesCreateOrConnectWithoutCustomersInput[]
    createMany?: SalesCreateManyCustomersInputEnvelope
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
  }

  export type SalesReturnCreateNestedManyWithoutCustomersInput = {
    create?: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput> | SalesReturnCreateWithoutCustomersInput[] | SalesReturnUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutCustomersInput | SalesReturnCreateOrConnectWithoutCustomersInput[]
    createMany?: SalesReturnCreateManyCustomersInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput> | ExchangesCreateWithoutCustomersInput[] | ExchangesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutCustomersInput | ExchangesCreateOrConnectWithoutCustomersInput[]
    createMany?: ExchangesCreateManyCustomersInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type ServicesCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput> | ServicesCreateWithoutCustomersInput[] | ServicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutCustomersInput | ServicesCreateOrConnectWithoutCustomersInput[]
    createMany?: ServicesCreateManyCustomersInputEnvelope
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
  }

  export type SalesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput> | SalesCreateWithoutCustomersInput[] | SalesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutCustomersInput | SalesCreateOrConnectWithoutCustomersInput[]
    createMany?: SalesCreateManyCustomersInputEnvelope
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
  }

  export type SalesReturnUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput> | SalesReturnCreateWithoutCustomersInput[] | SalesReturnUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutCustomersInput | SalesReturnCreateOrConnectWithoutCustomersInput[]
    createMany?: SalesReturnCreateManyCustomersInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput> | ExchangesCreateWithoutCustomersInput[] | ExchangesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutCustomersInput | ExchangesCreateOrConnectWithoutCustomersInput[]
    createMany?: ExchangesCreateManyCustomersInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type ServicesUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput> | ServicesCreateWithoutCustomersInput[] | ServicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutCustomersInput | ServicesCreateOrConnectWithoutCustomersInput[]
    createMany?: ServicesCreateManyCustomersInputEnvelope
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
  }

  export type SalesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput> | SalesCreateWithoutCustomersInput[] | SalesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutCustomersInput | SalesCreateOrConnectWithoutCustomersInput[]
    upsert?: SalesUpsertWithWhereUniqueWithoutCustomersInput | SalesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: SalesCreateManyCustomersInputEnvelope
    set?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    disconnect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    delete?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    update?: SalesUpdateWithWhereUniqueWithoutCustomersInput | SalesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: SalesUpdateManyWithWhereWithoutCustomersInput | SalesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: SalesScalarWhereInput | SalesScalarWhereInput[]
  }

  export type SalesReturnUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput> | SalesReturnCreateWithoutCustomersInput[] | SalesReturnUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutCustomersInput | SalesReturnCreateOrConnectWithoutCustomersInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutCustomersInput | SalesReturnUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: SalesReturnCreateManyCustomersInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutCustomersInput | SalesReturnUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutCustomersInput | SalesReturnUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput> | ExchangesCreateWithoutCustomersInput[] | ExchangesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutCustomersInput | ExchangesCreateOrConnectWithoutCustomersInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutCustomersInput | ExchangesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ExchangesCreateManyCustomersInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutCustomersInput | ExchangesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutCustomersInput | ExchangesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type ServicesUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput> | ServicesCreateWithoutCustomersInput[] | ServicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutCustomersInput | ServicesCreateOrConnectWithoutCustomersInput[]
    upsert?: ServicesUpsertWithWhereUniqueWithoutCustomersInput | ServicesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ServicesCreateManyCustomersInputEnvelope
    set?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    disconnect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    delete?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    update?: ServicesUpdateWithWhereUniqueWithoutCustomersInput | ServicesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ServicesUpdateManyWithWhereWithoutCustomersInput | ServicesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
  }

  export type SalesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput> | SalesCreateWithoutCustomersInput[] | SalesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesCreateOrConnectWithoutCustomersInput | SalesCreateOrConnectWithoutCustomersInput[]
    upsert?: SalesUpsertWithWhereUniqueWithoutCustomersInput | SalesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: SalesCreateManyCustomersInputEnvelope
    set?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    disconnect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    delete?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    connect?: SalesWhereUniqueInput | SalesWhereUniqueInput[]
    update?: SalesUpdateWithWhereUniqueWithoutCustomersInput | SalesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: SalesUpdateManyWithWhereWithoutCustomersInput | SalesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: SalesScalarWhereInput | SalesScalarWhereInput[]
  }

  export type SalesReturnUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput> | SalesReturnCreateWithoutCustomersInput[] | SalesReturnUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutCustomersInput | SalesReturnCreateOrConnectWithoutCustomersInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutCustomersInput | SalesReturnUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: SalesReturnCreateManyCustomersInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutCustomersInput | SalesReturnUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutCustomersInput | SalesReturnUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput> | ExchangesCreateWithoutCustomersInput[] | ExchangesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutCustomersInput | ExchangesCreateOrConnectWithoutCustomersInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutCustomersInput | ExchangesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ExchangesCreateManyCustomersInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutCustomersInput | ExchangesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutCustomersInput | ExchangesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type ServicesUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput> | ServicesCreateWithoutCustomersInput[] | ServicesUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ServicesCreateOrConnectWithoutCustomersInput | ServicesCreateOrConnectWithoutCustomersInput[]
    upsert?: ServicesUpsertWithWhereUniqueWithoutCustomersInput | ServicesUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ServicesCreateManyCustomersInputEnvelope
    set?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    disconnect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    delete?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    connect?: ServicesWhereUniqueInput | ServicesWhereUniqueInput[]
    update?: ServicesUpdateWithWhereUniqueWithoutCustomersInput | ServicesUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ServicesUpdateManyWithWhereWithoutCustomersInput | ServicesUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
  }

  export type PurchasesCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput> | PurchasesCreateWithoutSuppliersInput[] | PurchasesUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutSuppliersInput | PurchasesCreateOrConnectWithoutSuppliersInput[]
    createMany?: PurchasesCreateManySuppliersInputEnvelope
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
  }

  export type PurchasesReturnCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput> | PurchasesReturnCreateWithoutSuppliersInput[] | PurchasesReturnUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutSuppliersInput | PurchasesReturnCreateOrConnectWithoutSuppliersInput[]
    createMany?: PurchasesReturnCreateManySuppliersInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type ProductsCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput> | ProductsCreateWithoutSupplierInput[] | ProductsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSupplierInput | ProductsCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductsCreateManySupplierInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type PurchasesUncheckedCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput> | PurchasesCreateWithoutSuppliersInput[] | PurchasesUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutSuppliersInput | PurchasesCreateOrConnectWithoutSuppliersInput[]
    createMany?: PurchasesCreateManySuppliersInputEnvelope
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
  }

  export type PurchasesReturnUncheckedCreateNestedManyWithoutSuppliersInput = {
    create?: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput> | PurchasesReturnCreateWithoutSuppliersInput[] | PurchasesReturnUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutSuppliersInput | PurchasesReturnCreateOrConnectWithoutSuppliersInput[]
    createMany?: PurchasesReturnCreateManySuppliersInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput> | ProductsCreateWithoutSupplierInput[] | ProductsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSupplierInput | ProductsCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductsCreateManySupplierInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type PurchasesUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput> | PurchasesCreateWithoutSuppliersInput[] | PurchasesUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutSuppliersInput | PurchasesCreateOrConnectWithoutSuppliersInput[]
    upsert?: PurchasesUpsertWithWhereUniqueWithoutSuppliersInput | PurchasesUpsertWithWhereUniqueWithoutSuppliersInput[]
    createMany?: PurchasesCreateManySuppliersInputEnvelope
    set?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    disconnect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    delete?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    update?: PurchasesUpdateWithWhereUniqueWithoutSuppliersInput | PurchasesUpdateWithWhereUniqueWithoutSuppliersInput[]
    updateMany?: PurchasesUpdateManyWithWhereWithoutSuppliersInput | PurchasesUpdateManyWithWhereWithoutSuppliersInput[]
    deleteMany?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
  }

  export type PurchasesReturnUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput> | PurchasesReturnCreateWithoutSuppliersInput[] | PurchasesReturnUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutSuppliersInput | PurchasesReturnCreateOrConnectWithoutSuppliersInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutSuppliersInput | PurchasesReturnUpsertWithWhereUniqueWithoutSuppliersInput[]
    createMany?: PurchasesReturnCreateManySuppliersInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutSuppliersInput | PurchasesReturnUpdateWithWhereUniqueWithoutSuppliersInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutSuppliersInput | PurchasesReturnUpdateManyWithWhereWithoutSuppliersInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type ProductsUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput> | ProductsCreateWithoutSupplierInput[] | ProductsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSupplierInput | ProductsCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutSupplierInput | ProductsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductsCreateManySupplierInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutSupplierInput | ProductsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutSupplierInput | ProductsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type PurchasesUncheckedUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput> | PurchasesCreateWithoutSuppliersInput[] | PurchasesUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesCreateOrConnectWithoutSuppliersInput | PurchasesCreateOrConnectWithoutSuppliersInput[]
    upsert?: PurchasesUpsertWithWhereUniqueWithoutSuppliersInput | PurchasesUpsertWithWhereUniqueWithoutSuppliersInput[]
    createMany?: PurchasesCreateManySuppliersInputEnvelope
    set?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    disconnect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    delete?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    connect?: PurchasesWhereUniqueInput | PurchasesWhereUniqueInput[]
    update?: PurchasesUpdateWithWhereUniqueWithoutSuppliersInput | PurchasesUpdateWithWhereUniqueWithoutSuppliersInput[]
    updateMany?: PurchasesUpdateManyWithWhereWithoutSuppliersInput | PurchasesUpdateManyWithWhereWithoutSuppliersInput[]
    deleteMany?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutSuppliersNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput> | PurchasesReturnCreateWithoutSuppliersInput[] | PurchasesReturnUncheckedCreateWithoutSuppliersInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutSuppliersInput | PurchasesReturnCreateOrConnectWithoutSuppliersInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutSuppliersInput | PurchasesReturnUpsertWithWhereUniqueWithoutSuppliersInput[]
    createMany?: PurchasesReturnCreateManySuppliersInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutSuppliersInput | PurchasesReturnUpdateWithWhereUniqueWithoutSuppliersInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutSuppliersInput | PurchasesReturnUpdateManyWithWhereWithoutSuppliersInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput> | ProductsCreateWithoutSupplierInput[] | ProductsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSupplierInput | ProductsCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutSupplierInput | ProductsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductsCreateManySupplierInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutSupplierInput | ProductsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutSupplierInput | ProductsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput> | ProductsCreateWithoutCategoriesInput[] | ProductsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoriesInput | ProductsCreateOrConnectWithoutCategoriesInput[]
    createMany?: ProductsCreateManyCategoriesInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput> | ProductsCreateWithoutCategoriesInput[] | ProductsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoriesInput | ProductsCreateOrConnectWithoutCategoriesInput[]
    createMany?: ProductsCreateManyCategoriesInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput> | ProductsCreateWithoutCategoriesInput[] | ProductsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoriesInput | ProductsCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCategoriesInput | ProductsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ProductsCreateManyCategoriesInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCategoriesInput | ProductsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCategoriesInput | ProductsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput> | ProductsCreateWithoutCategoriesInput[] | ProductsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutCategoriesInput | ProductsCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutCategoriesInput | ProductsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ProductsCreateManyCategoriesInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutCategoriesInput | ProductsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutCategoriesInput | ProductsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type CategoriesCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoriesCreateWithoutProductsInput, CategoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutProductsInput
    connect?: CategoriesWhereUniqueInput
  }

  export type SuppliersCreateNestedOneWithoutProductsInput = {
    create?: XOR<SuppliersCreateWithoutProductsInput, SuppliersUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutProductsInput
    connect?: SuppliersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCreatedProductsInput = {
    create?: XOR<UsersCreateWithoutCreatedProductsInput, UsersUncheckedCreateWithoutCreatedProductsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedProductsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUpdatedProductsInput = {
    create?: XOR<UsersCreateWithoutUpdatedProductsInput, UsersUncheckedCreateWithoutUpdatedProductsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUpdatedProductsInput
    connect?: UsersWhereUniqueInput
  }

  export type SalesItemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput> | SalesItemsCreateWithoutProductsInput[] | SalesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutProductsInput | SalesItemsCreateOrConnectWithoutProductsInput[]
    createMany?: SalesItemsCreateManyProductsInputEnvelope
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
  }

  export type SalesReturnItemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput> | SalesReturnItemsCreateWithoutProductsInput[] | SalesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductsInput | SalesReturnItemsCreateOrConnectWithoutProductsInput[]
    createMany?: SalesReturnItemsCreateManyProductsInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type ExchangesItemsCreateNestedManyWithoutOldProductInput = {
    create?: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput> | ExchangesItemsCreateWithoutOldProductInput[] | ExchangesItemsUncheckedCreateWithoutOldProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutOldProductInput | ExchangesItemsCreateOrConnectWithoutOldProductInput[]
    createMany?: ExchangesItemsCreateManyOldProductInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type ExchangesItemsCreateNestedManyWithoutNewProductInput = {
    create?: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput> | ExchangesItemsCreateWithoutNewProductInput[] | ExchangesItemsUncheckedCreateWithoutNewProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutNewProductInput | ExchangesItemsCreateOrConnectWithoutNewProductInput[]
    createMany?: ExchangesItemsCreateManyNewProductInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type PurchasesItemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput> | PurchasesItemsCreateWithoutProductsInput[] | PurchasesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutProductsInput | PurchasesItemsCreateOrConnectWithoutProductsInput[]
    createMany?: PurchasesItemsCreateManyProductsInputEnvelope
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
  }

  export type PurchasesReturnItemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput> | PurchasesReturnItemsCreateWithoutProductsInput[] | PurchasesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutProductsInput | PurchasesReturnItemsCreateOrConnectWithoutProductsInput[]
    createMany?: PurchasesReturnItemsCreateManyProductsInputEnvelope
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
  }

  export type ProductSerialsCreateNestedManyWithoutProductsInput = {
    create?: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput> | ProductSerialsCreateWithoutProductsInput[] | ProductSerialsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutProductsInput | ProductSerialsCreateOrConnectWithoutProductsInput[]
    createMany?: ProductSerialsCreateManyProductsInputEnvelope
    connect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
  }

  export type SalesItemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput> | SalesItemsCreateWithoutProductsInput[] | SalesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutProductsInput | SalesItemsCreateOrConnectWithoutProductsInput[]
    createMany?: SalesItemsCreateManyProductsInputEnvelope
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
  }

  export type SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput> | SalesReturnItemsCreateWithoutProductsInput[] | SalesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductsInput | SalesReturnItemsCreateOrConnectWithoutProductsInput[]
    createMany?: SalesReturnItemsCreateManyProductsInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput = {
    create?: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput> | ExchangesItemsCreateWithoutOldProductInput[] | ExchangesItemsUncheckedCreateWithoutOldProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutOldProductInput | ExchangesItemsCreateOrConnectWithoutOldProductInput[]
    createMany?: ExchangesItemsCreateManyOldProductInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput = {
    create?: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput> | ExchangesItemsCreateWithoutNewProductInput[] | ExchangesItemsUncheckedCreateWithoutNewProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutNewProductInput | ExchangesItemsCreateOrConnectWithoutNewProductInput[]
    createMany?: ExchangesItemsCreateManyNewProductInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput> | PurchasesItemsCreateWithoutProductsInput[] | PurchasesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutProductsInput | PurchasesItemsCreateOrConnectWithoutProductsInput[]
    createMany?: PurchasesItemsCreateManyProductsInputEnvelope
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
  }

  export type PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput> | PurchasesReturnItemsCreateWithoutProductsInput[] | PurchasesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutProductsInput | PurchasesReturnItemsCreateOrConnectWithoutProductsInput[]
    createMany?: PurchasesReturnItemsCreateManyProductsInputEnvelope
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
  }

  export type ProductSerialsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput> | ProductSerialsCreateWithoutProductsInput[] | ProductSerialsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutProductsInput | ProductSerialsCreateOrConnectWithoutProductsInput[]
    createMany?: ProductSerialsCreateManyProductsInputEnvelope
    connect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type CategoriesUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoriesCreateWithoutProductsInput, CategoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutProductsInput
    upsert?: CategoriesUpsertWithoutProductsInput
    disconnect?: CategoriesWhereInput | boolean
    delete?: CategoriesWhereInput | boolean
    connect?: CategoriesWhereUniqueInput
    update?: XOR<XOR<CategoriesUpdateToOneWithWhereWithoutProductsInput, CategoriesUpdateWithoutProductsInput>, CategoriesUncheckedUpdateWithoutProductsInput>
  }

  export type SuppliersUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SuppliersCreateWithoutProductsInput, SuppliersUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutProductsInput
    upsert?: SuppliersUpsertWithoutProductsInput
    disconnect?: SuppliersWhereInput | boolean
    delete?: SuppliersWhereInput | boolean
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutProductsInput, SuppliersUpdateWithoutProductsInput>, SuppliersUncheckedUpdateWithoutProductsInput>
  }

  export type UsersUpdateOneWithoutCreatedProductsNestedInput = {
    create?: XOR<UsersCreateWithoutCreatedProductsInput, UsersUncheckedCreateWithoutCreatedProductsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedProductsInput
    upsert?: UsersUpsertWithoutCreatedProductsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCreatedProductsInput, UsersUpdateWithoutCreatedProductsInput>, UsersUncheckedUpdateWithoutCreatedProductsInput>
  }

  export type UsersUpdateOneWithoutUpdatedProductsNestedInput = {
    create?: XOR<UsersCreateWithoutUpdatedProductsInput, UsersUncheckedCreateWithoutUpdatedProductsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUpdatedProductsInput
    upsert?: UsersUpsertWithoutUpdatedProductsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUpdatedProductsInput, UsersUpdateWithoutUpdatedProductsInput>, UsersUncheckedUpdateWithoutUpdatedProductsInput>
  }

  export type SalesItemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput> | SalesItemsCreateWithoutProductsInput[] | SalesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutProductsInput | SalesItemsCreateOrConnectWithoutProductsInput[]
    upsert?: SalesItemsUpsertWithWhereUniqueWithoutProductsInput | SalesItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: SalesItemsCreateManyProductsInputEnvelope
    set?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    disconnect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    delete?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    update?: SalesItemsUpdateWithWhereUniqueWithoutProductsInput | SalesItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: SalesItemsUpdateManyWithWhereWithoutProductsInput | SalesItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
  }

  export type SalesReturnItemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput> | SalesReturnItemsCreateWithoutProductsInput[] | SalesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductsInput | SalesReturnItemsCreateOrConnectWithoutProductsInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutProductsInput | SalesReturnItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: SalesReturnItemsCreateManyProductsInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutProductsInput | SalesReturnItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutProductsInput | SalesReturnItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type ExchangesItemsUpdateManyWithoutOldProductNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput> | ExchangesItemsCreateWithoutOldProductInput[] | ExchangesItemsUncheckedCreateWithoutOldProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutOldProductInput | ExchangesItemsCreateOrConnectWithoutOldProductInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutOldProductInput | ExchangesItemsUpsertWithWhereUniqueWithoutOldProductInput[]
    createMany?: ExchangesItemsCreateManyOldProductInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutOldProductInput | ExchangesItemsUpdateWithWhereUniqueWithoutOldProductInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutOldProductInput | ExchangesItemsUpdateManyWithWhereWithoutOldProductInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type ExchangesItemsUpdateManyWithoutNewProductNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput> | ExchangesItemsCreateWithoutNewProductInput[] | ExchangesItemsUncheckedCreateWithoutNewProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutNewProductInput | ExchangesItemsCreateOrConnectWithoutNewProductInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutNewProductInput | ExchangesItemsUpsertWithWhereUniqueWithoutNewProductInput[]
    createMany?: ExchangesItemsCreateManyNewProductInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutNewProductInput | ExchangesItemsUpdateWithWhereUniqueWithoutNewProductInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutNewProductInput | ExchangesItemsUpdateManyWithWhereWithoutNewProductInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type PurchasesItemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput> | PurchasesItemsCreateWithoutProductsInput[] | PurchasesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutProductsInput | PurchasesItemsCreateOrConnectWithoutProductsInput[]
    upsert?: PurchasesItemsUpsertWithWhereUniqueWithoutProductsInput | PurchasesItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PurchasesItemsCreateManyProductsInputEnvelope
    set?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    disconnect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    delete?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    update?: PurchasesItemsUpdateWithWhereUniqueWithoutProductsInput | PurchasesItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PurchasesItemsUpdateManyWithWhereWithoutProductsInput | PurchasesItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
  }

  export type PurchasesReturnItemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput> | PurchasesReturnItemsCreateWithoutProductsInput[] | PurchasesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutProductsInput | PurchasesReturnItemsCreateOrConnectWithoutProductsInput[]
    upsert?: PurchasesReturnItemsUpsertWithWhereUniqueWithoutProductsInput | PurchasesReturnItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PurchasesReturnItemsCreateManyProductsInputEnvelope
    set?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    disconnect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    delete?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    update?: PurchasesReturnItemsUpdateWithWhereUniqueWithoutProductsInput | PurchasesReturnItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PurchasesReturnItemsUpdateManyWithWhereWithoutProductsInput | PurchasesReturnItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
  }

  export type ProductSerialsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput> | ProductSerialsCreateWithoutProductsInput[] | ProductSerialsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutProductsInput | ProductSerialsCreateOrConnectWithoutProductsInput[]
    upsert?: ProductSerialsUpsertWithWhereUniqueWithoutProductsInput | ProductSerialsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: ProductSerialsCreateManyProductsInputEnvelope
    set?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    disconnect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    delete?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    connect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    update?: ProductSerialsUpdateWithWhereUniqueWithoutProductsInput | ProductSerialsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: ProductSerialsUpdateManyWithWhereWithoutProductsInput | ProductSerialsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: ProductSerialsScalarWhereInput | ProductSerialsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SalesItemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput> | SalesItemsCreateWithoutProductsInput[] | SalesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutProductsInput | SalesItemsCreateOrConnectWithoutProductsInput[]
    upsert?: SalesItemsUpsertWithWhereUniqueWithoutProductsInput | SalesItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: SalesItemsCreateManyProductsInputEnvelope
    set?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    disconnect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    delete?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    update?: SalesItemsUpdateWithWhereUniqueWithoutProductsInput | SalesItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: SalesItemsUpdateManyWithWhereWithoutProductsInput | SalesItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput> | SalesReturnItemsCreateWithoutProductsInput[] | SalesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductsInput | SalesReturnItemsCreateOrConnectWithoutProductsInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutProductsInput | SalesReturnItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: SalesReturnItemsCreateManyProductsInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutProductsInput | SalesReturnItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutProductsInput | SalesReturnItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput> | ExchangesItemsCreateWithoutOldProductInput[] | ExchangesItemsUncheckedCreateWithoutOldProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutOldProductInput | ExchangesItemsCreateOrConnectWithoutOldProductInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutOldProductInput | ExchangesItemsUpsertWithWhereUniqueWithoutOldProductInput[]
    createMany?: ExchangesItemsCreateManyOldProductInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutOldProductInput | ExchangesItemsUpdateWithWhereUniqueWithoutOldProductInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutOldProductInput | ExchangesItemsUpdateManyWithWhereWithoutOldProductInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput> | ExchangesItemsCreateWithoutNewProductInput[] | ExchangesItemsUncheckedCreateWithoutNewProductInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutNewProductInput | ExchangesItemsCreateOrConnectWithoutNewProductInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutNewProductInput | ExchangesItemsUpsertWithWhereUniqueWithoutNewProductInput[]
    createMany?: ExchangesItemsCreateManyNewProductInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutNewProductInput | ExchangesItemsUpdateWithWhereUniqueWithoutNewProductInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutNewProductInput | ExchangesItemsUpdateManyWithWhereWithoutNewProductInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput> | PurchasesItemsCreateWithoutProductsInput[] | PurchasesItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutProductsInput | PurchasesItemsCreateOrConnectWithoutProductsInput[]
    upsert?: PurchasesItemsUpsertWithWhereUniqueWithoutProductsInput | PurchasesItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PurchasesItemsCreateManyProductsInputEnvelope
    set?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    disconnect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    delete?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    update?: PurchasesItemsUpdateWithWhereUniqueWithoutProductsInput | PurchasesItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PurchasesItemsUpdateManyWithWhereWithoutProductsInput | PurchasesItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
  }

  export type PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput> | PurchasesReturnItemsCreateWithoutProductsInput[] | PurchasesReturnItemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutProductsInput | PurchasesReturnItemsCreateOrConnectWithoutProductsInput[]
    upsert?: PurchasesReturnItemsUpsertWithWhereUniqueWithoutProductsInput | PurchasesReturnItemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: PurchasesReturnItemsCreateManyProductsInputEnvelope
    set?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    disconnect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    delete?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    update?: PurchasesReturnItemsUpdateWithWhereUniqueWithoutProductsInput | PurchasesReturnItemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: PurchasesReturnItemsUpdateManyWithWhereWithoutProductsInput | PurchasesReturnItemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
  }

  export type ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput> | ProductSerialsCreateWithoutProductsInput[] | ProductSerialsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutProductsInput | ProductSerialsCreateOrConnectWithoutProductsInput[]
    upsert?: ProductSerialsUpsertWithWhereUniqueWithoutProductsInput | ProductSerialsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: ProductSerialsCreateManyProductsInputEnvelope
    set?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    disconnect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    delete?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    connect?: ProductSerialsWhereUniqueInput | ProductSerialsWhereUniqueInput[]
    update?: ProductSerialsUpdateWithWhereUniqueWithoutProductsInput | ProductSerialsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: ProductSerialsUpdateManyWithWhereWithoutProductsInput | ProductSerialsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: ProductSerialsScalarWhereInput | ProductSerialsScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutProductSerialsInput = {
    create?: XOR<ProductsCreateWithoutProductSerialsInput, ProductsUncheckedCreateWithoutProductSerialsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductSerialsInput
    connect?: ProductsWhereUniqueInput
  }

  export type SalesItemSerialsCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesItemSerialsCreateWithoutProductSerialsInput[] | SalesItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
  }

  export type SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemSerialsCreateWithoutProductSerialsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesReturnItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
  }

  export type PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseItemSerialsCreateWithoutProductSerialsInput[] | PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: PurchaseItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
  }

  export type PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseReturnItemSerialsCreateWithoutProductSerialsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
  }

  export type SalesReturnItemsCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemsCreateWithoutProductSerialsInput[] | SalesReturnItemsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesReturnItemsCreateManyProductSerialsInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput> | ExchangeItemSerialsCreateWithoutOldProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyOldProductSerialsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput> | ExchangeItemSerialsCreateWithoutNewProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyNewProductSerialsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesItemSerialsCreateWithoutProductSerialsInput[] | SalesItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
  }

  export type SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemSerialsCreateWithoutProductSerialsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesReturnItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
  }

  export type PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseItemSerialsCreateWithoutProductSerialsInput[] | PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: PurchaseItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
  }

  export type PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseReturnItemSerialsCreateWithoutProductSerialsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyProductSerialsInputEnvelope
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
  }

  export type SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemsCreateWithoutProductSerialsInput[] | SalesReturnItemsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemsCreateOrConnectWithoutProductSerialsInput[]
    createMany?: SalesReturnItemsCreateManyProductSerialsInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput> | ExchangeItemSerialsCreateWithoutOldProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyOldProductSerialsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput> | ExchangeItemSerialsCreateWithoutNewProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyNewProductSerialsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type EnumSerialStatusFieldUpdateOperationsInput = {
    set?: $Enums.SerialStatus
  }

  export type EnumWarrantyFieldUpdateOperationsInput = {
    set?: $Enums.Warranty
  }

  export type ProductsUpdateOneWithoutProductSerialsNestedInput = {
    create?: XOR<ProductsCreateWithoutProductSerialsInput, ProductsUncheckedCreateWithoutProductSerialsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductSerialsInput
    upsert?: ProductsUpsertWithoutProductSerialsInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutProductSerialsInput, ProductsUpdateWithoutProductSerialsInput>, ProductsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesItemSerialsCreateWithoutProductSerialsInput[] | SalesItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesItemSerialsCreateManyProductSerialsInputEnvelope
    set?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    disconnect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    delete?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    update?: SalesItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | SalesItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemSerialsCreateWithoutProductSerialsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesReturnItemSerialsCreateManyProductSerialsInputEnvelope
    set?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    disconnect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    delete?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    update?: SalesReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | SalesReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
  }

  export type PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseItemSerialsCreateWithoutProductSerialsInput[] | PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: PurchaseItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | PurchaseItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: PurchaseItemSerialsCreateManyProductSerialsInputEnvelope
    set?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    delete?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    update?: PurchaseItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | PurchaseItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: PurchaseItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | PurchaseItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
  }

  export type PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseReturnItemSerialsCreateWithoutProductSerialsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyProductSerialsInputEnvelope
    set?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    delete?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    update?: PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: PurchaseReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | PurchaseReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemsCreateWithoutProductSerialsInput[] | SalesReturnItemsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesReturnItemsCreateManyProductSerialsInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutProductSerialsInput | SalesReturnItemsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput> | ExchangeItemSerialsCreateWithoutOldProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutOldProductSerialsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutOldProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyOldProductSerialsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutOldProductSerialsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutOldProductSerialsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutOldProductSerialsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutOldProductSerialsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput> | ExchangeItemSerialsCreateWithoutNewProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutNewProductSerialsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutNewProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyNewProductSerialsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutNewProductSerialsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutNewProductSerialsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutNewProductSerialsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutNewProductSerialsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesItemSerialsCreateWithoutProductSerialsInput[] | SalesItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesItemSerialsCreateManyProductSerialsInputEnvelope
    set?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    disconnect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    delete?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    update?: SalesItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | SalesItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemSerialsCreateWithoutProductSerialsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesReturnItemSerialsCreateManyProductSerialsInputEnvelope
    set?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    disconnect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    delete?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    update?: SalesReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | SalesReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
  }

  export type PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseItemSerialsCreateWithoutProductSerialsInput[] | PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: PurchaseItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | PurchaseItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: PurchaseItemSerialsCreateManyProductSerialsInputEnvelope
    set?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    delete?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    update?: PurchaseItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | PurchaseItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: PurchaseItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | PurchaseItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput> | PurchaseReturnItemSerialsCreateWithoutProductSerialsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput | PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyProductSerialsInputEnvelope
    set?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    delete?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    update?: PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput | PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: PurchaseReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput | PurchaseReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput> | SalesReturnItemsCreateWithoutProductSerialsInput[] | SalesReturnItemsUncheckedCreateWithoutProductSerialsInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutProductSerialsInput | SalesReturnItemsCreateOrConnectWithoutProductSerialsInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemsUpsertWithWhereUniqueWithoutProductSerialsInput[]
    createMany?: SalesReturnItemsCreateManyProductSerialsInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutProductSerialsInput | SalesReturnItemsUpdateWithWhereUniqueWithoutProductSerialsInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutProductSerialsInput | SalesReturnItemsUpdateManyWithWhereWithoutProductSerialsInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput> | ExchangeItemSerialsCreateWithoutOldProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutOldProductSerialsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutOldProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyOldProductSerialsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutOldProductSerialsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutOldProductSerialsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutOldProductSerialsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutOldProductSerialsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput> | ExchangeItemSerialsCreateWithoutNewProductSerialsInput[] | ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput | ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutNewProductSerialsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutNewProductSerialsInput[]
    createMany?: ExchangeItemSerialsCreateManyNewProductSerialsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutNewProductSerialsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutNewProductSerialsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutNewProductSerialsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutNewProductSerialsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutExpensesInput = {
    create?: XOR<UsersCreateWithoutExpensesInput, UsersUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutExpensesInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<UsersCreateWithoutExpensesInput, UsersUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutExpensesInput
    upsert?: UsersUpsertWithoutExpensesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutExpensesInput, UsersUpdateWithoutExpensesInput>, UsersUncheckedUpdateWithoutExpensesInput>
  }

  export type CustomersCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomersCreateWithoutSalesInput, CustomersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSalesInput
    connect?: CustomersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutSalesInput = {
    create?: XOR<UsersCreateWithoutSalesInput, UsersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSalesInput
    connect?: UsersWhereUniqueInput
  }

  export type SalesItemsCreateNestedManyWithoutSalesInput = {
    create?: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput> | SalesItemsCreateWithoutSalesInput[] | SalesItemsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesInput | SalesItemsCreateOrConnectWithoutSalesInput[]
    createMany?: SalesItemsCreateManySalesInputEnvelope
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
  }

  export type SalesReturnCreateNestedManyWithoutSalesInput = {
    create?: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput> | SalesReturnCreateWithoutSalesInput[] | SalesReturnUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesInput | SalesReturnCreateOrConnectWithoutSalesInput[]
    createMany?: SalesReturnCreateManySalesInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesCreateNestedManyWithoutSalesInput = {
    create?: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput> | ExchangesCreateWithoutSalesInput[] | ExchangesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutSalesInput | ExchangesCreateOrConnectWithoutSalesInput[]
    createMany?: ExchangesCreateManySalesInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type SalesItemsUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput> | SalesItemsCreateWithoutSalesInput[] | SalesItemsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesInput | SalesItemsCreateOrConnectWithoutSalesInput[]
    createMany?: SalesItemsCreateManySalesInputEnvelope
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
  }

  export type SalesReturnUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput> | SalesReturnCreateWithoutSalesInput[] | SalesReturnUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesInput | SalesReturnCreateOrConnectWithoutSalesInput[]
    createMany?: SalesReturnCreateManySalesInputEnvelope
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
  }

  export type ExchangesUncheckedCreateNestedManyWithoutSalesInput = {
    create?: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput> | ExchangesCreateWithoutSalesInput[] | ExchangesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutSalesInput | ExchangesCreateOrConnectWithoutSalesInput[]
    createMany?: ExchangesCreateManySalesInputEnvelope
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomersUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CustomersCreateWithoutSalesInput, CustomersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSalesInput
    upsert?: CustomersUpsertWithoutSalesInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutSalesInput, CustomersUpdateWithoutSalesInput>, CustomersUncheckedUpdateWithoutSalesInput>
  }

  export type UsersUpdateOneWithoutSalesNestedInput = {
    create?: XOR<UsersCreateWithoutSalesInput, UsersUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSalesInput
    upsert?: UsersUpsertWithoutSalesInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSalesInput, UsersUpdateWithoutSalesInput>, UsersUncheckedUpdateWithoutSalesInput>
  }

  export type SalesItemsUpdateManyWithoutSalesNestedInput = {
    create?: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput> | SalesItemsCreateWithoutSalesInput[] | SalesItemsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesInput | SalesItemsCreateOrConnectWithoutSalesInput[]
    upsert?: SalesItemsUpsertWithWhereUniqueWithoutSalesInput | SalesItemsUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: SalesItemsCreateManySalesInputEnvelope
    set?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    disconnect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    delete?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    update?: SalesItemsUpdateWithWhereUniqueWithoutSalesInput | SalesItemsUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: SalesItemsUpdateManyWithWhereWithoutSalesInput | SalesItemsUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
  }

  export type SalesReturnUpdateManyWithoutSalesNestedInput = {
    create?: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput> | SalesReturnCreateWithoutSalesInput[] | SalesReturnUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesInput | SalesReturnCreateOrConnectWithoutSalesInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutSalesInput | SalesReturnUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: SalesReturnCreateManySalesInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutSalesInput | SalesReturnUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutSalesInput | SalesReturnUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUpdateManyWithoutSalesNestedInput = {
    create?: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput> | ExchangesCreateWithoutSalesInput[] | ExchangesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutSalesInput | ExchangesCreateOrConnectWithoutSalesInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutSalesInput | ExchangesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: ExchangesCreateManySalesInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutSalesInput | ExchangesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutSalesInput | ExchangesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type SalesItemsUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput> | SalesItemsCreateWithoutSalesInput[] | SalesItemsUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesInput | SalesItemsCreateOrConnectWithoutSalesInput[]
    upsert?: SalesItemsUpsertWithWhereUniqueWithoutSalesInput | SalesItemsUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: SalesItemsCreateManySalesInputEnvelope
    set?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    disconnect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    delete?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    connect?: SalesItemsWhereUniqueInput | SalesItemsWhereUniqueInput[]
    update?: SalesItemsUpdateWithWhereUniqueWithoutSalesInput | SalesItemsUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: SalesItemsUpdateManyWithWhereWithoutSalesInput | SalesItemsUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
  }

  export type SalesReturnUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput> | SalesReturnCreateWithoutSalesInput[] | SalesReturnUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesInput | SalesReturnCreateOrConnectWithoutSalesInput[]
    upsert?: SalesReturnUpsertWithWhereUniqueWithoutSalesInput | SalesReturnUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: SalesReturnCreateManySalesInputEnvelope
    set?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    disconnect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    delete?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    connect?: SalesReturnWhereUniqueInput | SalesReturnWhereUniqueInput[]
    update?: SalesReturnUpdateWithWhereUniqueWithoutSalesInput | SalesReturnUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: SalesReturnUpdateManyWithWhereWithoutSalesInput | SalesReturnUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
  }

  export type ExchangesUncheckedUpdateManyWithoutSalesNestedInput = {
    create?: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput> | ExchangesCreateWithoutSalesInput[] | ExchangesUncheckedCreateWithoutSalesInput[]
    connectOrCreate?: ExchangesCreateOrConnectWithoutSalesInput | ExchangesCreateOrConnectWithoutSalesInput[]
    upsert?: ExchangesUpsertWithWhereUniqueWithoutSalesInput | ExchangesUpsertWithWhereUniqueWithoutSalesInput[]
    createMany?: ExchangesCreateManySalesInputEnvelope
    set?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    disconnect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    delete?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    connect?: ExchangesWhereUniqueInput | ExchangesWhereUniqueInput[]
    update?: ExchangesUpdateWithWhereUniqueWithoutSalesInput | ExchangesUpdateWithWhereUniqueWithoutSalesInput[]
    updateMany?: ExchangesUpdateManyWithWhereWithoutSalesInput | ExchangesUpdateManyWithWhereWithoutSalesInput[]
    deleteMany?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
  }

  export type SalesCreateNestedOneWithoutSalesItemsInput = {
    create?: XOR<SalesCreateWithoutSalesItemsInput, SalesUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: SalesCreateOrConnectWithoutSalesItemsInput
    connect?: SalesWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutSalesItemsInput = {
    create?: XOR<ProductsCreateWithoutSalesItemsInput, ProductsUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutSalesItemsInput
    connect?: ProductsWhereUniqueInput
  }

  export type SalesItemSerialsCreateNestedManyWithoutSalesItemsInput = {
    create?: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput> | SalesItemSerialsCreateWithoutSalesItemsInput[] | SalesItemSerialsUncheckedCreateWithoutSalesItemsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutSalesItemsInput | SalesItemSerialsCreateOrConnectWithoutSalesItemsInput[]
    createMany?: SalesItemSerialsCreateManySalesItemsInputEnvelope
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
  }

  export type SalesItemSerialsUncheckedCreateNestedManyWithoutSalesItemsInput = {
    create?: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput> | SalesItemSerialsCreateWithoutSalesItemsInput[] | SalesItemSerialsUncheckedCreateWithoutSalesItemsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutSalesItemsInput | SalesItemSerialsCreateOrConnectWithoutSalesItemsInput[]
    createMany?: SalesItemSerialsCreateManySalesItemsInputEnvelope
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
  }

  export type SalesUpdateOneWithoutSalesItemsNestedInput = {
    create?: XOR<SalesCreateWithoutSalesItemsInput, SalesUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: SalesCreateOrConnectWithoutSalesItemsInput
    upsert?: SalesUpsertWithoutSalesItemsInput
    disconnect?: SalesWhereInput | boolean
    delete?: SalesWhereInput | boolean
    connect?: SalesWhereUniqueInput
    update?: XOR<XOR<SalesUpdateToOneWithWhereWithoutSalesItemsInput, SalesUpdateWithoutSalesItemsInput>, SalesUncheckedUpdateWithoutSalesItemsInput>
  }

  export type ProductsUpdateOneWithoutSalesItemsNestedInput = {
    create?: XOR<ProductsCreateWithoutSalesItemsInput, ProductsUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutSalesItemsInput
    upsert?: ProductsUpsertWithoutSalesItemsInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutSalesItemsInput, ProductsUpdateWithoutSalesItemsInput>, ProductsUncheckedUpdateWithoutSalesItemsInput>
  }

  export type SalesItemSerialsUpdateManyWithoutSalesItemsNestedInput = {
    create?: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput> | SalesItemSerialsCreateWithoutSalesItemsInput[] | SalesItemSerialsUncheckedCreateWithoutSalesItemsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutSalesItemsInput | SalesItemSerialsCreateOrConnectWithoutSalesItemsInput[]
    upsert?: SalesItemSerialsUpsertWithWhereUniqueWithoutSalesItemsInput | SalesItemSerialsUpsertWithWhereUniqueWithoutSalesItemsInput[]
    createMany?: SalesItemSerialsCreateManySalesItemsInputEnvelope
    set?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    disconnect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    delete?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    update?: SalesItemSerialsUpdateWithWhereUniqueWithoutSalesItemsInput | SalesItemSerialsUpdateWithWhereUniqueWithoutSalesItemsInput[]
    updateMany?: SalesItemSerialsUpdateManyWithWhereWithoutSalesItemsInput | SalesItemSerialsUpdateManyWithWhereWithoutSalesItemsInput[]
    deleteMany?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
  }

  export type SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsNestedInput = {
    create?: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput> | SalesItemSerialsCreateWithoutSalesItemsInput[] | SalesItemSerialsUncheckedCreateWithoutSalesItemsInput[]
    connectOrCreate?: SalesItemSerialsCreateOrConnectWithoutSalesItemsInput | SalesItemSerialsCreateOrConnectWithoutSalesItemsInput[]
    upsert?: SalesItemSerialsUpsertWithWhereUniqueWithoutSalesItemsInput | SalesItemSerialsUpsertWithWhereUniqueWithoutSalesItemsInput[]
    createMany?: SalesItemSerialsCreateManySalesItemsInputEnvelope
    set?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    disconnect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    delete?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    connect?: SalesItemSerialsWhereUniqueInput | SalesItemSerialsWhereUniqueInput[]
    update?: SalesItemSerialsUpdateWithWhereUniqueWithoutSalesItemsInput | SalesItemSerialsUpdateWithWhereUniqueWithoutSalesItemsInput[]
    updateMany?: SalesItemSerialsUpdateManyWithWhereWithoutSalesItemsInput | SalesItemSerialsUpdateManyWithWhereWithoutSalesItemsInput[]
    deleteMany?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
  }

  export type SalesItemsCreateNestedOneWithoutSalesItemSerialsInput = {
    create?: XOR<SalesItemsCreateWithoutSalesItemSerialsInput, SalesItemsUncheckedCreateWithoutSalesItemSerialsInput>
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesItemSerialsInput
    connect?: SalesItemsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutSalesItemSerialsInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type SalesItemsUpdateOneRequiredWithoutSalesItemSerialsNestedInput = {
    create?: XOR<SalesItemsCreateWithoutSalesItemSerialsInput, SalesItemsUncheckedCreateWithoutSalesItemSerialsInput>
    connectOrCreate?: SalesItemsCreateOrConnectWithoutSalesItemSerialsInput
    upsert?: SalesItemsUpsertWithoutSalesItemSerialsInput
    connect?: SalesItemsWhereUniqueInput
    update?: XOR<XOR<SalesItemsUpdateToOneWithWhereWithoutSalesItemSerialsInput, SalesItemsUpdateWithoutSalesItemSerialsInput>, SalesItemsUncheckedUpdateWithoutSalesItemSerialsInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutSalesItemSerialsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesItemSerialsInput
    upsert?: ProductSerialsUpsertWithoutSalesItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutSalesItemSerialsInput, ProductSerialsUpdateWithoutSalesItemSerialsInput>, ProductSerialsUncheckedUpdateWithoutSalesItemSerialsInput>
  }

  export type SalesCreateNestedOneWithoutSalesReturnInput = {
    create?: XOR<SalesCreateWithoutSalesReturnInput, SalesUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: SalesCreateOrConnectWithoutSalesReturnInput
    connect?: SalesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutSalesReturnInput = {
    create?: XOR<UsersCreateWithoutSalesReturnInput, UsersUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSalesReturnInput
    connect?: UsersWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutSalesReturnInput = {
    create?: XOR<CustomersCreateWithoutSalesReturnInput, CustomersUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSalesReturnInput
    connect?: CustomersWhereUniqueInput
  }

  export type SalesReturnItemsCreateNestedManyWithoutSalesReturnInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput> | SalesReturnItemsCreateWithoutSalesReturnInput[] | SalesReturnItemsUncheckedCreateWithoutSalesReturnInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnInput | SalesReturnItemsCreateOrConnectWithoutSalesReturnInput[]
    createMany?: SalesReturnItemsCreateManySalesReturnInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type SalesReturnItemsUncheckedCreateNestedManyWithoutSalesReturnInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput> | SalesReturnItemsCreateWithoutSalesReturnInput[] | SalesReturnItemsUncheckedCreateWithoutSalesReturnInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnInput | SalesReturnItemsCreateOrConnectWithoutSalesReturnInput[]
    createMany?: SalesReturnItemsCreateManySalesReturnInputEnvelope
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
  }

  export type SalesUpdateOneRequiredWithoutSalesReturnNestedInput = {
    create?: XOR<SalesCreateWithoutSalesReturnInput, SalesUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: SalesCreateOrConnectWithoutSalesReturnInput
    upsert?: SalesUpsertWithoutSalesReturnInput
    connect?: SalesWhereUniqueInput
    update?: XOR<XOR<SalesUpdateToOneWithWhereWithoutSalesReturnInput, SalesUpdateWithoutSalesReturnInput>, SalesUncheckedUpdateWithoutSalesReturnInput>
  }

  export type UsersUpdateOneRequiredWithoutSalesReturnNestedInput = {
    create?: XOR<UsersCreateWithoutSalesReturnInput, UsersUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSalesReturnInput
    upsert?: UsersUpsertWithoutSalesReturnInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSalesReturnInput, UsersUpdateWithoutSalesReturnInput>, UsersUncheckedUpdateWithoutSalesReturnInput>
  }

  export type CustomersUpdateOneRequiredWithoutSalesReturnNestedInput = {
    create?: XOR<CustomersCreateWithoutSalesReturnInput, CustomersUncheckedCreateWithoutSalesReturnInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSalesReturnInput
    upsert?: CustomersUpsertWithoutSalesReturnInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutSalesReturnInput, CustomersUpdateWithoutSalesReturnInput>, CustomersUncheckedUpdateWithoutSalesReturnInput>
  }

  export type SalesReturnItemsUpdateManyWithoutSalesReturnNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput> | SalesReturnItemsCreateWithoutSalesReturnInput[] | SalesReturnItemsUncheckedCreateWithoutSalesReturnInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnInput | SalesReturnItemsCreateOrConnectWithoutSalesReturnInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutSalesReturnInput | SalesReturnItemsUpsertWithWhereUniqueWithoutSalesReturnInput[]
    createMany?: SalesReturnItemsCreateManySalesReturnInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutSalesReturnInput | SalesReturnItemsUpdateWithWhereUniqueWithoutSalesReturnInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutSalesReturnInput | SalesReturnItemsUpdateManyWithWhereWithoutSalesReturnInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput> | SalesReturnItemsCreateWithoutSalesReturnInput[] | SalesReturnItemsUncheckedCreateWithoutSalesReturnInput[]
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnInput | SalesReturnItemsCreateOrConnectWithoutSalesReturnInput[]
    upsert?: SalesReturnItemsUpsertWithWhereUniqueWithoutSalesReturnInput | SalesReturnItemsUpsertWithWhereUniqueWithoutSalesReturnInput[]
    createMany?: SalesReturnItemsCreateManySalesReturnInputEnvelope
    set?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    disconnect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    delete?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    connect?: SalesReturnItemsWhereUniqueInput | SalesReturnItemsWhereUniqueInput[]
    update?: SalesReturnItemsUpdateWithWhereUniqueWithoutSalesReturnInput | SalesReturnItemsUpdateWithWhereUniqueWithoutSalesReturnInput[]
    updateMany?: SalesReturnItemsUpdateManyWithWhereWithoutSalesReturnInput | SalesReturnItemsUpdateManyWithWhereWithoutSalesReturnInput[]
    deleteMany?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutSalesReturnItemsInput = {
    create?: XOR<ProductsCreateWithoutSalesReturnItemsInput, ProductsUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutSalesReturnItemsInput
    connect?: ProductsWhereUniqueInput
  }

  export type SalesReturnCreateNestedOneWithoutSalesReturnItemsInput = {
    create?: XOR<SalesReturnCreateWithoutSalesReturnItemsInput, SalesReturnUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesReturnItemsInput
    connect?: SalesReturnWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutSalesReturnItemsInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesReturnItemsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesReturnItemsInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type SalesReturnItemSerialsCreateNestedManyWithoutSalesReturnItemsInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput> | SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput | SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput[]
    createMany?: SalesReturnItemSerialsCreateManySalesReturnItemsInputEnvelope
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
  }

  export type SalesReturnItemSerialsUncheckedCreateNestedManyWithoutSalesReturnItemsInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput> | SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput | SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput[]
    createMany?: SalesReturnItemSerialsCreateManySalesReturnItemsInputEnvelope
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
  }

  export type ProductsUpdateOneWithoutSalesReturnItemsNestedInput = {
    create?: XOR<ProductsCreateWithoutSalesReturnItemsInput, ProductsUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutSalesReturnItemsInput
    upsert?: ProductsUpsertWithoutSalesReturnItemsInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutSalesReturnItemsInput, ProductsUpdateWithoutSalesReturnItemsInput>, ProductsUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnUpdateOneWithoutSalesReturnItemsNestedInput = {
    create?: XOR<SalesReturnCreateWithoutSalesReturnItemsInput, SalesReturnUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: SalesReturnCreateOrConnectWithoutSalesReturnItemsInput
    upsert?: SalesReturnUpsertWithoutSalesReturnItemsInput
    disconnect?: SalesReturnWhereInput | boolean
    delete?: SalesReturnWhereInput | boolean
    connect?: SalesReturnWhereUniqueInput
    update?: XOR<XOR<SalesReturnUpdateToOneWithWhereWithoutSalesReturnItemsInput, SalesReturnUpdateWithoutSalesReturnItemsInput>, SalesReturnUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type ProductSerialsUpdateOneWithoutSalesReturnItemsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesReturnItemsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesReturnItemsInput
    upsert?: ProductSerialsUpsertWithoutSalesReturnItemsInput
    disconnect?: ProductSerialsWhereInput | boolean
    delete?: ProductSerialsWhereInput | boolean
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutSalesReturnItemsInput, ProductSerialsUpdateWithoutSalesReturnItemsInput>, ProductSerialsUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemSerialsUpdateManyWithoutSalesReturnItemsNestedInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput> | SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput | SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput[]
    upsert?: SalesReturnItemSerialsUpsertWithWhereUniqueWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpsertWithWhereUniqueWithoutSalesReturnItemsInput[]
    createMany?: SalesReturnItemSerialsCreateManySalesReturnItemsInputEnvelope
    set?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    disconnect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    delete?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    update?: SalesReturnItemSerialsUpdateWithWhereUniqueWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpdateWithWhereUniqueWithoutSalesReturnItemsInput[]
    updateMany?: SalesReturnItemSerialsUpdateManyWithWhereWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpdateManyWithWhereWithoutSalesReturnItemsInput[]
    deleteMany?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsNestedInput = {
    create?: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput> | SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput[] | SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput[]
    connectOrCreate?: SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput | SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput[]
    upsert?: SalesReturnItemSerialsUpsertWithWhereUniqueWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpsertWithWhereUniqueWithoutSalesReturnItemsInput[]
    createMany?: SalesReturnItemSerialsCreateManySalesReturnItemsInputEnvelope
    set?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    disconnect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    delete?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    connect?: SalesReturnItemSerialsWhereUniqueInput | SalesReturnItemSerialsWhereUniqueInput[]
    update?: SalesReturnItemSerialsUpdateWithWhereUniqueWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpdateWithWhereUniqueWithoutSalesReturnItemsInput[]
    updateMany?: SalesReturnItemSerialsUpdateManyWithWhereWithoutSalesReturnItemsInput | SalesReturnItemSerialsUpdateManyWithWhereWithoutSalesReturnItemsInput[]
    deleteMany?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
  }

  export type SalesReturnItemsCreateNestedOneWithoutSalesReturnItemSerialsInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnItemSerialsInput
    connect?: SalesReturnItemsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutSalesReturnItemSerialsInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesReturnItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type SalesReturnItemsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput = {
    create?: XOR<SalesReturnItemsCreateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    connectOrCreate?: SalesReturnItemsCreateOrConnectWithoutSalesReturnItemSerialsInput
    upsert?: SalesReturnItemsUpsertWithoutSalesReturnItemSerialsInput
    connect?: SalesReturnItemsWhereUniqueInput
    update?: XOR<XOR<SalesReturnItemsUpdateToOneWithWhereWithoutSalesReturnItemSerialsInput, SalesReturnItemsUpdateWithoutSalesReturnItemSerialsInput>, SalesReturnItemsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutSalesReturnItemSerialsInput
    upsert?: ProductSerialsUpsertWithoutSalesReturnItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutSalesReturnItemSerialsInput, ProductSerialsUpdateWithoutSalesReturnItemSerialsInput>, ProductSerialsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
  }

  export type SalesCreateNestedOneWithoutExchangesInput = {
    create?: XOR<SalesCreateWithoutExchangesInput, SalesUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: SalesCreateOrConnectWithoutExchangesInput
    connect?: SalesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutExchangesInput = {
    create?: XOR<UsersCreateWithoutExchangesInput, UsersUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutExchangesInput
    connect?: UsersWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutExchangesInput = {
    create?: XOR<CustomersCreateWithoutExchangesInput, CustomersUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutExchangesInput
    connect?: CustomersWhereUniqueInput
  }

  export type ExchangesItemsCreateNestedManyWithoutExchangesInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput> | ExchangesItemsCreateWithoutExchangesInput[] | ExchangesItemsUncheckedCreateWithoutExchangesInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangesInput | ExchangesItemsCreateOrConnectWithoutExchangesInput[]
    createMany?: ExchangesItemsCreateManyExchangesInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type ExchangesItemsUncheckedCreateNestedManyWithoutExchangesInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput> | ExchangesItemsCreateWithoutExchangesInput[] | ExchangesItemsUncheckedCreateWithoutExchangesInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangesInput | ExchangesItemsCreateOrConnectWithoutExchangesInput[]
    createMany?: ExchangesItemsCreateManyExchangesInputEnvelope
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
  }

  export type SalesUpdateOneWithoutExchangesNestedInput = {
    create?: XOR<SalesCreateWithoutExchangesInput, SalesUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: SalesCreateOrConnectWithoutExchangesInput
    upsert?: SalesUpsertWithoutExchangesInput
    disconnect?: SalesWhereInput | boolean
    delete?: SalesWhereInput | boolean
    connect?: SalesWhereUniqueInput
    update?: XOR<XOR<SalesUpdateToOneWithWhereWithoutExchangesInput, SalesUpdateWithoutExchangesInput>, SalesUncheckedUpdateWithoutExchangesInput>
  }

  export type UsersUpdateOneWithoutExchangesNestedInput = {
    create?: XOR<UsersCreateWithoutExchangesInput, UsersUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutExchangesInput
    upsert?: UsersUpsertWithoutExchangesInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutExchangesInput, UsersUpdateWithoutExchangesInput>, UsersUncheckedUpdateWithoutExchangesInput>
  }

  export type CustomersUpdateOneWithoutExchangesNestedInput = {
    create?: XOR<CustomersCreateWithoutExchangesInput, CustomersUncheckedCreateWithoutExchangesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutExchangesInput
    upsert?: CustomersUpsertWithoutExchangesInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutExchangesInput, CustomersUpdateWithoutExchangesInput>, CustomersUncheckedUpdateWithoutExchangesInput>
  }

  export type ExchangesItemsUpdateManyWithoutExchangesNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput> | ExchangesItemsCreateWithoutExchangesInput[] | ExchangesItemsUncheckedCreateWithoutExchangesInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangesInput | ExchangesItemsCreateOrConnectWithoutExchangesInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutExchangesInput | ExchangesItemsUpsertWithWhereUniqueWithoutExchangesInput[]
    createMany?: ExchangesItemsCreateManyExchangesInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutExchangesInput | ExchangesItemsUpdateWithWhereUniqueWithoutExchangesInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutExchangesInput | ExchangesItemsUpdateManyWithWhereWithoutExchangesInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutExchangesNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput> | ExchangesItemsCreateWithoutExchangesInput[] | ExchangesItemsUncheckedCreateWithoutExchangesInput[]
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangesInput | ExchangesItemsCreateOrConnectWithoutExchangesInput[]
    upsert?: ExchangesItemsUpsertWithWhereUniqueWithoutExchangesInput | ExchangesItemsUpsertWithWhereUniqueWithoutExchangesInput[]
    createMany?: ExchangesItemsCreateManyExchangesInputEnvelope
    set?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    disconnect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    delete?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    connect?: ExchangesItemsWhereUniqueInput | ExchangesItemsWhereUniqueInput[]
    update?: ExchangesItemsUpdateWithWhereUniqueWithoutExchangesInput | ExchangesItemsUpdateWithWhereUniqueWithoutExchangesInput[]
    updateMany?: ExchangesItemsUpdateManyWithWhereWithoutExchangesInput | ExchangesItemsUpdateManyWithWhereWithoutExchangesInput[]
    deleteMany?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutExchangeItemsOldInput = {
    create?: XOR<ProductsCreateWithoutExchangeItemsOldInput, ProductsUncheckedCreateWithoutExchangeItemsOldInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutExchangeItemsOldInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutExchangeItemsNewInput = {
    create?: XOR<ProductsCreateWithoutExchangeItemsNewInput, ProductsUncheckedCreateWithoutExchangeItemsNewInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutExchangeItemsNewInput
    connect?: ProductsWhereUniqueInput
  }

  export type ExchangesCreateNestedOneWithoutExchangeItemsInput = {
    create?: XOR<ExchangesCreateWithoutExchangeItemsInput, ExchangesUncheckedCreateWithoutExchangeItemsInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutExchangeItemsInput
    connect?: ExchangesWhereUniqueInput
  }

  export type ExchangeItemSerialsCreateNestedManyWithoutExchangesItemsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput> | ExchangeItemSerialsCreateWithoutExchangesItemsInput[] | ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput | ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput[]
    createMany?: ExchangeItemSerialsCreateManyExchangesItemsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type ExchangeItemSerialsUncheckedCreateNestedManyWithoutExchangesItemsInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput> | ExchangeItemSerialsCreateWithoutExchangesItemsInput[] | ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput | ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput[]
    createMany?: ExchangeItemSerialsCreateManyExchangesItemsInputEnvelope
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
  }

  export type ProductsUpdateOneWithoutExchangeItemsOldNestedInput = {
    create?: XOR<ProductsCreateWithoutExchangeItemsOldInput, ProductsUncheckedCreateWithoutExchangeItemsOldInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutExchangeItemsOldInput
    upsert?: ProductsUpsertWithoutExchangeItemsOldInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutExchangeItemsOldInput, ProductsUpdateWithoutExchangeItemsOldInput>, ProductsUncheckedUpdateWithoutExchangeItemsOldInput>
  }

  export type ProductsUpdateOneWithoutExchangeItemsNewNestedInput = {
    create?: XOR<ProductsCreateWithoutExchangeItemsNewInput, ProductsUncheckedCreateWithoutExchangeItemsNewInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutExchangeItemsNewInput
    upsert?: ProductsUpsertWithoutExchangeItemsNewInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutExchangeItemsNewInput, ProductsUpdateWithoutExchangeItemsNewInput>, ProductsUncheckedUpdateWithoutExchangeItemsNewInput>
  }

  export type ExchangesUpdateOneWithoutExchangeItemsNestedInput = {
    create?: XOR<ExchangesCreateWithoutExchangeItemsInput, ExchangesUncheckedCreateWithoutExchangeItemsInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutExchangeItemsInput
    upsert?: ExchangesUpsertWithoutExchangeItemsInput
    disconnect?: ExchangesWhereInput | boolean
    delete?: ExchangesWhereInput | boolean
    connect?: ExchangesWhereUniqueInput
    update?: XOR<XOR<ExchangesUpdateToOneWithWhereWithoutExchangeItemsInput, ExchangesUpdateWithoutExchangeItemsInput>, ExchangesUncheckedUpdateWithoutExchangeItemsInput>
  }

  export type ExchangeItemSerialsUpdateManyWithoutExchangesItemsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput> | ExchangeItemSerialsCreateWithoutExchangesItemsInput[] | ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput | ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutExchangesItemsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutExchangesItemsInput[]
    createMany?: ExchangeItemSerialsCreateManyExchangesItemsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutExchangesItemsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutExchangesItemsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutExchangesItemsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutExchangesItemsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsNestedInput = {
    create?: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput> | ExchangeItemSerialsCreateWithoutExchangesItemsInput[] | ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput[]
    connectOrCreate?: ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput | ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput[]
    upsert?: ExchangeItemSerialsUpsertWithWhereUniqueWithoutExchangesItemsInput | ExchangeItemSerialsUpsertWithWhereUniqueWithoutExchangesItemsInput[]
    createMany?: ExchangeItemSerialsCreateManyExchangesItemsInputEnvelope
    set?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    disconnect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    delete?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    connect?: ExchangeItemSerialsWhereUniqueInput | ExchangeItemSerialsWhereUniqueInput[]
    update?: ExchangeItemSerialsUpdateWithWhereUniqueWithoutExchangesItemsInput | ExchangeItemSerialsUpdateWithWhereUniqueWithoutExchangesItemsInput[]
    updateMany?: ExchangeItemSerialsUpdateManyWithWhereWithoutExchangesItemsInput | ExchangeItemSerialsUpdateManyWithWhereWithoutExchangesItemsInput[]
    deleteMany?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
  }

  export type ExchangesItemsCreateNestedOneWithoutExchangeItemSerialsInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedCreateWithoutExchangeItemSerialsInput>
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangeItemSerialsInput
    connect?: ExchangesItemsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutExchangeItemSerialsOldInput = {
    create?: XOR<ProductSerialsCreateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsOldInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutExchangeItemSerialsOldInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutExchangeItemSerialsNewInput = {
    create?: XOR<ProductSerialsCreateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsNewInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutExchangeItemSerialsNewInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type ExchangesItemsUpdateOneRequiredWithoutExchangeItemSerialsNestedInput = {
    create?: XOR<ExchangesItemsCreateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedCreateWithoutExchangeItemSerialsInput>
    connectOrCreate?: ExchangesItemsCreateOrConnectWithoutExchangeItemSerialsInput
    upsert?: ExchangesItemsUpsertWithoutExchangeItemSerialsInput
    connect?: ExchangesItemsWhereUniqueInput
    update?: XOR<XOR<ExchangesItemsUpdateToOneWithWhereWithoutExchangeItemSerialsInput, ExchangesItemsUpdateWithoutExchangeItemSerialsInput>, ExchangesItemsUncheckedUpdateWithoutExchangeItemSerialsInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsOldNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsOldInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutExchangeItemSerialsOldInput
    upsert?: ProductSerialsUpsertWithoutExchangeItemSerialsOldInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutExchangeItemSerialsOldInput, ProductSerialsUpdateWithoutExchangeItemSerialsOldInput>, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsOldInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsNewNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsNewInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutExchangeItemSerialsNewInput
    upsert?: ProductSerialsUpsertWithoutExchangeItemSerialsNewInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutExchangeItemSerialsNewInput, ProductSerialsUpdateWithoutExchangeItemSerialsNewInput>, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsNewInput>
  }

  export type SuppliersCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<SuppliersCreateWithoutPurchasesInput, SuppliersUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutPurchasesInput
    connect?: SuppliersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UsersCreateWithoutPurchasesInput, UsersUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesInput
    connect?: UsersWhereUniqueInput
  }

  export type PurchasesItemsCreateNestedManyWithoutPurchasesInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput> | PurchasesItemsCreateWithoutPurchasesInput[] | PurchasesItemsUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchasesInput | PurchasesItemsCreateOrConnectWithoutPurchasesInput[]
    createMany?: PurchasesItemsCreateManyPurchasesInputEnvelope
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
  }

  export type PurchasesReturnCreateNestedManyWithoutPurchasesInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput> | PurchasesReturnCreateWithoutPurchasesInput[] | PurchasesReturnUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesInput | PurchasesReturnCreateOrConnectWithoutPurchasesInput[]
    createMany?: PurchasesReturnCreateManyPurchasesInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type PurchasesItemsUncheckedCreateNestedManyWithoutPurchasesInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput> | PurchasesItemsCreateWithoutPurchasesInput[] | PurchasesItemsUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchasesInput | PurchasesItemsCreateOrConnectWithoutPurchasesInput[]
    createMany?: PurchasesItemsCreateManyPurchasesInputEnvelope
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
  }

  export type PurchasesReturnUncheckedCreateNestedManyWithoutPurchasesInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput> | PurchasesReturnCreateWithoutPurchasesInput[] | PurchasesReturnUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesInput | PurchasesReturnCreateOrConnectWithoutPurchasesInput[]
    createMany?: PurchasesReturnCreateManyPurchasesInputEnvelope
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
  }

  export type SuppliersUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<SuppliersCreateWithoutPurchasesInput, SuppliersUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutPurchasesInput
    upsert?: SuppliersUpsertWithoutPurchasesInput
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutPurchasesInput, SuppliersUpdateWithoutPurchasesInput>, SuppliersUncheckedUpdateWithoutPurchasesInput>
  }

  export type UsersUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UsersCreateWithoutPurchasesInput, UsersUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesInput
    upsert?: UsersUpsertWithoutPurchasesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPurchasesInput, UsersUpdateWithoutPurchasesInput>, UsersUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchasesItemsUpdateManyWithoutPurchasesNestedInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput> | PurchasesItemsCreateWithoutPurchasesInput[] | PurchasesItemsUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchasesInput | PurchasesItemsCreateOrConnectWithoutPurchasesInput[]
    upsert?: PurchasesItemsUpsertWithWhereUniqueWithoutPurchasesInput | PurchasesItemsUpsertWithWhereUniqueWithoutPurchasesInput[]
    createMany?: PurchasesItemsCreateManyPurchasesInputEnvelope
    set?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    disconnect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    delete?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    update?: PurchasesItemsUpdateWithWhereUniqueWithoutPurchasesInput | PurchasesItemsUpdateWithWhereUniqueWithoutPurchasesInput[]
    updateMany?: PurchasesItemsUpdateManyWithWhereWithoutPurchasesInput | PurchasesItemsUpdateManyWithWhereWithoutPurchasesInput[]
    deleteMany?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
  }

  export type PurchasesReturnUpdateManyWithoutPurchasesNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput> | PurchasesReturnCreateWithoutPurchasesInput[] | PurchasesReturnUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesInput | PurchasesReturnCreateOrConnectWithoutPurchasesInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutPurchasesInput | PurchasesReturnUpsertWithWhereUniqueWithoutPurchasesInput[]
    createMany?: PurchasesReturnCreateManyPurchasesInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutPurchasesInput | PurchasesReturnUpdateWithWhereUniqueWithoutPurchasesInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutPurchasesInput | PurchasesReturnUpdateManyWithWhereWithoutPurchasesInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type PurchasesItemsUncheckedUpdateManyWithoutPurchasesNestedInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput> | PurchasesItemsCreateWithoutPurchasesInput[] | PurchasesItemsUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchasesInput | PurchasesItemsCreateOrConnectWithoutPurchasesInput[]
    upsert?: PurchasesItemsUpsertWithWhereUniqueWithoutPurchasesInput | PurchasesItemsUpsertWithWhereUniqueWithoutPurchasesInput[]
    createMany?: PurchasesItemsCreateManyPurchasesInputEnvelope
    set?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    disconnect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    delete?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    connect?: PurchasesItemsWhereUniqueInput | PurchasesItemsWhereUniqueInput[]
    update?: PurchasesItemsUpdateWithWhereUniqueWithoutPurchasesInput | PurchasesItemsUpdateWithWhereUniqueWithoutPurchasesInput[]
    updateMany?: PurchasesItemsUpdateManyWithWhereWithoutPurchasesInput | PurchasesItemsUpdateManyWithWhereWithoutPurchasesInput[]
    deleteMany?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutPurchasesNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput> | PurchasesReturnCreateWithoutPurchasesInput[] | PurchasesReturnUncheckedCreateWithoutPurchasesInput[]
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesInput | PurchasesReturnCreateOrConnectWithoutPurchasesInput[]
    upsert?: PurchasesReturnUpsertWithWhereUniqueWithoutPurchasesInput | PurchasesReturnUpsertWithWhereUniqueWithoutPurchasesInput[]
    createMany?: PurchasesReturnCreateManyPurchasesInputEnvelope
    set?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    disconnect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    delete?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    connect?: PurchasesReturnWhereUniqueInput | PurchasesReturnWhereUniqueInput[]
    update?: PurchasesReturnUpdateWithWhereUniqueWithoutPurchasesInput | PurchasesReturnUpdateWithWhereUniqueWithoutPurchasesInput[]
    updateMany?: PurchasesReturnUpdateManyWithWhereWithoutPurchasesInput | PurchasesReturnUpdateManyWithWhereWithoutPurchasesInput[]
    deleteMany?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
  }

  export type PurchasesCreateNestedOneWithoutPurchasesItemsInput = {
    create?: XOR<PurchasesCreateWithoutPurchasesItemsInput, PurchasesUncheckedCreateWithoutPurchasesItemsInput>
    connectOrCreate?: PurchasesCreateOrConnectWithoutPurchasesItemsInput
    connect?: PurchasesWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutPurchasesItemsInput = {
    create?: XOR<ProductsCreateWithoutPurchasesItemsInput, ProductsUncheckedCreateWithoutPurchasesItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPurchasesItemsInput
    connect?: ProductsWhereUniqueInput
  }

  export type PurchaseItemSerialsCreateNestedManyWithoutPurchasesItemsInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput> | PurchaseItemSerialsCreateWithoutPurchasesItemsInput[] | PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput | PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput[]
    createMany?: PurchaseItemSerialsCreateManyPurchasesItemsInputEnvelope
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
  }

  export type PurchaseItemSerialsUncheckedCreateNestedManyWithoutPurchasesItemsInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput> | PurchaseItemSerialsCreateWithoutPurchasesItemsInput[] | PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput | PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput[]
    createMany?: PurchaseItemSerialsCreateManyPurchasesItemsInputEnvelope
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
  }

  export type PurchasesUpdateOneRequiredWithoutPurchasesItemsNestedInput = {
    create?: XOR<PurchasesCreateWithoutPurchasesItemsInput, PurchasesUncheckedCreateWithoutPurchasesItemsInput>
    connectOrCreate?: PurchasesCreateOrConnectWithoutPurchasesItemsInput
    upsert?: PurchasesUpsertWithoutPurchasesItemsInput
    connect?: PurchasesWhereUniqueInput
    update?: XOR<XOR<PurchasesUpdateToOneWithWhereWithoutPurchasesItemsInput, PurchasesUpdateWithoutPurchasesItemsInput>, PurchasesUncheckedUpdateWithoutPurchasesItemsInput>
  }

  export type ProductsUpdateOneRequiredWithoutPurchasesItemsNestedInput = {
    create?: XOR<ProductsCreateWithoutPurchasesItemsInput, ProductsUncheckedCreateWithoutPurchasesItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPurchasesItemsInput
    upsert?: ProductsUpsertWithoutPurchasesItemsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutPurchasesItemsInput, ProductsUpdateWithoutPurchasesItemsInput>, ProductsUncheckedUpdateWithoutPurchasesItemsInput>
  }

  export type PurchaseItemSerialsUpdateManyWithoutPurchasesItemsNestedInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput> | PurchaseItemSerialsCreateWithoutPurchasesItemsInput[] | PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput | PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput[]
    upsert?: PurchaseItemSerialsUpsertWithWhereUniqueWithoutPurchasesItemsInput | PurchaseItemSerialsUpsertWithWhereUniqueWithoutPurchasesItemsInput[]
    createMany?: PurchaseItemSerialsCreateManyPurchasesItemsInputEnvelope
    set?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    delete?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    update?: PurchaseItemSerialsUpdateWithWhereUniqueWithoutPurchasesItemsInput | PurchaseItemSerialsUpdateWithWhereUniqueWithoutPurchasesItemsInput[]
    updateMany?: PurchaseItemSerialsUpdateManyWithWhereWithoutPurchasesItemsInput | PurchaseItemSerialsUpdateManyWithWhereWithoutPurchasesItemsInput[]
    deleteMany?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
  }

  export type PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsNestedInput = {
    create?: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput> | PurchaseItemSerialsCreateWithoutPurchasesItemsInput[] | PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput[]
    connectOrCreate?: PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput | PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput[]
    upsert?: PurchaseItemSerialsUpsertWithWhereUniqueWithoutPurchasesItemsInput | PurchaseItemSerialsUpsertWithWhereUniqueWithoutPurchasesItemsInput[]
    createMany?: PurchaseItemSerialsCreateManyPurchasesItemsInputEnvelope
    set?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    delete?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    connect?: PurchaseItemSerialsWhereUniqueInput | PurchaseItemSerialsWhereUniqueInput[]
    update?: PurchaseItemSerialsUpdateWithWhereUniqueWithoutPurchasesItemsInput | PurchaseItemSerialsUpdateWithWhereUniqueWithoutPurchasesItemsInput[]
    updateMany?: PurchaseItemSerialsUpdateManyWithWhereWithoutPurchasesItemsInput | PurchaseItemSerialsUpdateManyWithWhereWithoutPurchasesItemsInput[]
    deleteMany?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
  }

  export type PurchasesItemsCreateNestedOneWithoutPurchaseItemSerialsInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedCreateWithoutPurchaseItemSerialsInput>
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchaseItemSerialsInput
    connect?: PurchasesItemsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutPurchaseItemSerialsInput = {
    create?: XOR<ProductSerialsCreateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutPurchaseItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type PurchasesItemsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput = {
    create?: XOR<PurchasesItemsCreateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedCreateWithoutPurchaseItemSerialsInput>
    connectOrCreate?: PurchasesItemsCreateOrConnectWithoutPurchaseItemSerialsInput
    upsert?: PurchasesItemsUpsertWithoutPurchaseItemSerialsInput
    connect?: PurchasesItemsWhereUniqueInput
    update?: XOR<XOR<PurchasesItemsUpdateToOneWithWhereWithoutPurchaseItemSerialsInput, PurchasesItemsUpdateWithoutPurchaseItemSerialsInput>, PurchasesItemsUncheckedUpdateWithoutPurchaseItemSerialsInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutPurchaseItemSerialsInput
    upsert?: ProductSerialsUpsertWithoutPurchaseItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutPurchaseItemSerialsInput, ProductSerialsUpdateWithoutPurchaseItemSerialsInput>, ProductSerialsUncheckedUpdateWithoutPurchaseItemSerialsInput>
  }

  export type PurchasesCreateNestedOneWithoutPurchasesReturnInput = {
    create?: XOR<PurchasesCreateWithoutPurchasesReturnInput, PurchasesUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: PurchasesCreateOrConnectWithoutPurchasesReturnInput
    connect?: PurchasesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPurchasesReturnInput = {
    create?: XOR<UsersCreateWithoutPurchasesReturnInput, UsersUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesReturnInput
    connect?: UsersWhereUniqueInput
  }

  export type SuppliersCreateNestedOneWithoutPurchasesReturnInput = {
    create?: XOR<SuppliersCreateWithoutPurchasesReturnInput, SuppliersUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutPurchasesReturnInput
    connect?: SuppliersWhereUniqueInput
  }

  export type PurchasesReturnItemsCreateNestedManyWithoutPurchasesReturnInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput> | PurchasesReturnItemsCreateWithoutPurchasesReturnInput[] | PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput | PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput[]
    createMany?: PurchasesReturnItemsCreateManyPurchasesReturnInputEnvelope
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
  }

  export type PurchasesReturnItemsUncheckedCreateNestedManyWithoutPurchasesReturnInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput> | PurchasesReturnItemsCreateWithoutPurchasesReturnInput[] | PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput | PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput[]
    createMany?: PurchasesReturnItemsCreateManyPurchasesReturnInputEnvelope
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
  }

  export type PurchasesUpdateOneRequiredWithoutPurchasesReturnNestedInput = {
    create?: XOR<PurchasesCreateWithoutPurchasesReturnInput, PurchasesUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: PurchasesCreateOrConnectWithoutPurchasesReturnInput
    upsert?: PurchasesUpsertWithoutPurchasesReturnInput
    connect?: PurchasesWhereUniqueInput
    update?: XOR<XOR<PurchasesUpdateToOneWithWhereWithoutPurchasesReturnInput, PurchasesUpdateWithoutPurchasesReturnInput>, PurchasesUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type UsersUpdateOneRequiredWithoutPurchasesReturnNestedInput = {
    create?: XOR<UsersCreateWithoutPurchasesReturnInput, UsersUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPurchasesReturnInput
    upsert?: UsersUpsertWithoutPurchasesReturnInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPurchasesReturnInput, UsersUpdateWithoutPurchasesReturnInput>, UsersUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type SuppliersUpdateOneRequiredWithoutPurchasesReturnNestedInput = {
    create?: XOR<SuppliersCreateWithoutPurchasesReturnInput, SuppliersUncheckedCreateWithoutPurchasesReturnInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutPurchasesReturnInput
    upsert?: SuppliersUpsertWithoutPurchasesReturnInput
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutPurchasesReturnInput, SuppliersUpdateWithoutPurchasesReturnInput>, SuppliersUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type PurchasesReturnItemsUpdateManyWithoutPurchasesReturnNestedInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput> | PurchasesReturnItemsCreateWithoutPurchasesReturnInput[] | PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput | PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput[]
    upsert?: PurchasesReturnItemsUpsertWithWhereUniqueWithoutPurchasesReturnInput | PurchasesReturnItemsUpsertWithWhereUniqueWithoutPurchasesReturnInput[]
    createMany?: PurchasesReturnItemsCreateManyPurchasesReturnInputEnvelope
    set?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    disconnect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    delete?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    update?: PurchasesReturnItemsUpdateWithWhereUniqueWithoutPurchasesReturnInput | PurchasesReturnItemsUpdateWithWhereUniqueWithoutPurchasesReturnInput[]
    updateMany?: PurchasesReturnItemsUpdateManyWithWhereWithoutPurchasesReturnInput | PurchasesReturnItemsUpdateManyWithWhereWithoutPurchasesReturnInput[]
    deleteMany?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
  }

  export type PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnNestedInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput> | PurchasesReturnItemsCreateWithoutPurchasesReturnInput[] | PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput[]
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput | PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput[]
    upsert?: PurchasesReturnItemsUpsertWithWhereUniqueWithoutPurchasesReturnInput | PurchasesReturnItemsUpsertWithWhereUniqueWithoutPurchasesReturnInput[]
    createMany?: PurchasesReturnItemsCreateManyPurchasesReturnInputEnvelope
    set?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    disconnect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    delete?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    connect?: PurchasesReturnItemsWhereUniqueInput | PurchasesReturnItemsWhereUniqueInput[]
    update?: PurchasesReturnItemsUpdateWithWhereUniqueWithoutPurchasesReturnInput | PurchasesReturnItemsUpdateWithWhereUniqueWithoutPurchasesReturnInput[]
    updateMany?: PurchasesReturnItemsUpdateManyWithWhereWithoutPurchasesReturnInput | PurchasesReturnItemsUpdateManyWithWhereWithoutPurchasesReturnInput[]
    deleteMany?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
  }

  export type ProductsCreateNestedOneWithoutPurchasesReturnItemsInput = {
    create?: XOR<ProductsCreateWithoutPurchasesReturnItemsInput, ProductsUncheckedCreateWithoutPurchasesReturnItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPurchasesReturnItemsInput
    connect?: ProductsWhereUniqueInput
  }

  export type PurchasesReturnCreateNestedOneWithoutPurchasesReturnItemsInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedCreateWithoutPurchasesReturnItemsInput>
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesReturnItemsInput
    connect?: PurchasesReturnWhereUniqueInput
  }

  export type PurchaseReturnItemSerialsCreateNestedManyWithoutPurchasesReturnItemsInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput> | PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInputEnvelope
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
  }

  export type PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutPurchasesReturnItemsInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput> | PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInputEnvelope
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
  }

  export type ProductsUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput = {
    create?: XOR<ProductsCreateWithoutPurchasesReturnItemsInput, ProductsUncheckedCreateWithoutPurchasesReturnItemsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPurchasesReturnItemsInput
    upsert?: ProductsUpsertWithoutPurchasesReturnItemsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutPurchasesReturnItemsInput, ProductsUpdateWithoutPurchasesReturnItemsInput>, ProductsUncheckedUpdateWithoutPurchasesReturnItemsInput>
  }

  export type PurchasesReturnUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput = {
    create?: XOR<PurchasesReturnCreateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedCreateWithoutPurchasesReturnItemsInput>
    connectOrCreate?: PurchasesReturnCreateOrConnectWithoutPurchasesReturnItemsInput
    upsert?: PurchasesReturnUpsertWithoutPurchasesReturnItemsInput
    connect?: PurchasesReturnWhereUniqueInput
    update?: XOR<XOR<PurchasesReturnUpdateToOneWithWhereWithoutPurchasesReturnItemsInput, PurchasesReturnUpdateWithoutPurchasesReturnItemsInput>, PurchasesReturnUncheckedUpdateWithoutPurchasesReturnItemsInput>
  }

  export type PurchaseReturnItemSerialsUpdateManyWithoutPurchasesReturnItemsNestedInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput> | PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput[]
    upsert?: PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutPurchasesReturnItemsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInputEnvelope
    set?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    delete?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    update?: PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutPurchasesReturnItemsInput[]
    updateMany?: PurchaseReturnItemSerialsUpdateManyWithWhereWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpdateManyWithWhereWithoutPurchasesReturnItemsInput[]
    deleteMany?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsNestedInput = {
    create?: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput> | PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput[] | PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput[]
    connectOrCreate?: PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput[]
    upsert?: PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutPurchasesReturnItemsInput[]
    createMany?: PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInputEnvelope
    set?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    disconnect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    delete?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    connect?: PurchaseReturnItemSerialsWhereUniqueInput | PurchaseReturnItemSerialsWhereUniqueInput[]
    update?: PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutPurchasesReturnItemsInput[]
    updateMany?: PurchaseReturnItemSerialsUpdateManyWithWhereWithoutPurchasesReturnItemsInput | PurchaseReturnItemSerialsUpdateManyWithWhereWithoutPurchasesReturnItemsInput[]
    deleteMany?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
  }

  export type PurchasesReturnItemsCreateNestedOneWithoutPurchaseReturnItemSerialsInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchaseReturnItemSerialsInput
    connect?: PurchasesReturnItemsWhereUniqueInput
  }

  export type ProductSerialsCreateNestedOneWithoutPurchaseReturnItemSerialsInput = {
    create?: XOR<ProductSerialsCreateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutPurchaseReturnItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
  }

  export type PurchasesReturnItemsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput = {
    create?: XOR<PurchasesReturnItemsCreateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    connectOrCreate?: PurchasesReturnItemsCreateOrConnectWithoutPurchaseReturnItemSerialsInput
    upsert?: PurchasesReturnItemsUpsertWithoutPurchaseReturnItemSerialsInput
    connect?: PurchasesReturnItemsWhereUniqueInput
    update?: XOR<XOR<PurchasesReturnItemsUpdateToOneWithWhereWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUpdateWithoutPurchaseReturnItemSerialsInput>, PurchasesReturnItemsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
  }

  export type ProductSerialsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput = {
    create?: XOR<ProductSerialsCreateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    connectOrCreate?: ProductSerialsCreateOrConnectWithoutPurchaseReturnItemSerialsInput
    upsert?: ProductSerialsUpsertWithoutPurchaseReturnItemSerialsInput
    connect?: ProductSerialsWhereUniqueInput
    update?: XOR<XOR<ProductSerialsUpdateToOneWithWhereWithoutPurchaseReturnItemSerialsInput, ProductSerialsUpdateWithoutPurchaseReturnItemSerialsInput>, ProductSerialsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
  }

  export type CustomersCreateNestedOneWithoutServicesInput = {
    create?: XOR<CustomersCreateWithoutServicesInput, CustomersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutServicesInput
    connect?: CustomersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutServicesInput = {
    create?: XOR<UsersCreateWithoutServicesInput, UsersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutServicesInput
    connect?: UsersWhereUniqueInput
  }

  export type CustomersUpdateOneWithoutServicesNestedInput = {
    create?: XOR<CustomersCreateWithoutServicesInput, CustomersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutServicesInput
    upsert?: CustomersUpsertWithoutServicesInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutServicesInput, CustomersUpdateWithoutServicesInput>, CustomersUncheckedUpdateWithoutServicesInput>
  }

  export type UsersUpdateOneWithoutServicesNestedInput = {
    create?: XOR<UsersCreateWithoutServicesInput, UsersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutServicesInput
    upsert?: UsersUpsertWithoutServicesInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutServicesInput, UsersUpdateWithoutServicesInput>, UsersUncheckedUpdateWithoutServicesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSerialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SerialStatus | EnumSerialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSerialStatusFilter<$PrismaModel> | $Enums.SerialStatus
  }

  export type NestedEnumWarrantyFilter<$PrismaModel = never> = {
    equals?: $Enums.Warranty | EnumWarrantyFieldRefInput<$PrismaModel>
    in?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    not?: NestedEnumWarrantyFilter<$PrismaModel> | $Enums.Warranty
  }

  export type NestedEnumSerialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SerialStatus | EnumSerialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SerialStatus[] | ListEnumSerialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSerialStatusWithAggregatesFilter<$PrismaModel> | $Enums.SerialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSerialStatusFilter<$PrismaModel>
    _max?: NestedEnumSerialStatusFilter<$PrismaModel>
  }

  export type NestedEnumWarrantyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Warranty | EnumWarrantyFieldRefInput<$PrismaModel>
    in?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Warranty[] | ListEnumWarrantyFieldRefInput<$PrismaModel>
    not?: NestedEnumWarrantyWithAggregatesFilter<$PrismaModel> | $Enums.Warranty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWarrantyFilter<$PrismaModel>
    _max?: NestedEnumWarrantyFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RolePermissionsCreateWithoutPermissionsInput = {
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Roles: RolesCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateWithoutPermissionsInput = {
    id?: number
    role_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsCreateOrConnectWithoutPermissionsInput = {
    where: RolePermissionsWhereUniqueInput
    create: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type RolePermissionsCreateManyPermissionsInputEnvelope = {
    data: RolePermissionsCreateManyPermissionsInput | RolePermissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: RolePermissionsWhereUniqueInput
    update: XOR<RolePermissionsUpdateWithoutPermissionsInput, RolePermissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RolePermissionsCreateWithoutPermissionsInput, RolePermissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type RolePermissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: RolePermissionsWhereUniqueInput
    data: XOR<RolePermissionsUpdateWithoutPermissionsInput, RolePermissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type RolePermissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: RolePermissionsScalarWhereInput
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type RolePermissionsScalarWhereInput = {
    AND?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
    OR?: RolePermissionsScalarWhereInput[]
    NOT?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
    id?: IntFilter<"RolePermissions"> | number
    role_id?: IntFilter<"RolePermissions"> | number
    permission_id?: IntFilter<"RolePermissions"> | number
    can_view?: BoolFilter<"RolePermissions"> | boolean
    can_create?: BoolFilter<"RolePermissions"> | boolean
    can_edit?: BoolFilter<"RolePermissions"> | boolean
    can_delete?: BoolFilter<"RolePermissions"> | boolean
  }

  export type RolesCreateWithoutRolePermissionsInput = {
    name: string
    Users?: UsersCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    Users?: UsersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesCreateOrConnectWithoutRolePermissionsInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutRolePermissionsInput, RolesUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionsCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
  }

  export type PermissionsUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type PermissionsCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutRolePermissionsInput, PermissionsUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RolesUpsertWithoutRolePermissionsInput = {
    update: XOR<RolesUpdateWithoutRolePermissionsInput, RolesUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RolesCreateWithoutRolePermissionsInput, RolesUncheckedCreateWithoutRolePermissionsInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutRolePermissionsInput, RolesUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RolesUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Users?: UsersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type PermissionsUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionsUpdateWithoutRolePermissionsInput, PermissionsUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionsCreateWithoutRolePermissionsInput, PermissionsUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionsWhereInput
  }

  export type PermissionsUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionsWhereInput
    data: XOR<PermissionsUpdateWithoutRolePermissionsInput, PermissionsUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionsUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionsUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateWithoutRolesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutRolesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutRolesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput>
  }

  export type UsersCreateManyRolesInputEnvelope = {
    data: UsersCreateManyRolesInput | UsersCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionsCreateWithoutRolesInput = {
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
    Permissions: PermissionsCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateWithoutRolesInput = {
    id?: number
    permission_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsCreateOrConnectWithoutRolesInput = {
    where: RolePermissionsWhereUniqueInput
    create: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput>
  }

  export type RolePermissionsCreateManyRolesInputEnvelope = {
    data: RolePermissionsCreateManyRolesInput | RolePermissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutRolesInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutRolesInput, UsersUncheckedUpdateWithoutRolesInput>
    create: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutRolesInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutRolesInput, UsersUncheckedUpdateWithoutRolesInput>
  }

  export type UsersUpdateManyWithWhereWithoutRolesInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutRolesInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: IntFilter<"Users"> | number
    userId?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    status?: EnumStatusFilter<"Users"> | $Enums.Status
    role_id?: IntFilter<"Users"> | number
    phone?: StringNullableFilter<"Users"> | string | null
    address?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    permissionOverrides?: JsonNullableFilter<"Users">
  }

  export type RolePermissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: RolePermissionsWhereUniqueInput
    update: XOR<RolePermissionsUpdateWithoutRolesInput, RolePermissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<RolePermissionsCreateWithoutRolesInput, RolePermissionsUncheckedCreateWithoutRolesInput>
  }

  export type RolePermissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: RolePermissionsWhereUniqueInput
    data: XOR<RolePermissionsUpdateWithoutRolesInput, RolePermissionsUncheckedUpdateWithoutRolesInput>
  }

  export type RolePermissionsUpdateManyWithWhereWithoutRolesInput = {
    where: RolePermissionsScalarWhereInput
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type UsersCreateWithoutSessionInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutSessionInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutSessionInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSessionInput, UsersUncheckedCreateWithoutSessionInput>
  }

  export type UsersUpsertWithoutSessionInput = {
    update: XOR<UsersUpdateWithoutSessionInput, UsersUncheckedUpdateWithoutSessionInput>
    create: XOR<UsersCreateWithoutSessionInput, UsersUncheckedCreateWithoutSessionInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSessionInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSessionInput, UsersUncheckedUpdateWithoutSessionInput>
  }

  export type UsersUpdateWithoutSessionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type RolesCreateWithoutUsersInput = {
    name: string
    rolePermissions?: RolePermissionsCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    rolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesCreateOrConnectWithoutUsersInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesCreateWithoutUsersInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutSalesInput
    SalesItems?: SalesItemsCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateWithoutUsersInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesCreateOrConnectWithoutUsersInput = {
    where: SalesWhereUniqueInput
    create: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput>
  }

  export type SalesCreateManyUsersInputEnvelope = {
    data: SalesCreateManyUsersInput | SalesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnCreateWithoutUsersInput = {
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales: SalesCreateNestedOneWithoutSalesReturnInput
    Customers: CustomersCreateNestedOneWithoutSalesReturnInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnUncheckedCreateWithoutUsersInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnCreateOrConnectWithoutUsersInput = {
    where: SalesReturnWhereUniqueInput
    create: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput>
  }

  export type SalesReturnCreateManyUsersInputEnvelope = {
    data: SalesReturnCreateManyUsersInput | SalesReturnCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ExchangesCreateWithoutUsersInput = {
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales?: SalesCreateNestedOneWithoutExchangesInput
    Customers?: CustomersCreateNestedOneWithoutExchangesInput
    ExchangeItems?: ExchangesItemsCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesUncheckedCreateWithoutUsersInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ExchangeItems?: ExchangesItemsUncheckedCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesCreateOrConnectWithoutUsersInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput>
  }

  export type ExchangesCreateManyUsersInputEnvelope = {
    data: ExchangesCreateManyUsersInput | ExchangesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesCreateWithoutUsersInput = {
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUncheckedCreateWithoutUsersInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesCreateOrConnectWithoutUsersInput = {
    where: PurchasesWhereUniqueInput
    create: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput>
  }

  export type PurchasesCreateManyUsersInputEnvelope = {
    data: PurchasesCreateManyUsersInput | PurchasesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesReturnCreateWithoutUsersInput = {
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesReturnInput
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesReturnInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUncheckedCreateWithoutUsersInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnCreateOrConnectWithoutUsersInput = {
    where: PurchasesReturnWhereUniqueInput
    create: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput>
  }

  export type PurchasesReturnCreateManyUsersInputEnvelope = {
    data: PurchasesReturnCreateManyUsersInput | PurchasesReturnCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ServicesCreateWithoutUsersInput = {
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutServicesInput
  }

  export type ServicesUncheckedCreateWithoutUsersInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    customer_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesCreateOrConnectWithoutUsersInput = {
    where: ServicesWhereUniqueInput
    create: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput>
  }

  export type ServicesCreateManyUsersInputEnvelope = {
    data: ServicesCreateManyUsersInput | ServicesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ProductsCreateWithoutCreatorInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCreatorInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCreatorInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput>
  }

  export type ProductsCreateManyCreatorInputEnvelope = {
    data: ProductsCreateManyCreatorInput | ProductsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductsCreateWithoutUpdaterInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutUpdaterInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutUpdaterInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput>
  }

  export type ProductsCreateManyUpdaterInputEnvelope = {
    data: ProductsCreateManyUpdaterInput | ProductsCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type ExpensesCreateWithoutUsersInput = {
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpensesUncheckedCreateWithoutUsersInput = {
    id?: number
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpensesCreateOrConnectWithoutUsersInput = {
    where: ExpensesWhereUniqueInput
    create: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput>
  }

  export type ExpensesCreateManyUsersInputEnvelope = {
    data: ExpensesCreateManyUsersInput | ExpensesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type RolesUpsertWithoutUsersInput = {
    update: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type RolesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    rolePermissions?: RolePermissionsUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SalesUpsertWithWhereUniqueWithoutUsersInput = {
    where: SalesWhereUniqueInput
    update: XOR<SalesUpdateWithoutUsersInput, SalesUncheckedUpdateWithoutUsersInput>
    create: XOR<SalesCreateWithoutUsersInput, SalesUncheckedCreateWithoutUsersInput>
  }

  export type SalesUpdateWithWhereUniqueWithoutUsersInput = {
    where: SalesWhereUniqueInput
    data: XOR<SalesUpdateWithoutUsersInput, SalesUncheckedUpdateWithoutUsersInput>
  }

  export type SalesUpdateManyWithWhereWithoutUsersInput = {
    where: SalesScalarWhereInput
    data: XOR<SalesUpdateManyMutationInput, SalesUncheckedUpdateManyWithoutUsersInput>
  }

  export type SalesScalarWhereInput = {
    AND?: SalesScalarWhereInput | SalesScalarWhereInput[]
    OR?: SalesScalarWhereInput[]
    NOT?: SalesScalarWhereInput | SalesScalarWhereInput[]
    id?: IntFilter<"Sales"> | number
    saleNo?: StringFilter<"Sales"> | string
    totalAmount?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Sales"> | Decimal | DecimalJsLike | number | string
    totaldiscount?: DecimalNullableFilter<"Sales"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeNullableFilter<"Sales"> | Date | string | null
    status?: StringFilter<"Sales"> | string
    customer_id?: IntNullableFilter<"Sales"> | number | null
    user_id?: IntFilter<"Sales"> | number
    createdAt?: DateTimeFilter<"Sales"> | Date | string
    updatedAt?: DateTimeFilter<"Sales"> | Date | string
  }

  export type SalesReturnUpsertWithWhereUniqueWithoutUsersInput = {
    where: SalesReturnWhereUniqueInput
    update: XOR<SalesReturnUpdateWithoutUsersInput, SalesReturnUncheckedUpdateWithoutUsersInput>
    create: XOR<SalesReturnCreateWithoutUsersInput, SalesReturnUncheckedCreateWithoutUsersInput>
  }

  export type SalesReturnUpdateWithWhereUniqueWithoutUsersInput = {
    where: SalesReturnWhereUniqueInput
    data: XOR<SalesReturnUpdateWithoutUsersInput, SalesReturnUncheckedUpdateWithoutUsersInput>
  }

  export type SalesReturnUpdateManyWithWhereWithoutUsersInput = {
    where: SalesReturnScalarWhereInput
    data: XOR<SalesReturnUpdateManyMutationInput, SalesReturnUncheckedUpdateManyWithoutUsersInput>
  }

  export type SalesReturnScalarWhereInput = {
    AND?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
    OR?: SalesReturnScalarWhereInput[]
    NOT?: SalesReturnScalarWhereInput | SalesReturnScalarWhereInput[]
    id?: IntFilter<"SalesReturn"> | number
    returnNo?: StringFilter<"SalesReturn"> | string
    total_payback?: DecimalFilter<"SalesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"SalesReturn"> | string
    sales_id?: IntFilter<"SalesReturn"> | number
    user_id?: IntFilter<"SalesReturn"> | number
    customer_id?: IntFilter<"SalesReturn"> | number
    createdAt?: DateTimeFilter<"SalesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturn"> | Date | string
  }

  export type ExchangesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ExchangesWhereUniqueInput
    update: XOR<ExchangesUpdateWithoutUsersInput, ExchangesUncheckedUpdateWithoutUsersInput>
    create: XOR<ExchangesCreateWithoutUsersInput, ExchangesUncheckedCreateWithoutUsersInput>
  }

  export type ExchangesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ExchangesWhereUniqueInput
    data: XOR<ExchangesUpdateWithoutUsersInput, ExchangesUncheckedUpdateWithoutUsersInput>
  }

  export type ExchangesUpdateManyWithWhereWithoutUsersInput = {
    where: ExchangesScalarWhereInput
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyWithoutUsersInput>
  }

  export type ExchangesScalarWhereInput = {
    AND?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
    OR?: ExchangesScalarWhereInput[]
    NOT?: ExchangesScalarWhereInput | ExchangesScalarWhereInput[]
    id?: IntFilter<"Exchanges"> | number
    exchangeNo?: StringFilter<"Exchanges"> | string
    totalPaid?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFilter<"Exchanges"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"Exchanges"> | string
    sales_id?: IntFilter<"Exchanges"> | number
    user_id?: IntFilter<"Exchanges"> | number
    customer_id?: IntFilter<"Exchanges"> | number
    createdAt?: DateTimeFilter<"Exchanges"> | Date | string
    updatedAt?: DateTimeFilter<"Exchanges"> | Date | string
  }

  export type PurchasesUpsertWithWhereUniqueWithoutUsersInput = {
    where: PurchasesWhereUniqueInput
    update: XOR<PurchasesUpdateWithoutUsersInput, PurchasesUncheckedUpdateWithoutUsersInput>
    create: XOR<PurchasesCreateWithoutUsersInput, PurchasesUncheckedCreateWithoutUsersInput>
  }

  export type PurchasesUpdateWithWhereUniqueWithoutUsersInput = {
    where: PurchasesWhereUniqueInput
    data: XOR<PurchasesUpdateWithoutUsersInput, PurchasesUncheckedUpdateWithoutUsersInput>
  }

  export type PurchasesUpdateManyWithWhereWithoutUsersInput = {
    where: PurchasesScalarWhereInput
    data: XOR<PurchasesUpdateManyMutationInput, PurchasesUncheckedUpdateManyWithoutUsersInput>
  }

  export type PurchasesScalarWhereInput = {
    AND?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
    OR?: PurchasesScalarWhereInput[]
    NOT?: PurchasesScalarWhereInput | PurchasesScalarWhereInput[]
    id?: IntFilter<"Purchases"> | number
    purchaseNo?: StringFilter<"Purchases"> | string
    totalAmount?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFilter<"Purchases"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Purchases"> | Date | string
    note?: StringNullableFilter<"Purchases"> | string | null
    supplier_id?: IntFilter<"Purchases"> | number
    user_id?: IntFilter<"Purchases"> | number
    createdAt?: DateTimeFilter<"Purchases"> | Date | string
    updatedAt?: DateTimeFilter<"Purchases"> | Date | string
  }

  export type PurchasesReturnUpsertWithWhereUniqueWithoutUsersInput = {
    where: PurchasesReturnWhereUniqueInput
    update: XOR<PurchasesReturnUpdateWithoutUsersInput, PurchasesReturnUncheckedUpdateWithoutUsersInput>
    create: XOR<PurchasesReturnCreateWithoutUsersInput, PurchasesReturnUncheckedCreateWithoutUsersInput>
  }

  export type PurchasesReturnUpdateWithWhereUniqueWithoutUsersInput = {
    where: PurchasesReturnWhereUniqueInput
    data: XOR<PurchasesReturnUpdateWithoutUsersInput, PurchasesReturnUncheckedUpdateWithoutUsersInput>
  }

  export type PurchasesReturnUpdateManyWithWhereWithoutUsersInput = {
    where: PurchasesReturnScalarWhereInput
    data: XOR<PurchasesReturnUpdateManyMutationInput, PurchasesReturnUncheckedUpdateManyWithoutUsersInput>
  }

  export type PurchasesReturnScalarWhereInput = {
    AND?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
    OR?: PurchasesReturnScalarWhereInput[]
    NOT?: PurchasesReturnScalarWhereInput | PurchasesReturnScalarWhereInput[]
    id?: IntFilter<"PurchasesReturn"> | number
    returnNo?: StringFilter<"PurchasesReturn"> | string
    totalPaid?: DecimalFilter<"PurchasesReturn"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"PurchasesReturn"> | string
    purchase_id?: IntFilter<"PurchasesReturn"> | number
    user_id?: IntFilter<"PurchasesReturn"> | number
    supplier_id?: IntFilter<"PurchasesReturn"> | number
    createdAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchasesReturn"> | Date | string
  }

  export type ServicesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ServicesWhereUniqueInput
    update: XOR<ServicesUpdateWithoutUsersInput, ServicesUncheckedUpdateWithoutUsersInput>
    create: XOR<ServicesCreateWithoutUsersInput, ServicesUncheckedCreateWithoutUsersInput>
  }

  export type ServicesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ServicesWhereUniqueInput
    data: XOR<ServicesUpdateWithoutUsersInput, ServicesUncheckedUpdateWithoutUsersInput>
  }

  export type ServicesUpdateManyWithWhereWithoutUsersInput = {
    where: ServicesScalarWhereInput
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyWithoutUsersInput>
  }

  export type ServicesScalarWhereInput = {
    AND?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
    OR?: ServicesScalarWhereInput[]
    NOT?: ServicesScalarWhereInput | ServicesScalarWhereInput[]
    id?: IntFilter<"Services"> | number
    serviceNo?: StringFilter<"Services"> | string
    serviceProductName?: StringFilter<"Services"> | string
    serviceDescription?: StringFilter<"Services"> | string
    serviceCost?: DecimalFilter<"Services"> | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFilter<"Services"> | string
    customer_id?: IntNullableFilter<"Services"> | number | null
    user_id?: IntNullableFilter<"Services"> | number | null
    createdAt?: DateTimeFilter<"Services"> | Date | string
    updatedAt?: DateTimeFilter<"Services"> | Date | string
  }

  export type ProductsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutCreatorInput, ProductsUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProductsCreateWithoutCreatorInput, ProductsUncheckedCreateWithoutCreatorInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutCreatorInput, ProductsUncheckedUpdateWithoutCreatorInput>
  }

  export type ProductsUpdateManyWithWhereWithoutCreatorInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProductsScalarWhereInput = {
    AND?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    OR?: ProductsScalarWhereInput[]
    NOT?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    id?: IntFilter<"Products"> | number
    productCode?: StringFilter<"Products"> | string
    name?: StringFilter<"Products"> | string
    specification?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    quantity?: IntFilter<"Products"> | number
    purchasePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Products"> | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFilter<"Products"> | boolean
    productType?: EnumProductTypeFilter<"Products"> | $Enums.ProductType
    status?: EnumProductStatusFilter<"Products"> | $Enums.ProductStatus
    category_id?: IntFilter<"Products"> | number
    supplier_id?: IntNullableFilter<"Products"> | number | null
    created_by?: IntNullableFilter<"Products"> | number | null
    updated_by?: IntNullableFilter<"Products"> | number | null
    createdAt?: DateTimeFilter<"Products"> | Date | string
    updatedAt?: DateTimeFilter<"Products"> | Date | string
  }

  export type ProductsUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutUpdaterInput, ProductsUncheckedUpdateWithoutUpdaterInput>
    create: XOR<ProductsCreateWithoutUpdaterInput, ProductsUncheckedCreateWithoutUpdaterInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutUpdaterInput, ProductsUncheckedUpdateWithoutUpdaterInput>
  }

  export type ProductsUpdateManyWithWhereWithoutUpdaterInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type ExpensesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ExpensesWhereUniqueInput
    update: XOR<ExpensesUpdateWithoutUsersInput, ExpensesUncheckedUpdateWithoutUsersInput>
    create: XOR<ExpensesCreateWithoutUsersInput, ExpensesUncheckedCreateWithoutUsersInput>
  }

  export type ExpensesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ExpensesWhereUniqueInput
    data: XOR<ExpensesUpdateWithoutUsersInput, ExpensesUncheckedUpdateWithoutUsersInput>
  }

  export type ExpensesUpdateManyWithWhereWithoutUsersInput = {
    where: ExpensesScalarWhereInput
    data: XOR<ExpensesUpdateManyMutationInput, ExpensesUncheckedUpdateManyWithoutUsersInput>
  }

  export type ExpensesScalarWhereInput = {
    AND?: ExpensesScalarWhereInput | ExpensesScalarWhereInput[]
    OR?: ExpensesScalarWhereInput[]
    NOT?: ExpensesScalarWhereInput | ExpensesScalarWhereInput[]
    id?: IntFilter<"Expenses"> | number
    expenseNo?: StringFilter<"Expenses"> | string
    title?: StringFilter<"Expenses"> | string
    amount?: DecimalFilter<"Expenses"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expenses"> | Date | string
    description?: StringNullableFilter<"Expenses"> | string | null
    user_id?: IntFilter<"Expenses"> | number
    createdAt?: DateTimeFilter<"Expenses"> | Date | string
    updatedAt?: DateTimeFilter<"Expenses"> | Date | string
  }

  export type SalesCreateWithoutCustomersInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users?: UsersCreateNestedOneWithoutSalesInput
    SalesItems?: SalesItemsCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateWithoutCustomersInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesCreateOrConnectWithoutCustomersInput = {
    where: SalesWhereUniqueInput
    create: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput>
  }

  export type SalesCreateManyCustomersInputEnvelope = {
    data: SalesCreateManyCustomersInput | SalesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnCreateWithoutCustomersInput = {
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales: SalesCreateNestedOneWithoutSalesReturnInput
    Users: UsersCreateNestedOneWithoutSalesReturnInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnUncheckedCreateWithoutCustomersInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnCreateOrConnectWithoutCustomersInput = {
    where: SalesReturnWhereUniqueInput
    create: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput>
  }

  export type SalesReturnCreateManyCustomersInputEnvelope = {
    data: SalesReturnCreateManyCustomersInput | SalesReturnCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type ExchangesCreateWithoutCustomersInput = {
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales?: SalesCreateNestedOneWithoutExchangesInput
    Users?: UsersCreateNestedOneWithoutExchangesInput
    ExchangeItems?: ExchangesItemsCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesUncheckedCreateWithoutCustomersInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ExchangeItems?: ExchangesItemsUncheckedCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesCreateOrConnectWithoutCustomersInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput>
  }

  export type ExchangesCreateManyCustomersInputEnvelope = {
    data: ExchangesCreateManyCustomersInput | ExchangesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type ServicesCreateWithoutCustomersInput = {
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users?: UsersCreateNestedOneWithoutServicesInput
  }

  export type ServicesUncheckedCreateWithoutCustomersInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    user_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesCreateOrConnectWithoutCustomersInput = {
    where: ServicesWhereUniqueInput
    create: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput>
  }

  export type ServicesCreateManyCustomersInputEnvelope = {
    data: ServicesCreateManyCustomersInput | ServicesCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type SalesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: SalesWhereUniqueInput
    update: XOR<SalesUpdateWithoutCustomersInput, SalesUncheckedUpdateWithoutCustomersInput>
    create: XOR<SalesCreateWithoutCustomersInput, SalesUncheckedCreateWithoutCustomersInput>
  }

  export type SalesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: SalesWhereUniqueInput
    data: XOR<SalesUpdateWithoutCustomersInput, SalesUncheckedUpdateWithoutCustomersInput>
  }

  export type SalesUpdateManyWithWhereWithoutCustomersInput = {
    where: SalesScalarWhereInput
    data: XOR<SalesUpdateManyMutationInput, SalesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type SalesReturnUpsertWithWhereUniqueWithoutCustomersInput = {
    where: SalesReturnWhereUniqueInput
    update: XOR<SalesReturnUpdateWithoutCustomersInput, SalesReturnUncheckedUpdateWithoutCustomersInput>
    create: XOR<SalesReturnCreateWithoutCustomersInput, SalesReturnUncheckedCreateWithoutCustomersInput>
  }

  export type SalesReturnUpdateWithWhereUniqueWithoutCustomersInput = {
    where: SalesReturnWhereUniqueInput
    data: XOR<SalesReturnUpdateWithoutCustomersInput, SalesReturnUncheckedUpdateWithoutCustomersInput>
  }

  export type SalesReturnUpdateManyWithWhereWithoutCustomersInput = {
    where: SalesReturnScalarWhereInput
    data: XOR<SalesReturnUpdateManyMutationInput, SalesReturnUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ExchangesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: ExchangesWhereUniqueInput
    update: XOR<ExchangesUpdateWithoutCustomersInput, ExchangesUncheckedUpdateWithoutCustomersInput>
    create: XOR<ExchangesCreateWithoutCustomersInput, ExchangesUncheckedCreateWithoutCustomersInput>
  }

  export type ExchangesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: ExchangesWhereUniqueInput
    data: XOR<ExchangesUpdateWithoutCustomersInput, ExchangesUncheckedUpdateWithoutCustomersInput>
  }

  export type ExchangesUpdateManyWithWhereWithoutCustomersInput = {
    where: ExchangesScalarWhereInput
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ServicesUpsertWithWhereUniqueWithoutCustomersInput = {
    where: ServicesWhereUniqueInput
    update: XOR<ServicesUpdateWithoutCustomersInput, ServicesUncheckedUpdateWithoutCustomersInput>
    create: XOR<ServicesCreateWithoutCustomersInput, ServicesUncheckedCreateWithoutCustomersInput>
  }

  export type ServicesUpdateWithWhereUniqueWithoutCustomersInput = {
    where: ServicesWhereUniqueInput
    data: XOR<ServicesUpdateWithoutCustomersInput, ServicesUncheckedUpdateWithoutCustomersInput>
  }

  export type ServicesUpdateManyWithWhereWithoutCustomersInput = {
    where: ServicesScalarWhereInput
    data: XOR<ServicesUpdateManyMutationInput, ServicesUncheckedUpdateManyWithoutCustomersInput>
  }

  export type PurchasesCreateWithoutSuppliersInput = {
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutPurchasesInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUncheckedCreateWithoutSuppliersInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesCreateOrConnectWithoutSuppliersInput = {
    where: PurchasesWhereUniqueInput
    create: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchasesCreateManySuppliersInputEnvelope = {
    data: PurchasesCreateManySuppliersInput | PurchasesCreateManySuppliersInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesReturnCreateWithoutSuppliersInput = {
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesReturnInput
    Users: UsersCreateNestedOneWithoutPurchasesReturnInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUncheckedCreateWithoutSuppliersInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnCreateOrConnectWithoutSuppliersInput = {
    where: PurchasesReturnWhereUniqueInput
    create: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchasesReturnCreateManySuppliersInputEnvelope = {
    data: PurchasesReturnCreateManySuppliersInput | PurchasesReturnCreateManySuppliersInput[]
    skipDuplicates?: boolean
  }

  export type ProductsCreateWithoutSupplierInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutSupplierInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutSupplierInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput>
  }

  export type ProductsCreateManySupplierInputEnvelope = {
    data: ProductsCreateManySupplierInput | ProductsCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesUpsertWithWhereUniqueWithoutSuppliersInput = {
    where: PurchasesWhereUniqueInput
    update: XOR<PurchasesUpdateWithoutSuppliersInput, PurchasesUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PurchasesCreateWithoutSuppliersInput, PurchasesUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchasesUpdateWithWhereUniqueWithoutSuppliersInput = {
    where: PurchasesWhereUniqueInput
    data: XOR<PurchasesUpdateWithoutSuppliersInput, PurchasesUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchasesUpdateManyWithWhereWithoutSuppliersInput = {
    where: PurchasesScalarWhereInput
    data: XOR<PurchasesUpdateManyMutationInput, PurchasesUncheckedUpdateManyWithoutSuppliersInput>
  }

  export type PurchasesReturnUpsertWithWhereUniqueWithoutSuppliersInput = {
    where: PurchasesReturnWhereUniqueInput
    update: XOR<PurchasesReturnUpdateWithoutSuppliersInput, PurchasesReturnUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PurchasesReturnCreateWithoutSuppliersInput, PurchasesReturnUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchasesReturnUpdateWithWhereUniqueWithoutSuppliersInput = {
    where: PurchasesReturnWhereUniqueInput
    data: XOR<PurchasesReturnUpdateWithoutSuppliersInput, PurchasesReturnUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchasesReturnUpdateManyWithWhereWithoutSuppliersInput = {
    where: PurchasesReturnScalarWhereInput
    data: XOR<PurchasesReturnUpdateManyMutationInput, PurchasesReturnUncheckedUpdateManyWithoutSuppliersInput>
  }

  export type ProductsUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutSupplierInput, ProductsUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductsCreateWithoutSupplierInput, ProductsUncheckedCreateWithoutSupplierInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutSupplierInput, ProductsUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductsUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductsCreateWithoutCategoriesInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutCategoriesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductsCreateManyCategoriesInputEnvelope = {
    data: ProductsCreateManyCategoriesInput | ProductsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutCategoriesInput, ProductsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductsCreateWithoutCategoriesInput, ProductsUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutCategoriesInput, ProductsUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductsUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CategoriesCreateWithoutProductsInput = {
    name: string
  }

  export type CategoriesUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
  }

  export type CategoriesCreateOrConnectWithoutProductsInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutProductsInput, CategoriesUncheckedCreateWithoutProductsInput>
  }

  export type SuppliersCreateWithoutProductsInput = {
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesCreateNestedManyWithoutSuppliersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutSuppliersInput
  }

  export type SuppliersUncheckedCreateWithoutProductsInput = {
    id?: number
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutSuppliersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutSuppliersInput
  }

  export type SuppliersCreateOrConnectWithoutProductsInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutProductsInput, SuppliersUncheckedCreateWithoutProductsInput>
  }

  export type UsersCreateWithoutCreatedProductsInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCreatedProductsInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCreatedProductsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCreatedProductsInput, UsersUncheckedCreateWithoutCreatedProductsInput>
  }

  export type UsersCreateWithoutUpdatedProductsInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUpdatedProductsInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUpdatedProductsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUpdatedProductsInput, UsersUncheckedCreateWithoutUpdatedProductsInput>
  }

  export type SalesItemsCreateWithoutProductsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    Sales?: SalesCreateNestedOneWithoutSalesItemsInput
    salesItemSerials?: SalesItemSerialsCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateWithoutProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    sales_id: number
    salesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsCreateOrConnectWithoutProductsInput = {
    where: SalesItemsWhereUniqueInput
    create: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput>
  }

  export type SalesItemsCreateManyProductsInputEnvelope = {
    data: SalesItemsCreateManyProductsInput | SalesItemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnItemsCreateWithoutProductsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    SalesReturn?: SalesReturnCreateNestedOneWithoutSalesReturnItemsInput
    productSerials?: ProductSerialsCreateNestedOneWithoutSalesReturnItemsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUncheckedCreateWithoutProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    salesReturn_id: number
    productSerialsId?: number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsCreateOrConnectWithoutProductsInput = {
    where: SalesReturnItemsWhereUniqueInput
    create: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput>
  }

  export type SalesReturnItemsCreateManyProductsInputEnvelope = {
    data: SalesReturnItemsCreateManyProductsInput | SalesReturnItemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type ExchangesItemsCreateWithoutOldProductInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    newProduct?: ProductsCreateNestedOneWithoutExchangeItemsNewInput
    Exchanges?: ExchangesCreateNestedOneWithoutExchangeItemsInput
    exchangeItemSerials?: ExchangeItemSerialsCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsUncheckedCreateWithoutOldProductInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    newProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsCreateOrConnectWithoutOldProductInput = {
    where: ExchangesItemsWhereUniqueInput
    create: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput>
  }

  export type ExchangesItemsCreateManyOldProductInputEnvelope = {
    data: ExchangesItemsCreateManyOldProductInput | ExchangesItemsCreateManyOldProductInput[]
    skipDuplicates?: boolean
  }

  export type ExchangesItemsCreateWithoutNewProductInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oldProduct?: ProductsCreateNestedOneWithoutExchangeItemsOldInput
    Exchanges?: ExchangesCreateNestedOneWithoutExchangeItemsInput
    exchangeItemSerials?: ExchangeItemSerialsCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsUncheckedCreateWithoutNewProductInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsCreateOrConnectWithoutNewProductInput = {
    where: ExchangesItemsWhereUniqueInput
    create: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput>
  }

  export type ExchangesItemsCreateManyNewProductInputEnvelope = {
    data: ExchangesItemsCreateManyNewProductInput | ExchangesItemsCreateManyNewProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesItemsCreateWithoutProductsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesItemsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsUncheckedCreateWithoutProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchase_id: number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsCreateOrConnectWithoutProductsInput = {
    where: PurchasesItemsWhereUniqueInput
    create: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput>
  }

  export type PurchasesItemsCreateManyProductsInputEnvelope = {
    data: PurchasesItemsCreateManyProductsInput | PurchasesItemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesReturnItemsCreateWithoutProductsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    PurchasesReturn: PurchasesReturnCreateNestedOneWithoutPurchasesReturnItemsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsUncheckedCreateWithoutProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchaseReturn_id: number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsCreateOrConnectWithoutProductsInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    create: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput>
  }

  export type PurchasesReturnItemsCreateManyProductsInputEnvelope = {
    data: PurchasesReturnItemsCreateManyProductsInput | PurchasesReturnItemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type ProductSerialsCreateWithoutProductsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutProductsInput = {
    id?: number
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutProductsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput>
  }

  export type ProductSerialsCreateManyProductsInputEnvelope = {
    data: ProductSerialsCreateManyProductsInput | ProductSerialsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type CategoriesUpsertWithoutProductsInput = {
    update: XOR<CategoriesUpdateWithoutProductsInput, CategoriesUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoriesCreateWithoutProductsInput, CategoriesUncheckedCreateWithoutProductsInput>
    where?: CategoriesWhereInput
  }

  export type CategoriesUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoriesWhereInput
    data: XOR<CategoriesUpdateWithoutProductsInput, CategoriesUncheckedUpdateWithoutProductsInput>
  }

  export type CategoriesUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SuppliersUpsertWithoutProductsInput = {
    update: XOR<SuppliersUpdateWithoutProductsInput, SuppliersUncheckedUpdateWithoutProductsInput>
    create: XOR<SuppliersCreateWithoutProductsInput, SuppliersUncheckedCreateWithoutProductsInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutProductsInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutProductsInput, SuppliersUncheckedUpdateWithoutProductsInput>
  }

  export type SuppliersUpdateWithoutProductsInput = {
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUpdateManyWithoutSuppliersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutSuppliersNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUncheckedUpdateManyWithoutSuppliersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutSuppliersNestedInput
  }

  export type UsersUpsertWithoutCreatedProductsInput = {
    update: XOR<UsersUpdateWithoutCreatedProductsInput, UsersUncheckedUpdateWithoutCreatedProductsInput>
    create: XOR<UsersCreateWithoutCreatedProductsInput, UsersUncheckedCreateWithoutCreatedProductsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCreatedProductsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCreatedProductsInput, UsersUncheckedUpdateWithoutCreatedProductsInput>
  }

  export type UsersUpdateWithoutCreatedProductsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCreatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutUpdatedProductsInput = {
    update: XOR<UsersUpdateWithoutUpdatedProductsInput, UsersUncheckedUpdateWithoutUpdatedProductsInput>
    create: XOR<UsersCreateWithoutUpdatedProductsInput, UsersUncheckedCreateWithoutUpdatedProductsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUpdatedProductsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUpdatedProductsInput, UsersUncheckedUpdateWithoutUpdatedProductsInput>
  }

  export type UsersUpdateWithoutUpdatedProductsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUpdatedProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SalesItemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: SalesItemsWhereUniqueInput
    update: XOR<SalesItemsUpdateWithoutProductsInput, SalesItemsUncheckedUpdateWithoutProductsInput>
    create: XOR<SalesItemsCreateWithoutProductsInput, SalesItemsUncheckedCreateWithoutProductsInput>
  }

  export type SalesItemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: SalesItemsWhereUniqueInput
    data: XOR<SalesItemsUpdateWithoutProductsInput, SalesItemsUncheckedUpdateWithoutProductsInput>
  }

  export type SalesItemsUpdateManyWithWhereWithoutProductsInput = {
    where: SalesItemsScalarWhereInput
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type SalesItemsScalarWhereInput = {
    AND?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
    OR?: SalesItemsScalarWhereInput[]
    NOT?: SalesItemsScalarWhereInput | SalesItemsScalarWhereInput[]
    id?: IntFilter<"SalesItems"> | number
    quantity?: IntFilter<"SalesItems"> | number
    unitPrice?: DecimalFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalNullableFilter<"SalesItems"> | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFilter<"SalesItems"> | number
    product_id?: IntFilter<"SalesItems"> | number
  }

  export type SalesReturnItemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: SalesReturnItemsWhereUniqueInput
    update: XOR<SalesReturnItemsUpdateWithoutProductsInput, SalesReturnItemsUncheckedUpdateWithoutProductsInput>
    create: XOR<SalesReturnItemsCreateWithoutProductsInput, SalesReturnItemsUncheckedCreateWithoutProductsInput>
  }

  export type SalesReturnItemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: SalesReturnItemsWhereUniqueInput
    data: XOR<SalesReturnItemsUpdateWithoutProductsInput, SalesReturnItemsUncheckedUpdateWithoutProductsInput>
  }

  export type SalesReturnItemsUpdateManyWithWhereWithoutProductsInput = {
    where: SalesReturnItemsScalarWhereInput
    data: XOR<SalesReturnItemsUpdateManyMutationInput, SalesReturnItemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type SalesReturnItemsScalarWhereInput = {
    AND?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
    OR?: SalesReturnItemsScalarWhereInput[]
    NOT?: SalesReturnItemsScalarWhereInput | SalesReturnItemsScalarWhereInput[]
    id?: IntFilter<"SalesReturnItems"> | number
    quantity?: IntFilter<"SalesReturnItems"> | number
    unitPrice?: DecimalFilter<"SalesReturnItems"> | Decimal | DecimalJsLike | number | string
    product_id?: IntFilter<"SalesReturnItems"> | number
    salesReturn_id?: IntFilter<"SalesReturnItems"> | number
    productSerialsId?: IntNullableFilter<"SalesReturnItems"> | number | null
  }

  export type ExchangesItemsUpsertWithWhereUniqueWithoutOldProductInput = {
    where: ExchangesItemsWhereUniqueInput
    update: XOR<ExchangesItemsUpdateWithoutOldProductInput, ExchangesItemsUncheckedUpdateWithoutOldProductInput>
    create: XOR<ExchangesItemsCreateWithoutOldProductInput, ExchangesItemsUncheckedCreateWithoutOldProductInput>
  }

  export type ExchangesItemsUpdateWithWhereUniqueWithoutOldProductInput = {
    where: ExchangesItemsWhereUniqueInput
    data: XOR<ExchangesItemsUpdateWithoutOldProductInput, ExchangesItemsUncheckedUpdateWithoutOldProductInput>
  }

  export type ExchangesItemsUpdateManyWithWhereWithoutOldProductInput = {
    where: ExchangesItemsScalarWhereInput
    data: XOR<ExchangesItemsUpdateManyMutationInput, ExchangesItemsUncheckedUpdateManyWithoutOldProductInput>
  }

  export type ExchangesItemsScalarWhereInput = {
    AND?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
    OR?: ExchangesItemsScalarWhereInput[]
    NOT?: ExchangesItemsScalarWhereInput | ExchangesItemsScalarWhereInput[]
    id?: IntFilter<"ExchangesItems"> | number
    quantity?: IntFilter<"ExchangesItems"> | number
    unitPrice?: DecimalFilter<"ExchangesItems"> | Decimal | DecimalJsLike | number | string
    note?: StringFilter<"ExchangesItems"> | string
    oldProduct_id?: IntFilter<"ExchangesItems"> | number
    newProduct_id?: IntFilter<"ExchangesItems"> | number
    exchangeId?: IntNullableFilter<"ExchangesItems"> | number | null
    createdAt?: DateTimeFilter<"ExchangesItems"> | Date | string
    updatedAt?: DateTimeFilter<"ExchangesItems"> | Date | string
  }

  export type ExchangesItemsUpsertWithWhereUniqueWithoutNewProductInput = {
    where: ExchangesItemsWhereUniqueInput
    update: XOR<ExchangesItemsUpdateWithoutNewProductInput, ExchangesItemsUncheckedUpdateWithoutNewProductInput>
    create: XOR<ExchangesItemsCreateWithoutNewProductInput, ExchangesItemsUncheckedCreateWithoutNewProductInput>
  }

  export type ExchangesItemsUpdateWithWhereUniqueWithoutNewProductInput = {
    where: ExchangesItemsWhereUniqueInput
    data: XOR<ExchangesItemsUpdateWithoutNewProductInput, ExchangesItemsUncheckedUpdateWithoutNewProductInput>
  }

  export type ExchangesItemsUpdateManyWithWhereWithoutNewProductInput = {
    where: ExchangesItemsScalarWhereInput
    data: XOR<ExchangesItemsUpdateManyMutationInput, ExchangesItemsUncheckedUpdateManyWithoutNewProductInput>
  }

  export type PurchasesItemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: PurchasesItemsWhereUniqueInput
    update: XOR<PurchasesItemsUpdateWithoutProductsInput, PurchasesItemsUncheckedUpdateWithoutProductsInput>
    create: XOR<PurchasesItemsCreateWithoutProductsInput, PurchasesItemsUncheckedCreateWithoutProductsInput>
  }

  export type PurchasesItemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: PurchasesItemsWhereUniqueInput
    data: XOR<PurchasesItemsUpdateWithoutProductsInput, PurchasesItemsUncheckedUpdateWithoutProductsInput>
  }

  export type PurchasesItemsUpdateManyWithWhereWithoutProductsInput = {
    where: PurchasesItemsScalarWhereInput
    data: XOR<PurchasesItemsUpdateManyMutationInput, PurchasesItemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type PurchasesItemsScalarWhereInput = {
    AND?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
    OR?: PurchasesItemsScalarWhereInput[]
    NOT?: PurchasesItemsScalarWhereInput | PurchasesItemsScalarWhereInput[]
    id?: IntFilter<"PurchasesItems"> | number
    quantity?: IntFilter<"PurchasesItems"> | number
    unitPrice?: DecimalFilter<"PurchasesItems"> | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFilter<"PurchasesItems"> | number
    product_id?: IntFilter<"PurchasesItems"> | number
  }

  export type PurchasesReturnItemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    update: XOR<PurchasesReturnItemsUpdateWithoutProductsInput, PurchasesReturnItemsUncheckedUpdateWithoutProductsInput>
    create: XOR<PurchasesReturnItemsCreateWithoutProductsInput, PurchasesReturnItemsUncheckedCreateWithoutProductsInput>
  }

  export type PurchasesReturnItemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    data: XOR<PurchasesReturnItemsUpdateWithoutProductsInput, PurchasesReturnItemsUncheckedUpdateWithoutProductsInput>
  }

  export type PurchasesReturnItemsUpdateManyWithWhereWithoutProductsInput = {
    where: PurchasesReturnItemsScalarWhereInput
    data: XOR<PurchasesReturnItemsUpdateManyMutationInput, PurchasesReturnItemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type PurchasesReturnItemsScalarWhereInput = {
    AND?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
    OR?: PurchasesReturnItemsScalarWhereInput[]
    NOT?: PurchasesReturnItemsScalarWhereInput | PurchasesReturnItemsScalarWhereInput[]
    id?: IntFilter<"PurchasesReturnItems"> | number
    quantity?: IntFilter<"PurchasesReturnItems"> | number
    unitPrice?: DecimalFilter<"PurchasesReturnItems"> | Decimal | DecimalJsLike | number | string
    products_id?: IntFilter<"PurchasesReturnItems"> | number
    purchaseReturn_id?: IntFilter<"PurchasesReturnItems"> | number
  }

  export type ProductSerialsUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductSerialsWhereUniqueInput
    update: XOR<ProductSerialsUpdateWithoutProductsInput, ProductSerialsUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductSerialsCreateWithoutProductsInput, ProductSerialsUncheckedCreateWithoutProductsInput>
  }

  export type ProductSerialsUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductSerialsWhereUniqueInput
    data: XOR<ProductSerialsUpdateWithoutProductsInput, ProductSerialsUncheckedUpdateWithoutProductsInput>
  }

  export type ProductSerialsUpdateManyWithWhereWithoutProductsInput = {
    where: ProductSerialsScalarWhereInput
    data: XOR<ProductSerialsUpdateManyMutationInput, ProductSerialsUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductSerialsScalarWhereInput = {
    AND?: ProductSerialsScalarWhereInput | ProductSerialsScalarWhereInput[]
    OR?: ProductSerialsScalarWhereInput[]
    NOT?: ProductSerialsScalarWhereInput | ProductSerialsScalarWhereInput[]
    id?: IntFilter<"ProductSerials"> | number
    serial?: StringFilter<"ProductSerials"> | string
    product_id?: IntFilter<"ProductSerials"> | number
    status?: EnumSerialStatusFilter<"ProductSerials"> | $Enums.SerialStatus
    warranty?: EnumWarrantyFilter<"ProductSerials"> | $Enums.Warranty
    createdAt?: DateTimeFilter<"ProductSerials"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSerials"> | Date | string
  }

  export type ProductsCreateWithoutProductSerialsInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutProductSerialsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutProductSerialsInput, ProductsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesItemSerialsCreateWithoutProductSerialsInput = {
    SalesItems: SalesItemsCreateNestedOneWithoutSalesItemSerialsInput
  }

  export type SalesItemSerialsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    salesItem_id: number
  }

  export type SalesItemSerialsCreateOrConnectWithoutProductSerialsInput = {
    where: SalesItemSerialsWhereUniqueInput
    create: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesItemSerialsCreateManyProductSerialsInputEnvelope = {
    data: SalesItemSerialsCreateManyProductSerialsInput | SalesItemSerialsCreateManyProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnItemSerialsCreateWithoutProductSerialsInput = {
    SalesReturnItems: SalesReturnItemsCreateNestedOneWithoutSalesReturnItemSerialsInput
  }

  export type SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    salesReturnItem_id: number
  }

  export type SalesReturnItemSerialsCreateOrConnectWithoutProductSerialsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    create: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesReturnItemSerialsCreateManyProductSerialsInputEnvelope = {
    data: SalesReturnItemSerialsCreateManyProductSerialsInput | SalesReturnItemSerialsCreateManyProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemSerialsCreateWithoutProductSerialsInput = {
    PurchasesItems: PurchasesItemsCreateNestedOneWithoutPurchaseItemSerialsInput
  }

  export type PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    purchaseItem_id: number
  }

  export type PurchaseItemSerialsCreateOrConnectWithoutProductSerialsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    create: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type PurchaseItemSerialsCreateManyProductSerialsInputEnvelope = {
    data: PurchaseItemSerialsCreateManyProductSerialsInput | PurchaseItemSerialsCreateManyProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemSerialsCreateWithoutProductSerialsInput = {
    PurchasesReturnItems: PurchasesReturnItemsCreateNestedOneWithoutPurchaseReturnItemSerialsInput
  }

  export type PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    purchaseReturnItem_id: number
  }

  export type PurchaseReturnItemSerialsCreateOrConnectWithoutProductSerialsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    create: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type PurchaseReturnItemSerialsCreateManyProductSerialsInputEnvelope = {
    data: PurchaseReturnItemSerialsCreateManyProductSerialsInput | PurchaseReturnItemSerialsCreateManyProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnItemsCreateWithoutProductSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products?: ProductsCreateNestedOneWithoutSalesReturnItemsInput
    SalesReturn?: SalesReturnCreateNestedOneWithoutSalesReturnItemsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUncheckedCreateWithoutProductSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    salesReturn_id: number
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsCreateOrConnectWithoutProductSerialsInput = {
    where: SalesReturnItemsWhereUniqueInput
    create: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesReturnItemsCreateManyProductSerialsInputEnvelope = {
    data: SalesReturnItemsCreateManyProductSerialsInput | SalesReturnItemsCreateManyProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type ExchangeItemSerialsCreateWithoutOldProductSerialsInput = {
    ExchangesItems: ExchangesItemsCreateNestedOneWithoutExchangeItemSerialsInput
    NewProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsNewInput
  }

  export type ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput = {
    id?: number
    exchangeItem_id: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsCreateOrConnectWithoutOldProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    create: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput>
  }

  export type ExchangeItemSerialsCreateManyOldProductSerialsInputEnvelope = {
    data: ExchangeItemSerialsCreateManyOldProductSerialsInput | ExchangeItemSerialsCreateManyOldProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type ExchangeItemSerialsCreateWithoutNewProductSerialsInput = {
    ExchangesItems: ExchangesItemsCreateNestedOneWithoutExchangeItemSerialsInput
    OldProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsOldInput
  }

  export type ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput = {
    id?: number
    exchangeItem_id: number
    serial_id_old: number
  }

  export type ExchangeItemSerialsCreateOrConnectWithoutNewProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    create: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput>
  }

  export type ExchangeItemSerialsCreateManyNewProductSerialsInputEnvelope = {
    data: ExchangeItemSerialsCreateManyNewProductSerialsInput | ExchangeItemSerialsCreateManyNewProductSerialsInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutProductSerialsInput = {
    update: XOR<ProductsUpdateWithoutProductSerialsInput, ProductsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<ProductsCreateWithoutProductSerialsInput, ProductsUncheckedCreateWithoutProductSerialsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutProductSerialsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutProductSerialsInput, ProductsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type ProductsUpdateWithoutProductSerialsInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type SalesItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesItemSerialsWhereUniqueInput
    update: XOR<SalesItemSerialsUpdateWithoutProductSerialsInput, SalesItemSerialsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<SalesItemSerialsCreateWithoutProductSerialsInput, SalesItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesItemSerialsWhereUniqueInput
    data: XOR<SalesItemSerialsUpdateWithoutProductSerialsInput, SalesItemSerialsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type SalesItemSerialsUpdateManyWithWhereWithoutProductSerialsInput = {
    where: SalesItemSerialsScalarWhereInput
    data: XOR<SalesItemSerialsUpdateManyMutationInput, SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsInput>
  }

  export type SalesItemSerialsScalarWhereInput = {
    AND?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
    OR?: SalesItemSerialsScalarWhereInput[]
    NOT?: SalesItemSerialsScalarWhereInput | SalesItemSerialsScalarWhereInput[]
    id?: IntFilter<"SalesItemSerials"> | number
    salesItem_id?: IntFilter<"SalesItemSerials"> | number
    serial_id?: IntFilter<"SalesItemSerials"> | number
  }

  export type SalesReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    update: XOR<SalesReturnItemSerialsUpdateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<SalesReturnItemSerialsCreateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    data: XOR<SalesReturnItemSerialsUpdateWithoutProductSerialsInput, SalesReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type SalesReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput = {
    where: SalesReturnItemSerialsScalarWhereInput
    data: XOR<SalesReturnItemSerialsUpdateManyMutationInput, SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsInput>
  }

  export type SalesReturnItemSerialsScalarWhereInput = {
    AND?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
    OR?: SalesReturnItemSerialsScalarWhereInput[]
    NOT?: SalesReturnItemSerialsScalarWhereInput | SalesReturnItemSerialsScalarWhereInput[]
    id?: IntFilter<"SalesReturnItemSerials"> | number
    salesReturnItem_id?: IntFilter<"SalesReturnItemSerials"> | number
    serial_id?: IntFilter<"SalesReturnItemSerials"> | number
  }

  export type PurchaseItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    update: XOR<PurchaseItemSerialsUpdateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<PurchaseItemSerialsCreateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type PurchaseItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    data: XOR<PurchaseItemSerialsUpdateWithoutProductSerialsInput, PurchaseItemSerialsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type PurchaseItemSerialsUpdateManyWithWhereWithoutProductSerialsInput = {
    where: PurchaseItemSerialsScalarWhereInput
    data: XOR<PurchaseItemSerialsUpdateManyMutationInput, PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsInput>
  }

  export type PurchaseItemSerialsScalarWhereInput = {
    AND?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
    OR?: PurchaseItemSerialsScalarWhereInput[]
    NOT?: PurchaseItemSerialsScalarWhereInput | PurchaseItemSerialsScalarWhereInput[]
    id?: IntFilter<"PurchaseItemSerials"> | number
    purchaseItem_id?: IntFilter<"PurchaseItemSerials"> | number
    serial_id?: IntFilter<"PurchaseItemSerials"> | number
  }

  export type PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutProductSerialsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    update: XOR<PurchaseReturnItemSerialsUpdateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<PurchaseReturnItemSerialsCreateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutProductSerialsInput>
  }

  export type PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutProductSerialsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    data: XOR<PurchaseReturnItemSerialsUpdateWithoutProductSerialsInput, PurchaseReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type PurchaseReturnItemSerialsUpdateManyWithWhereWithoutProductSerialsInput = {
    where: PurchaseReturnItemSerialsScalarWhereInput
    data: XOR<PurchaseReturnItemSerialsUpdateManyMutationInput, PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsInput>
  }

  export type PurchaseReturnItemSerialsScalarWhereInput = {
    AND?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
    OR?: PurchaseReturnItemSerialsScalarWhereInput[]
    NOT?: PurchaseReturnItemSerialsScalarWhereInput | PurchaseReturnItemSerialsScalarWhereInput[]
    id?: IntFilter<"PurchaseReturnItemSerials"> | number
    purchaseReturnItem_id?: IntFilter<"PurchaseReturnItemSerials"> | number
    serial_id?: IntFilter<"PurchaseReturnItemSerials"> | number
  }

  export type SalesReturnItemsUpsertWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesReturnItemsWhereUniqueInput
    update: XOR<SalesReturnItemsUpdateWithoutProductSerialsInput, SalesReturnItemsUncheckedUpdateWithoutProductSerialsInput>
    create: XOR<SalesReturnItemsCreateWithoutProductSerialsInput, SalesReturnItemsUncheckedCreateWithoutProductSerialsInput>
  }

  export type SalesReturnItemsUpdateWithWhereUniqueWithoutProductSerialsInput = {
    where: SalesReturnItemsWhereUniqueInput
    data: XOR<SalesReturnItemsUpdateWithoutProductSerialsInput, SalesReturnItemsUncheckedUpdateWithoutProductSerialsInput>
  }

  export type SalesReturnItemsUpdateManyWithWhereWithoutProductSerialsInput = {
    where: SalesReturnItemsScalarWhereInput
    data: XOR<SalesReturnItemsUpdateManyMutationInput, SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsInput>
  }

  export type ExchangeItemSerialsUpsertWithWhereUniqueWithoutOldProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    update: XOR<ExchangeItemSerialsUpdateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedUpdateWithoutOldProductSerialsInput>
    create: XOR<ExchangeItemSerialsCreateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutOldProductSerialsInput>
  }

  export type ExchangeItemSerialsUpdateWithWhereUniqueWithoutOldProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    data: XOR<ExchangeItemSerialsUpdateWithoutOldProductSerialsInput, ExchangeItemSerialsUncheckedUpdateWithoutOldProductSerialsInput>
  }

  export type ExchangeItemSerialsUpdateManyWithWhereWithoutOldProductSerialsInput = {
    where: ExchangeItemSerialsScalarWhereInput
    data: XOR<ExchangeItemSerialsUpdateManyMutationInput, ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsInput>
  }

  export type ExchangeItemSerialsScalarWhereInput = {
    AND?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
    OR?: ExchangeItemSerialsScalarWhereInput[]
    NOT?: ExchangeItemSerialsScalarWhereInput | ExchangeItemSerialsScalarWhereInput[]
    id?: IntFilter<"ExchangeItemSerials"> | number
    exchangeItem_id?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_old?: IntFilter<"ExchangeItemSerials"> | number
    serial_id_new?: IntFilter<"ExchangeItemSerials"> | number
  }

  export type ExchangeItemSerialsUpsertWithWhereUniqueWithoutNewProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    update: XOR<ExchangeItemSerialsUpdateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedUpdateWithoutNewProductSerialsInput>
    create: XOR<ExchangeItemSerialsCreateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedCreateWithoutNewProductSerialsInput>
  }

  export type ExchangeItemSerialsUpdateWithWhereUniqueWithoutNewProductSerialsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    data: XOR<ExchangeItemSerialsUpdateWithoutNewProductSerialsInput, ExchangeItemSerialsUncheckedUpdateWithoutNewProductSerialsInput>
  }

  export type ExchangeItemSerialsUpdateManyWithWhereWithoutNewProductSerialsInput = {
    where: ExchangeItemSerialsScalarWhereInput
    data: XOR<ExchangeItemSerialsUpdateManyMutationInput, ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsInput>
  }

  export type UsersCreateWithoutExpensesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
  }

  export type UsersUncheckedCreateWithoutExpensesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
  }

  export type UsersCreateOrConnectWithoutExpensesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutExpensesInput, UsersUncheckedCreateWithoutExpensesInput>
  }

  export type UsersUpsertWithoutExpensesInput = {
    update: XOR<UsersUpdateWithoutExpensesInput, UsersUncheckedUpdateWithoutExpensesInput>
    create: XOR<UsersCreateWithoutExpensesInput, UsersUncheckedCreateWithoutExpensesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutExpensesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutExpensesInput, UsersUncheckedUpdateWithoutExpensesInput>
  }

  export type UsersUpdateWithoutExpensesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
  }

  export type UsersUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
  }

  export type CustomersCreateWithoutSalesInput = {
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    SalesReturn?: SalesReturnCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesCreateNestedManyWithoutCustomersInput
    Services?: ServicesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutSalesInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutCustomersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutSalesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutSalesInput, CustomersUncheckedCreateWithoutSalesInput>
  }

  export type UsersCreateWithoutSalesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutSalesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutSalesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSalesInput, UsersUncheckedCreateWithoutSalesInput>
  }

  export type SalesItemsCreateWithoutSalesInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    Products?: ProductsCreateNestedOneWithoutSalesItemsInput
    salesItemSerials?: SalesItemSerialsCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateWithoutSalesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_id: number
    salesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutSalesItemsInput
  }

  export type SalesItemsCreateOrConnectWithoutSalesInput = {
    where: SalesItemsWhereUniqueInput
    create: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput>
  }

  export type SalesItemsCreateManySalesInputEnvelope = {
    data: SalesItemsCreateManySalesInput | SalesItemsCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnCreateWithoutSalesInput = {
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutSalesReturnInput
    Customers: CustomersCreateNestedOneWithoutSalesReturnInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnUncheckedCreateWithoutSalesInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutSalesReturnInput
  }

  export type SalesReturnCreateOrConnectWithoutSalesInput = {
    where: SalesReturnWhereUniqueInput
    create: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput>
  }

  export type SalesReturnCreateManySalesInputEnvelope = {
    data: SalesReturnCreateManySalesInput | SalesReturnCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type ExchangesCreateWithoutSalesInput = {
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users?: UsersCreateNestedOneWithoutExchangesInput
    Customers?: CustomersCreateNestedOneWithoutExchangesInput
    ExchangeItems?: ExchangesItemsCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesUncheckedCreateWithoutSalesInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ExchangeItems?: ExchangesItemsUncheckedCreateNestedManyWithoutExchangesInput
  }

  export type ExchangesCreateOrConnectWithoutSalesInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput>
  }

  export type ExchangesCreateManySalesInputEnvelope = {
    data: ExchangesCreateManySalesInput | ExchangesCreateManySalesInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithoutSalesInput = {
    update: XOR<CustomersUpdateWithoutSalesInput, CustomersUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomersCreateWithoutSalesInput, CustomersUncheckedCreateWithoutSalesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutSalesInput, CustomersUncheckedUpdateWithoutSalesInput>
  }

  export type CustomersUpdateWithoutSalesInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    SalesReturn?: SalesReturnUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type UsersUpsertWithoutSalesInput = {
    update: XOR<UsersUpdateWithoutSalesInput, UsersUncheckedUpdateWithoutSalesInput>
    create: XOR<UsersCreateWithoutSalesInput, UsersUncheckedCreateWithoutSalesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSalesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSalesInput, UsersUncheckedUpdateWithoutSalesInput>
  }

  export type UsersUpdateWithoutSalesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SalesItemsUpsertWithWhereUniqueWithoutSalesInput = {
    where: SalesItemsWhereUniqueInput
    update: XOR<SalesItemsUpdateWithoutSalesInput, SalesItemsUncheckedUpdateWithoutSalesInput>
    create: XOR<SalesItemsCreateWithoutSalesInput, SalesItemsUncheckedCreateWithoutSalesInput>
  }

  export type SalesItemsUpdateWithWhereUniqueWithoutSalesInput = {
    where: SalesItemsWhereUniqueInput
    data: XOR<SalesItemsUpdateWithoutSalesInput, SalesItemsUncheckedUpdateWithoutSalesInput>
  }

  export type SalesItemsUpdateManyWithWhereWithoutSalesInput = {
    where: SalesItemsScalarWhereInput
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyWithoutSalesInput>
  }

  export type SalesReturnUpsertWithWhereUniqueWithoutSalesInput = {
    where: SalesReturnWhereUniqueInput
    update: XOR<SalesReturnUpdateWithoutSalesInput, SalesReturnUncheckedUpdateWithoutSalesInput>
    create: XOR<SalesReturnCreateWithoutSalesInput, SalesReturnUncheckedCreateWithoutSalesInput>
  }

  export type SalesReturnUpdateWithWhereUniqueWithoutSalesInput = {
    where: SalesReturnWhereUniqueInput
    data: XOR<SalesReturnUpdateWithoutSalesInput, SalesReturnUncheckedUpdateWithoutSalesInput>
  }

  export type SalesReturnUpdateManyWithWhereWithoutSalesInput = {
    where: SalesReturnScalarWhereInput
    data: XOR<SalesReturnUpdateManyMutationInput, SalesReturnUncheckedUpdateManyWithoutSalesInput>
  }

  export type ExchangesUpsertWithWhereUniqueWithoutSalesInput = {
    where: ExchangesWhereUniqueInput
    update: XOR<ExchangesUpdateWithoutSalesInput, ExchangesUncheckedUpdateWithoutSalesInput>
    create: XOR<ExchangesCreateWithoutSalesInput, ExchangesUncheckedCreateWithoutSalesInput>
  }

  export type ExchangesUpdateWithWhereUniqueWithoutSalesInput = {
    where: ExchangesWhereUniqueInput
    data: XOR<ExchangesUpdateWithoutSalesInput, ExchangesUncheckedUpdateWithoutSalesInput>
  }

  export type ExchangesUpdateManyWithWhereWithoutSalesInput = {
    where: ExchangesScalarWhereInput
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyWithoutSalesInput>
  }

  export type SalesCreateWithoutSalesItemsInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutSalesInput
    Users?: UsersCreateNestedOneWithoutSalesInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateWithoutSalesItemsInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesCreateOrConnectWithoutSalesItemsInput = {
    where: SalesWhereUniqueInput
    create: XOR<SalesCreateWithoutSalesItemsInput, SalesUncheckedCreateWithoutSalesItemsInput>
  }

  export type ProductsCreateWithoutSalesItemsInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutSalesItemsInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutSalesItemsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutSalesItemsInput, ProductsUncheckedCreateWithoutSalesItemsInput>
  }

  export type SalesItemSerialsCreateWithoutSalesItemsInput = {
    ProductSerials: ProductSerialsCreateNestedOneWithoutSalesItemSerialsInput
  }

  export type SalesItemSerialsUncheckedCreateWithoutSalesItemsInput = {
    id?: number
    serial_id: number
  }

  export type SalesItemSerialsCreateOrConnectWithoutSalesItemsInput = {
    where: SalesItemSerialsWhereUniqueInput
    create: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput>
  }

  export type SalesItemSerialsCreateManySalesItemsInputEnvelope = {
    data: SalesItemSerialsCreateManySalesItemsInput | SalesItemSerialsCreateManySalesItemsInput[]
    skipDuplicates?: boolean
  }

  export type SalesUpsertWithoutSalesItemsInput = {
    update: XOR<SalesUpdateWithoutSalesItemsInput, SalesUncheckedUpdateWithoutSalesItemsInput>
    create: XOR<SalesCreateWithoutSalesItemsInput, SalesUncheckedCreateWithoutSalesItemsInput>
    where?: SalesWhereInput
  }

  export type SalesUpdateToOneWithWhereWithoutSalesItemsInput = {
    where?: SalesWhereInput
    data: XOR<SalesUpdateWithoutSalesItemsInput, SalesUncheckedUpdateWithoutSalesItemsInput>
  }

  export type SalesUpdateWithoutSalesItemsInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutSalesNestedInput
    Users?: UsersUpdateOneWithoutSalesNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type ProductsUpsertWithoutSalesItemsInput = {
    update: XOR<ProductsUpdateWithoutSalesItemsInput, ProductsUncheckedUpdateWithoutSalesItemsInput>
    create: XOR<ProductsCreateWithoutSalesItemsInput, ProductsUncheckedCreateWithoutSalesItemsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutSalesItemsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutSalesItemsInput, ProductsUncheckedUpdateWithoutSalesItemsInput>
  }

  export type ProductsUpdateWithoutSalesItemsInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type SalesItemSerialsUpsertWithWhereUniqueWithoutSalesItemsInput = {
    where: SalesItemSerialsWhereUniqueInput
    update: XOR<SalesItemSerialsUpdateWithoutSalesItemsInput, SalesItemSerialsUncheckedUpdateWithoutSalesItemsInput>
    create: XOR<SalesItemSerialsCreateWithoutSalesItemsInput, SalesItemSerialsUncheckedCreateWithoutSalesItemsInput>
  }

  export type SalesItemSerialsUpdateWithWhereUniqueWithoutSalesItemsInput = {
    where: SalesItemSerialsWhereUniqueInput
    data: XOR<SalesItemSerialsUpdateWithoutSalesItemsInput, SalesItemSerialsUncheckedUpdateWithoutSalesItemsInput>
  }

  export type SalesItemSerialsUpdateManyWithWhereWithoutSalesItemsInput = {
    where: SalesItemSerialsScalarWhereInput
    data: XOR<SalesItemSerialsUpdateManyMutationInput, SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsInput>
  }

  export type SalesItemsCreateWithoutSalesItemSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    Sales?: SalesCreateNestedOneWithoutSalesItemsInput
    Products?: ProductsCreateNestedOneWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateWithoutSalesItemSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    sales_id: number
    product_id: number
  }

  export type SalesItemsCreateOrConnectWithoutSalesItemSerialsInput = {
    where: SalesItemsWhereUniqueInput
    create: XOR<SalesItemsCreateWithoutSalesItemSerialsInput, SalesItemsUncheckedCreateWithoutSalesItemSerialsInput>
  }

  export type ProductSerialsCreateWithoutSalesItemSerialsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutSalesItemSerialsInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutSalesItemSerialsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutSalesItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesItemSerialsInput>
  }

  export type SalesItemsUpsertWithoutSalesItemSerialsInput = {
    update: XOR<SalesItemsUpdateWithoutSalesItemSerialsInput, SalesItemsUncheckedUpdateWithoutSalesItemSerialsInput>
    create: XOR<SalesItemsCreateWithoutSalesItemSerialsInput, SalesItemsUncheckedCreateWithoutSalesItemSerialsInput>
    where?: SalesItemsWhereInput
  }

  export type SalesItemsUpdateToOneWithWhereWithoutSalesItemSerialsInput = {
    where?: SalesItemsWhereInput
    data: XOR<SalesItemsUpdateWithoutSalesItemSerialsInput, SalesItemsUncheckedUpdateWithoutSalesItemSerialsInput>
  }

  export type SalesItemsUpdateWithoutSalesItemSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Sales?: SalesUpdateOneWithoutSalesItemsNestedInput
    Products?: ProductsUpdateOneWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateWithoutSalesItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductSerialsUpsertWithoutSalesItemSerialsInput = {
    update: XOR<ProductSerialsUpdateWithoutSalesItemSerialsInput, ProductSerialsUncheckedUpdateWithoutSalesItemSerialsInput>
    create: XOR<ProductSerialsCreateWithoutSalesItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesItemSerialsInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutSalesItemSerialsInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutSalesItemSerialsInput, ProductSerialsUncheckedUpdateWithoutSalesItemSerialsInput>
  }

  export type ProductSerialsUpdateWithoutSalesItemSerialsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutSalesItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type SalesCreateWithoutSalesReturnInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutSalesInput
    Users?: UsersCreateNestedOneWithoutSalesInput
    SalesItems?: SalesItemsCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateWithoutSalesReturnInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutSalesInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesCreateOrConnectWithoutSalesReturnInput = {
    where: SalesWhereUniqueInput
    create: XOR<SalesCreateWithoutSalesReturnInput, SalesUncheckedCreateWithoutSalesReturnInput>
  }

  export type UsersCreateWithoutSalesReturnInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutSalesReturnInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutSalesReturnInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSalesReturnInput, UsersUncheckedCreateWithoutSalesReturnInput>
  }

  export type CustomersCreateWithoutSalesReturnInput = {
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesCreateNestedManyWithoutCustomersInput
    Services?: ServicesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutSalesReturnInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesUncheckedCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutCustomersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutSalesReturnInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutSalesReturnInput, CustomersUncheckedCreateWithoutSalesReturnInput>
  }

  export type SalesReturnItemsCreateWithoutSalesReturnInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products?: ProductsCreateNestedOneWithoutSalesReturnItemsInput
    productSerials?: ProductSerialsCreateNestedOneWithoutSalesReturnItemsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUncheckedCreateWithoutSalesReturnInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    productSerialsId?: number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsCreateOrConnectWithoutSalesReturnInput = {
    where: SalesReturnItemsWhereUniqueInput
    create: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput>
  }

  export type SalesReturnItemsCreateManySalesReturnInputEnvelope = {
    data: SalesReturnItemsCreateManySalesReturnInput | SalesReturnItemsCreateManySalesReturnInput[]
    skipDuplicates?: boolean
  }

  export type SalesUpsertWithoutSalesReturnInput = {
    update: XOR<SalesUpdateWithoutSalesReturnInput, SalesUncheckedUpdateWithoutSalesReturnInput>
    create: XOR<SalesCreateWithoutSalesReturnInput, SalesUncheckedCreateWithoutSalesReturnInput>
    where?: SalesWhereInput
  }

  export type SalesUpdateToOneWithWhereWithoutSalesReturnInput = {
    where?: SalesWhereInput
    data: XOR<SalesUpdateWithoutSalesReturnInput, SalesUncheckedUpdateWithoutSalesReturnInput>
  }

  export type SalesUpdateWithoutSalesReturnInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutSalesNestedInput
    Users?: UsersUpdateOneWithoutSalesNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateWithoutSalesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type UsersUpsertWithoutSalesReturnInput = {
    update: XOR<UsersUpdateWithoutSalesReturnInput, UsersUncheckedUpdateWithoutSalesReturnInput>
    create: XOR<UsersCreateWithoutSalesReturnInput, UsersUncheckedCreateWithoutSalesReturnInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSalesReturnInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSalesReturnInput, UsersUncheckedUpdateWithoutSalesReturnInput>
  }

  export type UsersUpdateWithoutSalesReturnInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutSalesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CustomersUpsertWithoutSalesReturnInput = {
    update: XOR<CustomersUpdateWithoutSalesReturnInput, CustomersUncheckedUpdateWithoutSalesReturnInput>
    create: XOR<CustomersCreateWithoutSalesReturnInput, CustomersUncheckedCreateWithoutSalesReturnInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutSalesReturnInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutSalesReturnInput, CustomersUncheckedUpdateWithoutSalesReturnInput>
  }

  export type CustomersUpdateWithoutSalesReturnInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutSalesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUncheckedUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type SalesReturnItemsUpsertWithWhereUniqueWithoutSalesReturnInput = {
    where: SalesReturnItemsWhereUniqueInput
    update: XOR<SalesReturnItemsUpdateWithoutSalesReturnInput, SalesReturnItemsUncheckedUpdateWithoutSalesReturnInput>
    create: XOR<SalesReturnItemsCreateWithoutSalesReturnInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnInput>
  }

  export type SalesReturnItemsUpdateWithWhereUniqueWithoutSalesReturnInput = {
    where: SalesReturnItemsWhereUniqueInput
    data: XOR<SalesReturnItemsUpdateWithoutSalesReturnInput, SalesReturnItemsUncheckedUpdateWithoutSalesReturnInput>
  }

  export type SalesReturnItemsUpdateManyWithWhereWithoutSalesReturnInput = {
    where: SalesReturnItemsScalarWhereInput
    data: XOR<SalesReturnItemsUpdateManyMutationInput, SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnInput>
  }

  export type ProductsCreateWithoutSalesReturnItemsInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutSalesReturnItemsInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutSalesReturnItemsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutSalesReturnItemsInput, ProductsUncheckedCreateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnCreateWithoutSalesReturnItemsInput = {
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales: SalesCreateNestedOneWithoutSalesReturnInput
    Users: UsersCreateNestedOneWithoutSalesReturnInput
    Customers: CustomersCreateNestedOneWithoutSalesReturnInput
  }

  export type SalesReturnUncheckedCreateWithoutSalesReturnItemsInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnCreateOrConnectWithoutSalesReturnItemsInput = {
    where: SalesReturnWhereUniqueInput
    create: XOR<SalesReturnCreateWithoutSalesReturnItemsInput, SalesReturnUncheckedCreateWithoutSalesReturnItemsInput>
  }

  export type ProductSerialsCreateWithoutSalesReturnItemsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutSalesReturnItemsInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutSalesReturnItemsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutSalesReturnItemsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput = {
    ProductSerials: ProductSerialsCreateNestedOneWithoutSalesReturnItemSerialsInput
  }

  export type SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput = {
    id?: number
    serial_id: number
  }

  export type SalesReturnItemSerialsCreateOrConnectWithoutSalesReturnItemsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    create: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemSerialsCreateManySalesReturnItemsInputEnvelope = {
    data: SalesReturnItemSerialsCreateManySalesReturnItemsInput | SalesReturnItemSerialsCreateManySalesReturnItemsInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutSalesReturnItemsInput = {
    update: XOR<ProductsUpdateWithoutSalesReturnItemsInput, ProductsUncheckedUpdateWithoutSalesReturnItemsInput>
    create: XOR<ProductsCreateWithoutSalesReturnItemsInput, ProductsUncheckedCreateWithoutSalesReturnItemsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutSalesReturnItemsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutSalesReturnItemsInput, ProductsUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type ProductsUpdateWithoutSalesReturnItemsInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutSalesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type SalesReturnUpsertWithoutSalesReturnItemsInput = {
    update: XOR<SalesReturnUpdateWithoutSalesReturnItemsInput, SalesReturnUncheckedUpdateWithoutSalesReturnItemsInput>
    create: XOR<SalesReturnCreateWithoutSalesReturnItemsInput, SalesReturnUncheckedCreateWithoutSalesReturnItemsInput>
    where?: SalesReturnWhereInput
  }

  export type SalesReturnUpdateToOneWithWhereWithoutSalesReturnItemsInput = {
    where?: SalesReturnWhereInput
    data: XOR<SalesReturnUpdateWithoutSalesReturnItemsInput, SalesReturnUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnUpdateWithoutSalesReturnItemsInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneRequiredWithoutSalesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutSalesReturnNestedInput
    Customers?: CustomersUpdateOneRequiredWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateWithoutSalesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSerialsUpsertWithoutSalesReturnItemsInput = {
    update: XOR<ProductSerialsUpdateWithoutSalesReturnItemsInput, ProductSerialsUncheckedUpdateWithoutSalesReturnItemsInput>
    create: XOR<ProductSerialsCreateWithoutSalesReturnItemsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemsInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutSalesReturnItemsInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutSalesReturnItemsInput, ProductSerialsUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type ProductSerialsUpdateWithoutSalesReturnItemsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutSalesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type SalesReturnItemSerialsUpsertWithWhereUniqueWithoutSalesReturnItemsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    update: XOR<SalesReturnItemSerialsUpdateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedUpdateWithoutSalesReturnItemsInput>
    create: XOR<SalesReturnItemSerialsCreateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedCreateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemSerialsUpdateWithWhereUniqueWithoutSalesReturnItemsInput = {
    where: SalesReturnItemSerialsWhereUniqueInput
    data: XOR<SalesReturnItemSerialsUpdateWithoutSalesReturnItemsInput, SalesReturnItemSerialsUncheckedUpdateWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemSerialsUpdateManyWithWhereWithoutSalesReturnItemsInput = {
    where: SalesReturnItemSerialsScalarWhereInput
    data: XOR<SalesReturnItemSerialsUpdateManyMutationInput, SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsInput>
  }

  export type SalesReturnItemsCreateWithoutSalesReturnItemSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products?: ProductsCreateNestedOneWithoutSalesReturnItemsInput
    SalesReturn?: SalesReturnCreateNestedOneWithoutSalesReturnItemsInput
    productSerials?: ProductSerialsCreateNestedOneWithoutSalesReturnItemsInput
  }

  export type SalesReturnItemsUncheckedCreateWithoutSalesReturnItemSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    salesReturn_id: number
    productSerialsId?: number | null
  }

  export type SalesReturnItemsCreateOrConnectWithoutSalesReturnItemSerialsInput = {
    where: SalesReturnItemsWhereUniqueInput
    create: XOR<SalesReturnItemsCreateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnItemSerialsInput>
  }

  export type ProductSerialsCreateWithoutSalesReturnItemSerialsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutSalesReturnItemSerialsInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutSalesReturnItemSerialsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemSerialsInput>
  }

  export type SalesReturnItemsUpsertWithoutSalesReturnItemSerialsInput = {
    update: XOR<SalesReturnItemsUpdateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
    create: XOR<SalesReturnItemsCreateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    where?: SalesReturnItemsWhereInput
  }

  export type SalesReturnItemsUpdateToOneWithWhereWithoutSalesReturnItemSerialsInput = {
    where?: SalesReturnItemsWhereInput
    data: XOR<SalesReturnItemsUpdateWithoutSalesReturnItemSerialsInput, SalesReturnItemsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
  }

  export type SalesReturnItemsUpdateWithoutSalesReturnItemSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneWithoutSalesReturnItemsNestedInput
    SalesReturn?: SalesReturnUpdateOneWithoutSalesReturnItemsNestedInput
    productSerials?: ProductSerialsUpdateOneWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateWithoutSalesReturnItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductSerialsUpsertWithoutSalesReturnItemSerialsInput = {
    update: XOR<ProductSerialsUpdateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
    create: XOR<ProductSerialsCreateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutSalesReturnItemSerialsInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutSalesReturnItemSerialsInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutSalesReturnItemSerialsInput, ProductSerialsUncheckedUpdateWithoutSalesReturnItemSerialsInput>
  }

  export type ProductSerialsUpdateWithoutSalesReturnItemSerialsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutSalesReturnItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type SalesCreateWithoutExchangesInput = {
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Customers?: CustomersCreateNestedOneWithoutSalesInput
    Users?: UsersCreateNestedOneWithoutSalesInput
    SalesItems?: SalesItemsCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutSalesInput
  }

  export type SalesUncheckedCreateWithoutExchangesInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutSalesInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutSalesInput
  }

  export type SalesCreateOrConnectWithoutExchangesInput = {
    where: SalesWhereUniqueInput
    create: XOR<SalesCreateWithoutExchangesInput, SalesUncheckedCreateWithoutExchangesInput>
  }

  export type UsersCreateWithoutExchangesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutExchangesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutExchangesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutExchangesInput, UsersUncheckedCreateWithoutExchangesInput>
  }

  export type CustomersCreateWithoutExchangesInput = {
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutCustomersInput
    Services?: ServicesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutExchangesInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesUncheckedCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutCustomersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutExchangesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutExchangesInput, CustomersUncheckedCreateWithoutExchangesInput>
  }

  export type ExchangesItemsCreateWithoutExchangesInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oldProduct?: ProductsCreateNestedOneWithoutExchangeItemsOldInput
    newProduct?: ProductsCreateNestedOneWithoutExchangeItemsNewInput
    exchangeItemSerials?: ExchangeItemSerialsCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsUncheckedCreateWithoutExchangesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    newProduct_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutExchangesItemsInput
  }

  export type ExchangesItemsCreateOrConnectWithoutExchangesInput = {
    where: ExchangesItemsWhereUniqueInput
    create: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput>
  }

  export type ExchangesItemsCreateManyExchangesInputEnvelope = {
    data: ExchangesItemsCreateManyExchangesInput | ExchangesItemsCreateManyExchangesInput[]
    skipDuplicates?: boolean
  }

  export type SalesUpsertWithoutExchangesInput = {
    update: XOR<SalesUpdateWithoutExchangesInput, SalesUncheckedUpdateWithoutExchangesInput>
    create: XOR<SalesCreateWithoutExchangesInput, SalesUncheckedCreateWithoutExchangesInput>
    where?: SalesWhereInput
  }

  export type SalesUpdateToOneWithWhereWithoutExchangesInput = {
    where?: SalesWhereInput
    data: XOR<SalesUpdateWithoutExchangesInput, SalesUncheckedUpdateWithoutExchangesInput>
  }

  export type SalesUpdateWithoutExchangesInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutSalesNestedInput
    Users?: UsersUpdateOneWithoutSalesNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateWithoutExchangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type UsersUpsertWithoutExchangesInput = {
    update: XOR<UsersUpdateWithoutExchangesInput, UsersUncheckedUpdateWithoutExchangesInput>
    create: XOR<UsersCreateWithoutExchangesInput, UsersUncheckedCreateWithoutExchangesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutExchangesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutExchangesInput, UsersUncheckedUpdateWithoutExchangesInput>
  }

  export type UsersUpdateWithoutExchangesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutExchangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CustomersUpsertWithoutExchangesInput = {
    update: XOR<CustomersUpdateWithoutExchangesInput, CustomersUncheckedUpdateWithoutExchangesInput>
    create: XOR<CustomersCreateWithoutExchangesInput, CustomersUncheckedCreateWithoutExchangesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutExchangesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutExchangesInput, CustomersUncheckedUpdateWithoutExchangesInput>
  }

  export type CustomersUpdateWithoutExchangesInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutExchangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUncheckedUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutCustomersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type ExchangesItemsUpsertWithWhereUniqueWithoutExchangesInput = {
    where: ExchangesItemsWhereUniqueInput
    update: XOR<ExchangesItemsUpdateWithoutExchangesInput, ExchangesItemsUncheckedUpdateWithoutExchangesInput>
    create: XOR<ExchangesItemsCreateWithoutExchangesInput, ExchangesItemsUncheckedCreateWithoutExchangesInput>
  }

  export type ExchangesItemsUpdateWithWhereUniqueWithoutExchangesInput = {
    where: ExchangesItemsWhereUniqueInput
    data: XOR<ExchangesItemsUpdateWithoutExchangesInput, ExchangesItemsUncheckedUpdateWithoutExchangesInput>
  }

  export type ExchangesItemsUpdateManyWithWhereWithoutExchangesInput = {
    where: ExchangesItemsScalarWhereInput
    data: XOR<ExchangesItemsUpdateManyMutationInput, ExchangesItemsUncheckedUpdateManyWithoutExchangesInput>
  }

  export type ProductsCreateWithoutExchangeItemsOldInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutExchangeItemsOldInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutExchangeItemsOldInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutExchangeItemsOldInput, ProductsUncheckedCreateWithoutExchangeItemsOldInput>
  }

  export type ProductsCreateWithoutExchangeItemsNewInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutExchangeItemsNewInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutExchangeItemsNewInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutExchangeItemsNewInput, ProductsUncheckedCreateWithoutExchangeItemsNewInput>
  }

  export type ExchangesCreateWithoutExchangeItemsInput = {
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Sales?: SalesCreateNestedOneWithoutExchangesInput
    Users?: UsersCreateNestedOneWithoutExchangesInput
    Customers?: CustomersCreateNestedOneWithoutExchangesInput
  }

  export type ExchangesUncheckedCreateWithoutExchangeItemsInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesCreateOrConnectWithoutExchangeItemsInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutExchangeItemsInput, ExchangesUncheckedCreateWithoutExchangeItemsInput>
  }

  export type ExchangeItemSerialsCreateWithoutExchangesItemsInput = {
    OldProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsOldInput
    NewProductSerials: ProductSerialsCreateNestedOneWithoutExchangeItemSerialsNewInput
  }

  export type ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput = {
    id?: number
    serial_id_old: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsCreateOrConnectWithoutExchangesItemsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    create: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput>
  }

  export type ExchangeItemSerialsCreateManyExchangesItemsInputEnvelope = {
    data: ExchangeItemSerialsCreateManyExchangesItemsInput | ExchangeItemSerialsCreateManyExchangesItemsInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutExchangeItemsOldInput = {
    update: XOR<ProductsUpdateWithoutExchangeItemsOldInput, ProductsUncheckedUpdateWithoutExchangeItemsOldInput>
    create: XOR<ProductsCreateWithoutExchangeItemsOldInput, ProductsUncheckedCreateWithoutExchangeItemsOldInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutExchangeItemsOldInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutExchangeItemsOldInput, ProductsUncheckedUpdateWithoutExchangeItemsOldInput>
  }

  export type ProductsUpdateWithoutExchangeItemsOldInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutExchangeItemsOldInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUpsertWithoutExchangeItemsNewInput = {
    update: XOR<ProductsUpdateWithoutExchangeItemsNewInput, ProductsUncheckedUpdateWithoutExchangeItemsNewInput>
    create: XOR<ProductsCreateWithoutExchangeItemsNewInput, ProductsUncheckedCreateWithoutExchangeItemsNewInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutExchangeItemsNewInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutExchangeItemsNewInput, ProductsUncheckedUpdateWithoutExchangeItemsNewInput>
  }

  export type ProductsUpdateWithoutExchangeItemsNewInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutExchangeItemsNewInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ExchangesUpsertWithoutExchangeItemsInput = {
    update: XOR<ExchangesUpdateWithoutExchangeItemsInput, ExchangesUncheckedUpdateWithoutExchangeItemsInput>
    create: XOR<ExchangesCreateWithoutExchangeItemsInput, ExchangesUncheckedCreateWithoutExchangeItemsInput>
    where?: ExchangesWhereInput
  }

  export type ExchangesUpdateToOneWithWhereWithoutExchangeItemsInput = {
    where?: ExchangesWhereInput
    data: XOR<ExchangesUpdateWithoutExchangeItemsInput, ExchangesUncheckedUpdateWithoutExchangeItemsInput>
  }

  export type ExchangesUpdateWithoutExchangeItemsInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneWithoutExchangesNestedInput
    Users?: UsersUpdateOneWithoutExchangesNestedInput
    Customers?: CustomersUpdateOneWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutExchangeItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeItemSerialsUpsertWithWhereUniqueWithoutExchangesItemsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    update: XOR<ExchangeItemSerialsUpdateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedUpdateWithoutExchangesItemsInput>
    create: XOR<ExchangeItemSerialsCreateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedCreateWithoutExchangesItemsInput>
  }

  export type ExchangeItemSerialsUpdateWithWhereUniqueWithoutExchangesItemsInput = {
    where: ExchangeItemSerialsWhereUniqueInput
    data: XOR<ExchangeItemSerialsUpdateWithoutExchangesItemsInput, ExchangeItemSerialsUncheckedUpdateWithoutExchangesItemsInput>
  }

  export type ExchangeItemSerialsUpdateManyWithWhereWithoutExchangesItemsInput = {
    where: ExchangeItemSerialsScalarWhereInput
    data: XOR<ExchangeItemSerialsUpdateManyMutationInput, ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsInput>
  }

  export type ExchangesItemsCreateWithoutExchangeItemSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oldProduct?: ProductsCreateNestedOneWithoutExchangeItemsOldInput
    newProduct?: ProductsCreateNestedOneWithoutExchangeItemsNewInput
    Exchanges?: ExchangesCreateNestedOneWithoutExchangeItemsInput
  }

  export type ExchangesItemsUncheckedCreateWithoutExchangeItemSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    newProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesItemsCreateOrConnectWithoutExchangeItemSerialsInput = {
    where: ExchangesItemsWhereUniqueInput
    create: XOR<ExchangesItemsCreateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedCreateWithoutExchangeItemSerialsInput>
  }

  export type ProductSerialsCreateWithoutExchangeItemSerialsOldInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutExchangeItemSerialsOldInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutExchangeItemSerialsOldInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsOldInput>
  }

  export type ProductSerialsCreateWithoutExchangeItemSerialsNewInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutExchangeItemSerialsNewInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutExchangeItemSerialsNewInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsNewInput>
  }

  export type ExchangesItemsUpsertWithoutExchangeItemSerialsInput = {
    update: XOR<ExchangesItemsUpdateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedUpdateWithoutExchangeItemSerialsInput>
    create: XOR<ExchangesItemsCreateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedCreateWithoutExchangeItemSerialsInput>
    where?: ExchangesItemsWhereInput
  }

  export type ExchangesItemsUpdateToOneWithWhereWithoutExchangeItemSerialsInput = {
    where?: ExchangesItemsWhereInput
    data: XOR<ExchangesItemsUpdateWithoutExchangeItemSerialsInput, ExchangesItemsUncheckedUpdateWithoutExchangeItemSerialsInput>
  }

  export type ExchangesItemsUpdateWithoutExchangeItemSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oldProduct?: ProductsUpdateOneWithoutExchangeItemsOldNestedInput
    newProduct?: ProductsUpdateOneWithoutExchangeItemsNewNestedInput
    Exchanges?: ExchangesUpdateOneWithoutExchangeItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateWithoutExchangeItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    newProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSerialsUpsertWithoutExchangeItemSerialsOldInput = {
    update: XOR<ProductSerialsUpdateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsOldInput>
    create: XOR<ProductSerialsCreateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsOldInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutExchangeItemSerialsOldInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutExchangeItemSerialsOldInput, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsOldInput>
  }

  export type ProductSerialsUpdateWithoutExchangeItemSerialsOldInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsOldInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUpsertWithoutExchangeItemSerialsNewInput = {
    update: XOR<ProductSerialsUpdateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsNewInput>
    create: XOR<ProductSerialsCreateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedCreateWithoutExchangeItemSerialsNewInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutExchangeItemSerialsNewInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutExchangeItemSerialsNewInput, ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsNewInput>
  }

  export type ProductSerialsUpdateWithoutExchangeItemSerialsNewInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutExchangeItemSerialsNewInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
  }

  export type SuppliersCreateWithoutPurchasesInput = {
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutSuppliersInput
    products?: ProductsCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUncheckedCreateWithoutPurchasesInput = {
    id?: number
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutSuppliersInput
    products?: ProductsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutPurchasesInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutPurchasesInput, SuppliersUncheckedCreateWithoutPurchasesInput>
  }

  export type UsersCreateWithoutPurchasesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPurchasesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPurchasesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPurchasesInput, UsersUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchasesItemsCreateWithoutPurchasesInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products: ProductsCreateNestedOneWithoutPurchasesItemsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsUncheckedCreateWithoutPurchasesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutPurchasesItemsInput
  }

  export type PurchasesItemsCreateOrConnectWithoutPurchasesInput = {
    where: PurchasesItemsWhereUniqueInput
    create: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchasesItemsCreateManyPurchasesInputEnvelope = {
    data: PurchasesItemsCreateManyPurchasesInput | PurchasesItemsCreateManyPurchasesInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesReturnCreateWithoutPurchasesInput = {
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutPurchasesReturnInput
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesReturnInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUncheckedCreateWithoutPurchasesInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutPurchasesReturnInput
  }

  export type PurchasesReturnCreateOrConnectWithoutPurchasesInput = {
    where: PurchasesReturnWhereUniqueInput
    create: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchasesReturnCreateManyPurchasesInputEnvelope = {
    data: PurchasesReturnCreateManyPurchasesInput | PurchasesReturnCreateManyPurchasesInput[]
    skipDuplicates?: boolean
  }

  export type SuppliersUpsertWithoutPurchasesInput = {
    update: XOR<SuppliersUpdateWithoutPurchasesInput, SuppliersUncheckedUpdateWithoutPurchasesInput>
    create: XOR<SuppliersCreateWithoutPurchasesInput, SuppliersUncheckedCreateWithoutPurchasesInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutPurchasesInput, SuppliersUncheckedUpdateWithoutPurchasesInput>
  }

  export type SuppliersUpdateWithoutPurchasesInput = {
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UsersUpsertWithoutPurchasesInput = {
    update: XOR<UsersUpdateWithoutPurchasesInput, UsersUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UsersCreateWithoutPurchasesInput, UsersUncheckedCreateWithoutPurchasesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPurchasesInput, UsersUncheckedUpdateWithoutPurchasesInput>
  }

  export type UsersUpdateWithoutPurchasesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PurchasesItemsUpsertWithWhereUniqueWithoutPurchasesInput = {
    where: PurchasesItemsWhereUniqueInput
    update: XOR<PurchasesItemsUpdateWithoutPurchasesInput, PurchasesItemsUncheckedUpdateWithoutPurchasesInput>
    create: XOR<PurchasesItemsCreateWithoutPurchasesInput, PurchasesItemsUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchasesItemsUpdateWithWhereUniqueWithoutPurchasesInput = {
    where: PurchasesItemsWhereUniqueInput
    data: XOR<PurchasesItemsUpdateWithoutPurchasesInput, PurchasesItemsUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchasesItemsUpdateManyWithWhereWithoutPurchasesInput = {
    where: PurchasesItemsScalarWhereInput
    data: XOR<PurchasesItemsUpdateManyMutationInput, PurchasesItemsUncheckedUpdateManyWithoutPurchasesInput>
  }

  export type PurchasesReturnUpsertWithWhereUniqueWithoutPurchasesInput = {
    where: PurchasesReturnWhereUniqueInput
    update: XOR<PurchasesReturnUpdateWithoutPurchasesInput, PurchasesReturnUncheckedUpdateWithoutPurchasesInput>
    create: XOR<PurchasesReturnCreateWithoutPurchasesInput, PurchasesReturnUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchasesReturnUpdateWithWhereUniqueWithoutPurchasesInput = {
    where: PurchasesReturnWhereUniqueInput
    data: XOR<PurchasesReturnUpdateWithoutPurchasesInput, PurchasesReturnUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchasesReturnUpdateManyWithWhereWithoutPurchasesInput = {
    where: PurchasesReturnScalarWhereInput
    data: XOR<PurchasesReturnUpdateManyMutationInput, PurchasesReturnUncheckedUpdateManyWithoutPurchasesInput>
  }

  export type PurchasesCreateWithoutPurchasesItemsInput = {
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesInput
    Users: UsersCreateNestedOneWithoutPurchasesInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUncheckedCreateWithoutPurchasesItemsInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesCreateOrConnectWithoutPurchasesItemsInput = {
    where: PurchasesWhereUniqueInput
    create: XOR<PurchasesCreateWithoutPurchasesItemsInput, PurchasesUncheckedCreateWithoutPurchasesItemsInput>
  }

  export type ProductsCreateWithoutPurchasesItemsInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesReturnItems?: PurchasesReturnItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutPurchasesItemsInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutPurchasesItemsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPurchasesItemsInput, ProductsUncheckedCreateWithoutPurchasesItemsInput>
  }

  export type PurchaseItemSerialsCreateWithoutPurchasesItemsInput = {
    ProductSerials: ProductSerialsCreateNestedOneWithoutPurchaseItemSerialsInput
  }

  export type PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput = {
    id?: number
    serial_id: number
  }

  export type PurchaseItemSerialsCreateOrConnectWithoutPurchasesItemsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    create: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput>
  }

  export type PurchaseItemSerialsCreateManyPurchasesItemsInputEnvelope = {
    data: PurchaseItemSerialsCreateManyPurchasesItemsInput | PurchaseItemSerialsCreateManyPurchasesItemsInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesUpsertWithoutPurchasesItemsInput = {
    update: XOR<PurchasesUpdateWithoutPurchasesItemsInput, PurchasesUncheckedUpdateWithoutPurchasesItemsInput>
    create: XOR<PurchasesCreateWithoutPurchasesItemsInput, PurchasesUncheckedCreateWithoutPurchasesItemsInput>
    where?: PurchasesWhereInput
  }

  export type PurchasesUpdateToOneWithWhereWithoutPurchasesItemsInput = {
    where?: PurchasesWhereInput
    data: XOR<PurchasesUpdateWithoutPurchasesItemsInput, PurchasesUncheckedUpdateWithoutPurchasesItemsInput>
  }

  export type PurchasesUpdateWithoutPurchasesItemsInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateWithoutPurchasesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutPurchasesNestedInput
  }

  export type ProductsUpsertWithoutPurchasesItemsInput = {
    update: XOR<ProductsUpdateWithoutPurchasesItemsInput, ProductsUncheckedUpdateWithoutPurchasesItemsInput>
    create: XOR<ProductsCreateWithoutPurchasesItemsInput, ProductsUncheckedCreateWithoutPurchasesItemsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutPurchasesItemsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutPurchasesItemsInput, ProductsUncheckedUpdateWithoutPurchasesItemsInput>
  }

  export type ProductsUpdateWithoutPurchasesItemsInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutPurchasesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type PurchaseItemSerialsUpsertWithWhereUniqueWithoutPurchasesItemsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    update: XOR<PurchaseItemSerialsUpdateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedUpdateWithoutPurchasesItemsInput>
    create: XOR<PurchaseItemSerialsCreateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedCreateWithoutPurchasesItemsInput>
  }

  export type PurchaseItemSerialsUpdateWithWhereUniqueWithoutPurchasesItemsInput = {
    where: PurchaseItemSerialsWhereUniqueInput
    data: XOR<PurchaseItemSerialsUpdateWithoutPurchasesItemsInput, PurchaseItemSerialsUncheckedUpdateWithoutPurchasesItemsInput>
  }

  export type PurchaseItemSerialsUpdateManyWithWhereWithoutPurchasesItemsInput = {
    where: PurchaseItemSerialsScalarWhereInput
    data: XOR<PurchaseItemSerialsUpdateManyMutationInput, PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsInput>
  }

  export type PurchasesItemsCreateWithoutPurchaseItemSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesItemsInput
    Products: ProductsCreateNestedOneWithoutPurchasesItemsInput
  }

  export type PurchasesItemsUncheckedCreateWithoutPurchaseItemSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchase_id: number
    product_id: number
  }

  export type PurchasesItemsCreateOrConnectWithoutPurchaseItemSerialsInput = {
    where: PurchasesItemsWhereUniqueInput
    create: XOR<PurchasesItemsCreateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedCreateWithoutPurchaseItemSerialsInput>
  }

  export type ProductSerialsCreateWithoutPurchaseItemSerialsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutPurchaseItemSerialsInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutPurchaseItemSerialsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseItemSerialsInput>
  }

  export type PurchasesItemsUpsertWithoutPurchaseItemSerialsInput = {
    update: XOR<PurchasesItemsUpdateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedUpdateWithoutPurchaseItemSerialsInput>
    create: XOR<PurchasesItemsCreateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedCreateWithoutPurchaseItemSerialsInput>
    where?: PurchasesItemsWhereInput
  }

  export type PurchasesItemsUpdateToOneWithWhereWithoutPurchaseItemSerialsInput = {
    where?: PurchasesItemsWhereInput
    data: XOR<PurchasesItemsUpdateWithoutPurchaseItemSerialsInput, PurchasesItemsUncheckedUpdateWithoutPurchaseItemSerialsInput>
  }

  export type PurchasesItemsUpdateWithoutPurchaseItemSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesItemsNestedInput
    Products?: ProductsUpdateOneRequiredWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateWithoutPurchaseItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductSerialsUpsertWithoutPurchaseItemSerialsInput = {
    update: XOR<ProductSerialsUpdateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedUpdateWithoutPurchaseItemSerialsInput>
    create: XOR<ProductSerialsCreateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseItemSerialsInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutPurchaseItemSerialsInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutPurchaseItemSerialsInput, ProductSerialsUncheckedUpdateWithoutPurchaseItemSerialsInput>
  }

  export type ProductSerialsUpdateWithoutPurchaseItemSerialsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutPurchaseItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type PurchasesCreateWithoutPurchasesReturnInput = {
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesInput
    Users: UsersCreateNestedOneWithoutPurchasesInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesUncheckedCreateWithoutPurchasesReturnInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutPurchasesInput
  }

  export type PurchasesCreateOrConnectWithoutPurchasesReturnInput = {
    where: PurchasesWhereUniqueInput
    create: XOR<PurchasesCreateWithoutPurchasesReturnInput, PurchasesUncheckedCreateWithoutPurchasesReturnInput>
  }

  export type UsersCreateWithoutPurchasesReturnInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    Services?: ServicesCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPurchasesReturnInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    Services?: ServicesUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPurchasesReturnInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPurchasesReturnInput, UsersUncheckedCreateWithoutPurchasesReturnInput>
  }

  export type SuppliersCreateWithoutPurchasesReturnInput = {
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesCreateNestedManyWithoutSuppliersInput
    products?: ProductsCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUncheckedCreateWithoutPurchasesReturnInput = {
    id?: number
    suppId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutSuppliersInput
    products?: ProductsUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutPurchasesReturnInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutPurchasesReturnInput, SuppliersUncheckedCreateWithoutPurchasesReturnInput>
  }

  export type PurchasesReturnItemsCreateWithoutPurchasesReturnInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products: ProductsCreateNestedOneWithoutPurchasesReturnItemsInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    products_id: number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedCreateNestedManyWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsCreateOrConnectWithoutPurchasesReturnInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    create: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput>
  }

  export type PurchasesReturnItemsCreateManyPurchasesReturnInputEnvelope = {
    data: PurchasesReturnItemsCreateManyPurchasesReturnInput | PurchasesReturnItemsCreateManyPurchasesReturnInput[]
    skipDuplicates?: boolean
  }

  export type PurchasesUpsertWithoutPurchasesReturnInput = {
    update: XOR<PurchasesUpdateWithoutPurchasesReturnInput, PurchasesUncheckedUpdateWithoutPurchasesReturnInput>
    create: XOR<PurchasesCreateWithoutPurchasesReturnInput, PurchasesUncheckedCreateWithoutPurchasesReturnInput>
    where?: PurchasesWhereInput
  }

  export type PurchasesUpdateToOneWithWhereWithoutPurchasesReturnInput = {
    where?: PurchasesWhereInput
    data: XOR<PurchasesUpdateWithoutPurchasesReturnInput, PurchasesUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type PurchasesUpdateWithoutPurchasesReturnInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateWithoutPurchasesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutPurchasesNestedInput
  }

  export type UsersUpsertWithoutPurchasesReturnInput = {
    update: XOR<UsersUpdateWithoutPurchasesReturnInput, UsersUncheckedUpdateWithoutPurchasesReturnInput>
    create: XOR<UsersCreateWithoutPurchasesReturnInput, UsersUncheckedCreateWithoutPurchasesReturnInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPurchasesReturnInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPurchasesReturnInput, UsersUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type UsersUpdateWithoutPurchasesReturnInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPurchasesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SuppliersUpsertWithoutPurchasesReturnInput = {
    update: XOR<SuppliersUpdateWithoutPurchasesReturnInput, SuppliersUncheckedUpdateWithoutPurchasesReturnInput>
    create: XOR<SuppliersCreateWithoutPurchasesReturnInput, SuppliersUncheckedCreateWithoutPurchasesReturnInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutPurchasesReturnInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutPurchasesReturnInput, SuppliersUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type SuppliersUpdateWithoutPurchasesReturnInput = {
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutPurchasesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    suppId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Purchases?: PurchasesUncheckedUpdateManyWithoutSuppliersNestedInput
    products?: ProductsUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PurchasesReturnItemsUpsertWithWhereUniqueWithoutPurchasesReturnInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    update: XOR<PurchasesReturnItemsUpdateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedUpdateWithoutPurchasesReturnInput>
    create: XOR<PurchasesReturnItemsCreateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedCreateWithoutPurchasesReturnInput>
  }

  export type PurchasesReturnItemsUpdateWithWhereUniqueWithoutPurchasesReturnInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    data: XOR<PurchasesReturnItemsUpdateWithoutPurchasesReturnInput, PurchasesReturnItemsUncheckedUpdateWithoutPurchasesReturnInput>
  }

  export type PurchasesReturnItemsUpdateManyWithWhereWithoutPurchasesReturnInput = {
    where: PurchasesReturnItemsScalarWhereInput
    data: XOR<PurchasesReturnItemsUpdateManyMutationInput, PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnInput>
  }

  export type ProductsCreateWithoutPurchasesReturnItemsInput = {
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Categories?: CategoriesCreateNestedOneWithoutProductsInput
    supplier?: SuppliersCreateNestedOneWithoutProductsInput
    creator?: UsersCreateNestedOneWithoutCreatedProductsInput
    updater?: UsersCreateNestedOneWithoutUpdatedProductsInput
    SalesItems?: SalesItemsCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutPurchasesReturnItemsInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductsInput
    SalesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductsInput
    exchangeItemsOld?: ExchangesItemsUncheckedCreateNestedManyWithoutOldProductInput
    exchangeItemsNew?: ExchangesItemsUncheckedCreateNestedManyWithoutNewProductInput
    PurchasesItems?: PurchasesItemsUncheckedCreateNestedManyWithoutProductsInput
    productSerials?: ProductSerialsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutPurchasesReturnItemsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPurchasesReturnItemsInput, ProductsUncheckedCreateWithoutPurchasesReturnItemsInput>
  }

  export type PurchasesReturnCreateWithoutPurchasesReturnItemsInput = {
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Purchases: PurchasesCreateNestedOneWithoutPurchasesReturnInput
    Users: UsersCreateNestedOneWithoutPurchasesReturnInput
    Suppliers: SuppliersCreateNestedOneWithoutPurchasesReturnInput
  }

  export type PurchasesReturnUncheckedCreateWithoutPurchasesReturnItemsInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    user_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesReturnCreateOrConnectWithoutPurchasesReturnItemsInput = {
    where: PurchasesReturnWhereUniqueInput
    create: XOR<PurchasesReturnCreateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedCreateWithoutPurchasesReturnItemsInput>
  }

  export type PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput = {
    ProductSerials: ProductSerialsCreateNestedOneWithoutPurchaseReturnItemSerialsInput
  }

  export type PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput = {
    id?: number
    serial_id: number
  }

  export type PurchaseReturnItemSerialsCreateOrConnectWithoutPurchasesReturnItemsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    create: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput>
  }

  export type PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInputEnvelope = {
    data: PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInput | PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInput[]
    skipDuplicates?: boolean
  }

  export type ProductsUpsertWithoutPurchasesReturnItemsInput = {
    update: XOR<ProductsUpdateWithoutPurchasesReturnItemsInput, ProductsUncheckedUpdateWithoutPurchasesReturnItemsInput>
    create: XOR<ProductsCreateWithoutPurchasesReturnItemsInput, ProductsUncheckedCreateWithoutPurchasesReturnItemsInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutPurchasesReturnItemsInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutPurchasesReturnItemsInput, ProductsUncheckedUpdateWithoutPurchasesReturnItemsInput>
  }

  export type ProductsUpdateWithoutPurchasesReturnItemsInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutPurchasesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type PurchasesReturnUpsertWithoutPurchasesReturnItemsInput = {
    update: XOR<PurchasesReturnUpdateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedUpdateWithoutPurchasesReturnItemsInput>
    create: XOR<PurchasesReturnCreateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedCreateWithoutPurchasesReturnItemsInput>
    where?: PurchasesReturnWhereInput
  }

  export type PurchasesReturnUpdateToOneWithWhereWithoutPurchasesReturnItemsInput = {
    where?: PurchasesReturnWhereInput
    data: XOR<PurchasesReturnUpdateWithoutPurchasesReturnItemsInput, PurchasesReturnUncheckedUpdateWithoutPurchasesReturnItemsInput>
  }

  export type PurchasesReturnUpdateWithoutPurchasesReturnItemsInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateWithoutPurchasesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemSerialsUpsertWithWhereUniqueWithoutPurchasesReturnItemsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    update: XOR<PurchaseReturnItemSerialsUpdateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedUpdateWithoutPurchasesReturnItemsInput>
    create: XOR<PurchaseReturnItemSerialsCreateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedCreateWithoutPurchasesReturnItemsInput>
  }

  export type PurchaseReturnItemSerialsUpdateWithWhereUniqueWithoutPurchasesReturnItemsInput = {
    where: PurchaseReturnItemSerialsWhereUniqueInput
    data: XOR<PurchaseReturnItemSerialsUpdateWithoutPurchasesReturnItemsInput, PurchaseReturnItemSerialsUncheckedUpdateWithoutPurchasesReturnItemsInput>
  }

  export type PurchaseReturnItemSerialsUpdateManyWithWhereWithoutPurchasesReturnItemsInput = {
    where: PurchaseReturnItemSerialsScalarWhereInput
    data: XOR<PurchaseReturnItemSerialsUpdateManyMutationInput, PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsInput>
  }

  export type PurchasesReturnItemsCreateWithoutPurchaseReturnItemSerialsInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    Products: ProductsCreateNestedOneWithoutPurchasesReturnItemsInput
    PurchasesReturn: PurchasesReturnCreateNestedOneWithoutPurchasesReturnItemsInput
  }

  export type PurchasesReturnItemsUncheckedCreateWithoutPurchaseReturnItemSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    products_id: number
    purchaseReturn_id: number
  }

  export type PurchasesReturnItemsCreateOrConnectWithoutPurchaseReturnItemSerialsInput = {
    where: PurchasesReturnItemsWhereUniqueInput
    create: XOR<PurchasesReturnItemsCreateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
  }

  export type ProductSerialsCreateWithoutPurchaseReturnItemSerialsInput = {
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductsCreateNestedOneWithoutProductSerialsInput
    SalesItemSerials?: SalesItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsUncheckedCreateWithoutPurchaseReturnItemSerialsInput = {
    id?: number
    serial: string
    product_id: number
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedCreateNestedManyWithoutProductSerialsInput
    salesReturnItems?: SalesReturnItemsUncheckedCreateNestedManyWithoutProductSerialsInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutOldProductSerialsInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedCreateNestedManyWithoutNewProductSerialsInput
  }

  export type ProductSerialsCreateOrConnectWithoutPurchaseReturnItemSerialsInput = {
    where: ProductSerialsWhereUniqueInput
    create: XOR<ProductSerialsCreateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
  }

  export type PurchasesReturnItemsUpsertWithoutPurchaseReturnItemSerialsInput = {
    update: XOR<PurchasesReturnItemsUpdateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
    create: XOR<PurchasesReturnItemsCreateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    where?: PurchasesReturnItemsWhereInput
  }

  export type PurchasesReturnItemsUpdateToOneWithWhereWithoutPurchaseReturnItemSerialsInput = {
    where?: PurchasesReturnItemsWhereInput
    data: XOR<PurchasesReturnItemsUpdateWithoutPurchaseReturnItemSerialsInput, PurchasesReturnItemsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
  }

  export type PurchasesReturnItemsUpdateWithoutPurchaseReturnItemSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
    PurchasesReturn?: PurchasesReturnUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    products_id?: IntFieldUpdateOperationsInput | number
    purchaseReturn_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductSerialsUpsertWithoutPurchaseReturnItemSerialsInput = {
    update: XOR<ProductSerialsUpdateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
    create: XOR<ProductSerialsCreateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedCreateWithoutPurchaseReturnItemSerialsInput>
    where?: ProductSerialsWhereInput
  }

  export type ProductSerialsUpdateToOneWithWhereWithoutPurchaseReturnItemSerialsInput = {
    where?: ProductSerialsWhereInput
    data: XOR<ProductSerialsUpdateWithoutPurchaseReturnItemSerialsInput, ProductSerialsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput>
  }

  export type ProductSerialsUpdateWithoutPurchaseReturnItemSerialsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductsUpdateOneWithoutProductSerialsNestedInput
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutPurchaseReturnItemSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    product_id?: IntFieldUpdateOperationsInput | number
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type CustomersCreateWithoutServicesInput = {
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutServicesInput = {
    id?: number
    custId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    Sales?: SalesUncheckedCreateNestedManyWithoutCustomersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutCustomersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutServicesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutServicesInput, CustomersUncheckedCreateWithoutServicesInput>
  }

  export type UsersCreateWithoutServicesInput = {
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesCreateNestedOneWithoutUsersInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Sales?: SalesCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutServicesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    role_id: number
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Sales?: SalesUncheckedCreateNestedManyWithoutUsersInput
    SalesReturn?: SalesReturnUncheckedCreateNestedManyWithoutUsersInput
    Exchanges?: ExchangesUncheckedCreateNestedManyWithoutUsersInput
    Purchases?: PurchasesUncheckedCreateNestedManyWithoutUsersInput
    PurchasesReturn?: PurchasesReturnUncheckedCreateNestedManyWithoutUsersInput
    createdProducts?: ProductsUncheckedCreateNestedManyWithoutCreatorInput
    updatedProducts?: ProductsUncheckedCreateNestedManyWithoutUpdaterInput
    expenses?: ExpensesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutServicesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutServicesInput, UsersUncheckedCreateWithoutServicesInput>
  }

  export type CustomersUpsertWithoutServicesInput = {
    update: XOR<CustomersUpdateWithoutServicesInput, CustomersUncheckedUpdateWithoutServicesInput>
    create: XOR<CustomersCreateWithoutServicesInput, CustomersUncheckedCreateWithoutServicesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutServicesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutServicesInput, CustomersUncheckedUpdateWithoutServicesInput>
  }

  export type CustomersUpdateWithoutServicesInput = {
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    custId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    Sales?: SalesUncheckedUpdateManyWithoutCustomersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutCustomersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type UsersUpsertWithoutServicesInput = {
    update: XOR<UsersUpdateWithoutServicesInput, UsersUncheckedUpdateWithoutServicesInput>
    create: XOR<UsersCreateWithoutServicesInput, UsersUncheckedCreateWithoutServicesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutServicesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutServicesInput, UsersUncheckedUpdateWithoutServicesInput>
  }

  export type UsersUpdateWithoutServicesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Roles?: RolesUpdateOneWithoutUsersNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    role_id?: IntFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type RolePermissionsCreateManyPermissionsInput = {
    id?: number
    role_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type RolePermissionsUpdateWithoutPermissionsInput = {
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
    Roles?: RolesUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionsUncheckedUpdateManyWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsersCreateManyRolesInput = {
    id?: number
    userId: string
    name: string
    email: string
    password: string
    status?: $Enums.Status
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RolePermissionsCreateManyRolesInput = {
    id?: number
    permission_id: number
    can_view?: boolean
    can_create?: boolean
    can_edit?: boolean
    can_delete?: boolean
  }

  export type UsersUpdateWithoutRolesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUpdateManyWithoutUserNestedInput
    Sales?: SalesUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutUsersNestedInput
    Services?: ServicesUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Sales?: SalesUncheckedUpdateManyWithoutUsersNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutUsersNestedInput
    Purchases?: PurchasesUncheckedUpdateManyWithoutUsersNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutUsersNestedInput
    Services?: ServicesUncheckedUpdateManyWithoutUsersNestedInput
    createdProducts?: ProductsUncheckedUpdateManyWithoutCreatorNestedInput
    updatedProducts?: ProductsUncheckedUpdateManyWithoutUpdaterNestedInput
    expenses?: ExpensesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissionOverrides?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RolePermissionsUpdateWithoutRolesInput = {
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
    Permissions?: PermissionsUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolePermissionsUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    can_view?: BoolFieldUpdateOperationsInput | boolean
    can_create?: BoolFieldUpdateOperationsInput | boolean
    can_edit?: BoolFieldUpdateOperationsInput | boolean
    can_delete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type SalesCreateManyUsersInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    customer_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnCreateManyUsersInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesCreateManyUsersInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesCreateManyUsersInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesReturnCreateManyUsersInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesCreateManyUsersInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    customer_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsCreateManyCreatorInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsCreateManyUpdaterInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    supplier_id?: number | null
    created_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpensesCreateManyUsersInput = {
    id?: number
    expenseNo: string
    title: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesUpdateWithoutUsersInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutSalesNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnUpdateWithoutUsersInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneRequiredWithoutSalesReturnNestedInput
    Customers?: CustomersUpdateOneRequiredWithoutSalesReturnNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesUpdateWithoutUsersInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneWithoutExchangesNestedInput
    Customers?: CustomersUpdateOneWithoutExchangesNestedInput
    ExchangeItems?: ExchangesItemsUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExchangeItems?: ExchangesItemsUncheckedUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesUpdateWithoutUsersInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesReturnUpdateWithoutUsersInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUpdateWithoutUsersInput = {
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutServicesNestedInput
  }

  export type ServicesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUpdateWithoutCreatorInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUpdateWithoutUpdaterInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesUpdateWithoutUsersInput = {
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpensesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesCreateManyCustomersInput = {
    id?: number
    saleNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    totaldiscount?: Decimal | DecimalJsLike | number | string | null
    dueDate?: Date | string | null
    status: string
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnCreateManyCustomersInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesCreateManyCustomersInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    sales_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesCreateManyCustomersInput = {
    id?: number
    serviceNo: string
    serviceProductName: string
    serviceDescription: string
    serviceCost: Decimal | DecimalJsLike | number | string
    serviceStatus: string
    user_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesUpdateWithoutCustomersInput = {
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneWithoutSalesNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutSalesNestedInput
    SalesReturn?: SalesReturnUncheckedUpdateManyWithoutSalesNestedInput
    Exchanges?: ExchangesUncheckedUpdateManyWithoutSalesNestedInput
  }

  export type SalesUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totaldiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnUpdateWithoutCustomersInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneRequiredWithoutSalesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutSalesReturnNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesUpdateWithoutCustomersInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sales?: SalesUpdateOneWithoutExchangesNestedInput
    Users?: UsersUpdateOneWithoutExchangesNestedInput
    ExchangeItems?: ExchangesItemsUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExchangeItems?: ExchangesItemsUncheckedUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    sales_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUpdateWithoutCustomersInput = {
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneWithoutServicesNestedInput
  }

  export type ServicesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceNo?: StringFieldUpdateOperationsInput | string
    serviceProductName?: StringFieldUpdateOperationsInput | string
    serviceDescription?: StringFieldUpdateOperationsInput | string
    serviceCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatus?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesCreateManySuppliersInput = {
    id?: number
    purchaseNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    totalPaid: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    note?: string | null
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesReturnCreateManySuppliersInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    purchase_id: number
    user_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsCreateManySupplierInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    category_id: number
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesUpdateWithoutSuppliersInput = {
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutPurchasesNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutPurchasesNestedInput
    PurchasesReturn?: PurchasesReturnUncheckedUpdateManyWithoutPurchasesNestedInput
  }

  export type PurchasesUncheckedUpdateManyWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesReturnUpdateWithoutSuppliersInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Users?: UsersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsUpdateWithoutSupplierInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Categories?: CategoriesUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    category_id?: IntFieldUpdateOperationsInput | number
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsCreateManyCategoriesInput = {
    id?: number
    productCode: string
    name: string
    specification?: string | null
    description?: string | null
    quantity: number
    purchasePrice: Decimal | DecimalJsLike | number | string
    wholesalePrice: Decimal | DecimalJsLike | number | string
    retailPrice: Decimal | DecimalJsLike | number | string
    useIndividualSerials?: boolean
    productType?: $Enums.ProductType
    status?: $Enums.ProductStatus
    supplier_id?: number | null
    created_by?: number | null
    updated_by?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductsUpdateWithoutCategoriesInput = {
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneWithoutProductsNestedInput
    creator?: UsersUpdateOneWithoutCreatedProductsNestedInput
    updater?: UsersUpdateOneWithoutUpdatedProductsNestedInput
    SalesItems?: SalesItemsUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItems?: SalesItemsUncheckedUpdateManyWithoutProductsNestedInput
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    exchangeItemsOld?: ExchangesItemsUncheckedUpdateManyWithoutOldProductNestedInput
    exchangeItemsNew?: ExchangesItemsUncheckedUpdateManyWithoutNewProductNestedInput
    PurchasesItems?: PurchasesItemsUncheckedUpdateManyWithoutProductsNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutProductsNestedInput
    productSerials?: ProductSerialsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specification?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    useIndividualSerials?: BoolFieldUpdateOperationsInput | boolean
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsCreateManyProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    sales_id: number
  }

  export type SalesReturnItemsCreateManyProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    salesReturn_id: number
    productSerialsId?: number | null
  }

  export type ExchangesItemsCreateManyOldProductInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    newProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesItemsCreateManyNewProductInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    exchangeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesItemsCreateManyProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchase_id: number
  }

  export type PurchasesReturnItemsCreateManyProductsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    purchaseReturn_id: number
  }

  export type ProductSerialsCreateManyProductsInput = {
    id?: number
    serial: string
    status?: $Enums.SerialStatus
    warranty?: $Enums.Warranty
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsUpdateWithoutProductsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Sales?: SalesUpdateOneWithoutSalesItemsNestedInput
    salesItemSerials?: SalesItemSerialsUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFieldUpdateOperationsInput | number
    salesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sales_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemsUpdateWithoutProductsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SalesReturn?: SalesReturnUpdateOneWithoutSalesReturnItemsNestedInput
    productSerials?: ProductSerialsUpdateOneWithoutSalesReturnItemsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExchangesItemsUpdateWithoutOldProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    newProduct?: ProductsUpdateOneWithoutExchangeItemsNewNestedInput
    Exchanges?: ExchangesUpdateOneWithoutExchangeItemsNestedInput
    exchangeItemSerials?: ExchangeItemSerialsUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateWithoutOldProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    newProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutOldProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    newProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesItemsUpdateWithoutNewProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oldProduct?: ProductsUpdateOneWithoutExchangeItemsOldNestedInput
    Exchanges?: ExchangesUpdateOneWithoutExchangeItemsNestedInput
    exchangeItemSerials?: ExchangeItemSerialsUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateWithoutNewProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutNewProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    exchangeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasesItemsUpdateWithoutProductsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Purchases?: PurchasesUpdateOneRequiredWithoutPurchasesItemsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFieldUpdateOperationsInput | number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesReturnItemsUpdateWithoutProductsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PurchasesReturn?: PurchasesReturnUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReturn_id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReturn_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductSerialsUpdateWithoutProductsInput = {
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsNestedInput
    salesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsNestedInput
    exchangeItemSerialsOld?: ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsNestedInput
    exchangeItemSerialsNew?: ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsNestedInput
  }

  export type ProductSerialsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    status?: EnumSerialStatusFieldUpdateOperationsInput | $Enums.SerialStatus
    warranty?: EnumWarrantyFieldUpdateOperationsInput | $Enums.Warranty
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemSerialsCreateManyProductSerialsInput = {
    id?: number
    salesItem_id: number
  }

  export type SalesReturnItemSerialsCreateManyProductSerialsInput = {
    id?: number
    salesReturnItem_id: number
  }

  export type PurchaseItemSerialsCreateManyProductSerialsInput = {
    id?: number
    purchaseItem_id: number
  }

  export type PurchaseReturnItemSerialsCreateManyProductSerialsInput = {
    id?: number
    purchaseReturnItem_id: number
  }

  export type SalesReturnItemsCreateManyProductSerialsInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    salesReturn_id: number
  }

  export type ExchangeItemSerialsCreateManyOldProductSerialsInput = {
    id?: number
    exchangeItem_id: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsCreateManyNewProductSerialsInput = {
    id?: number
    exchangeItem_id: number
    serial_id_old: number
  }

  export type SalesItemSerialsUpdateWithoutProductSerialsInput = {
    SalesItems?: SalesItemsUpdateOneRequiredWithoutSalesItemSerialsNestedInput
  }

  export type SalesItemSerialsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesItemSerialsUncheckedUpdateManyWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemSerialsUpdateWithoutProductSerialsInput = {
    SalesReturnItems?: SalesReturnItemsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput
  }

  export type SalesReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesReturnItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesReturnItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseItemSerialsUpdateWithoutProductSerialsInput = {
    PurchasesItems?: PurchasesItemsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput
  }

  export type PurchaseItemSerialsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseItemSerialsUncheckedUpdateManyWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsUpdateWithoutProductSerialsInput = {
    PurchasesReturnItems?: PurchasesReturnItemsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateManyWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItem_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemsUpdateWithoutProductSerialsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneWithoutSalesReturnItemsNestedInput
    SalesReturn?: SalesReturnUpdateOneWithoutSalesReturnItemsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    salesReturn_id?: IntFieldUpdateOperationsInput | number
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    salesReturn_id?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsUpdateWithoutOldProductSerialsInput = {
    ExchangesItems?: ExchangesItemsUpdateOneRequiredWithoutExchangeItemSerialsNestedInput
    NewProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsNewNestedInput
  }

  export type ExchangeItemSerialsUncheckedUpdateWithoutOldProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutOldProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsUpdateWithoutNewProductSerialsInput = {
    ExchangesItems?: ExchangesItemsUpdateOneRequiredWithoutExchangeItemSerialsNestedInput
    OldProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsOldNestedInput
  }

  export type ExchangeItemSerialsUncheckedUpdateWithoutNewProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutNewProductSerialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeItem_id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
  }

  export type SalesItemsCreateManySalesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string | null
    product_id: number
  }

  export type SalesReturnCreateManySalesInput = {
    id?: number
    returnNo: string
    total_payback: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesCreateManySalesInput = {
    id?: number
    exchangeNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    totalPayback: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    customer_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsUpdateWithoutSalesInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Products?: ProductsUpdateOneWithoutSalesItemsNestedInput
    salesItemSerials?: SalesItemSerialsUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    salesItemSerials?: SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnUpdateWithoutSalesInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutSalesReturnNestedInput
    Customers?: CustomersUpdateOneRequiredWithoutSalesReturnNestedInput
    SalesReturnItems?: SalesReturnItemsUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnItems?: SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnNestedInput
  }

  export type SalesReturnUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    total_payback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangesUpdateWithoutSalesInput = {
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneWithoutExchangesNestedInput
    Customers?: CustomersUpdateOneWithoutExchangesNestedInput
    ExchangeItems?: ExchangesItemsUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExchangeItems?: ExchangesItemsUncheckedUpdateManyWithoutExchangesNestedInput
  }

  export type ExchangesUncheckedUpdateManyWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayback?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemSerialsCreateManySalesItemsInput = {
    id?: number
    serial_id: number
  }

  export type SalesItemSerialsUpdateWithoutSalesItemsInput = {
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutSalesItemSerialsNestedInput
  }

  export type SalesItemSerialsUncheckedUpdateWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesItemSerialsUncheckedUpdateManyWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemsCreateManySalesReturnInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
    productSerialsId?: number | null
  }

  export type SalesReturnItemsUpdateWithoutSalesReturnInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneWithoutSalesReturnItemsNestedInput
    productSerials?: ProductSerialsUpdateOneWithoutSalesReturnItemsNestedInput
    salesReturnItemSerials?: SalesReturnItemSerialsUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateWithoutSalesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
    salesReturnItemSerials?: SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsNestedInput
  }

  export type SalesReturnItemsUncheckedUpdateManyWithoutSalesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    productSerialsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalesReturnItemSerialsCreateManySalesReturnItemsInput = {
    id?: number
    serial_id: number
  }

  export type SalesReturnItemSerialsUpdateWithoutSalesReturnItemsInput = {
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutSalesReturnItemSerialsNestedInput
  }

  export type SalesReturnItemSerialsUncheckedUpdateWithoutSalesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type SalesReturnItemSerialsUncheckedUpdateManyWithoutSalesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangesItemsCreateManyExchangesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    note: string
    oldProduct_id: number
    newProduct_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExchangesItemsUpdateWithoutExchangesInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oldProduct?: ProductsUpdateOneWithoutExchangeItemsOldNestedInput
    newProduct?: ProductsUpdateOneWithoutExchangeItemsNewNestedInput
    exchangeItemSerials?: ExchangeItemSerialsUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateWithoutExchangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    newProduct_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeItemSerials?: ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsNestedInput
  }

  export type ExchangesItemsUncheckedUpdateManyWithoutExchangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    oldProduct_id?: IntFieldUpdateOperationsInput | number
    newProduct_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeItemSerialsCreateManyExchangesItemsInput = {
    id?: number
    serial_id_old: number
    serial_id_new: number
  }

  export type ExchangeItemSerialsUpdateWithoutExchangesItemsInput = {
    OldProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsOldNestedInput
    NewProductSerials?: ProductSerialsUpdateOneRequiredWithoutExchangeItemSerialsNewNestedInput
  }

  export type ExchangeItemSerialsUncheckedUpdateWithoutExchangesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type ExchangeItemSerialsUncheckedUpdateManyWithoutExchangesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id_old?: IntFieldUpdateOperationsInput | number
    serial_id_new?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesItemsCreateManyPurchasesInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    product_id: number
  }

  export type PurchasesReturnCreateManyPurchasesInput = {
    id?: number
    returnNo: string
    totalPaid: Decimal | DecimalJsLike | number | string
    note: string
    user_id: number
    supplier_id: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasesItemsUpdateWithoutPurchasesInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneRequiredWithoutPurchasesItemsNestedInput
    purchaseItemSerials?: PurchaseItemSerialsUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
    purchaseItemSerials?: PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsNestedInput
  }

  export type PurchasesItemsUncheckedUpdateManyWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesReturnUpdateWithoutPurchasesInput = {
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    Suppliers?: SuppliersUpdateOneRequiredWithoutPurchasesReturnNestedInput
    PurchasesReturnItems?: PurchasesReturnItemsUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchasesReturnItems?: PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnNestedInput
  }

  export type PurchasesReturnUncheckedUpdateManyWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    returnNo?: StringFieldUpdateOperationsInput | string
    totalPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemSerialsCreateManyPurchasesItemsInput = {
    id?: number
    serial_id: number
  }

  export type PurchaseItemSerialsUpdateWithoutPurchasesItemsInput = {
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutPurchaseItemSerialsNestedInput
  }

  export type PurchaseItemSerialsUncheckedUpdateWithoutPurchasesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseItemSerialsUncheckedUpdateManyWithoutPurchasesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchasesReturnItemsCreateManyPurchasesReturnInput = {
    id?: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    products_id: number
  }

  export type PurchasesReturnItemsUpdateWithoutPurchasesReturnInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Products?: ProductsUpdateOneRequiredWithoutPurchasesReturnItemsNestedInput
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateWithoutPurchasesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    products_id?: IntFieldUpdateOperationsInput | number
    purchaseReturnItemSerials?: PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsNestedInput
  }

  export type PurchasesReturnItemsUncheckedUpdateManyWithoutPurchasesReturnInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    products_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsCreateManyPurchasesReturnItemsInput = {
    id?: number
    serial_id: number
  }

  export type PurchaseReturnItemSerialsUpdateWithoutPurchasesReturnItemsInput = {
    ProductSerials?: ProductSerialsUpdateOneRequiredWithoutPurchaseReturnItemSerialsNestedInput
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateWithoutPurchasesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseReturnItemSerialsUncheckedUpdateManyWithoutPurchasesReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serial_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}